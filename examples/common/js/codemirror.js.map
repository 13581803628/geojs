{"version":3,"file":"codemirror.js","sources":["../../../../bower_components/jsonlint/lib/jsonlint.js","../../../../bower_components/codemirror/lib/codemirror.js","../../../../bower_components/codemirror/mode/javascript/javascript.js","../../../../bower_components/codemirror/addon/lint/lint.js","../../../../bower_components/codemirror/addon/lint/json-lint.js","../../../../bower_components/codemirror/addon/fold/brace-fold.js","../../../../bower_components/codemirror/addon/fold/foldcode.js","../../../../bower_components/codemirror/addon/fold/foldgutter.js","../../../../bower_components/codemirror/addon/edit/matchbrackets.js"],"names":["jsonlint","parser","trace","yy","symbols_","error","JSONString","STRING","JSONNumber","NUMBER","JSONNullLiteral","NULL","JSONBooleanLiteral","TRUE","FALSE","JSONText","JSONValue","EOF","JSONObject","JSONArray","{","}","JSONMemberList","JSONMember",":",",","[","]","JSONElementList","$accept","$end","terminals_",2,4,6,8,10,11,14,17,18,21,22,23,24,"productions_","performAction","yytext","yyleng","yylineno","yystate","$$","$0","length","this","$","replace","Number","push","table",3,5,7,9,12,13,15,16,1,19,20,25,"defaultActions","parseError","str","Error","parse","input","popStack","n","stack","vstack","lstack","lex","token","self","lexer","recovering","TERROR","setInput","yylloc","yyloc","symbol","preErrorSymbol","state","action","r","p","len","newState","expected","yyval","errStr","showPosition","join","text","match","line","loc","toString","Array","_$","first_line","last_line","first_column","last_column","call","slice","hash","_input","_more","_less","done","matched","conditionStack","ch","lines","unput","more","less","pastInput","past","substr","upcomingInput","next","pre","c","tempMatch","index","rules","_currentRules","i","options","flex","begin","condition","popState","pop","conditions","topState","pushState","yy_","$avoiding_name_collisions","YY_START","INITIAL","inclusive","require","exports","apply","arguments","main","args","process","source","readFileSync","cwd","path","read","charset","module","argv","mod","define","amd","CodeMirror","place","copyObj","defaults","setGuttersForLineNumbers","doc","value","Doc","mode","display","Display","wrapper","updateGutters","themeChanged","lineWrapping","className","autofocus","mobile","focusInput","keyMaps","overlays","modeGen","overwrite","focused","suppressEdits","pasteIncoming","cutIncoming","draggingText","highlight","Delayed","ie","ie_version","setTimeout","bind","resetInput","registerEventHandlers","ensureGlobalHandlers","startOperation","curOp","forceUpdate","attachDoc","activeElt","onFocus","onBlur","opt","optionHandlers","hasOwnProperty","Init","maybeUpdateLineNumberWidth","initHooks","endOperation","d","elt","webkit","style","width","setAttribute","ios","border","inputDiv","scrollbarH","scrollbarV","scrollbarFiller","gutterFiller","lineDiv","selectionDiv","cursorDiv","measure","lineMeasure","lineSpace","mover","sizer","heightForcer","scrollerCutOff","gutters","lineGutter","scroller","zIndex","paddingRight","draggable","khtml","height","position","minHeight","minWidth","appendChild","viewFrom","viewTo","first","view","externalMeasured","viewOffset","lastSizeC","updateLineNumbers","lineNumWidth","lineNumInnerWidth","lineNumChars","prevInput","alignWidgets","pollingFast","poll","cachedCharWidth","cachedTextHeight","cachedPaddingH","inaccurateSelection","maxLine","maxLineLength","maxLineChanged","wheelDX","wheelDY","wheelStartX","wheelStartY","shift","selForContextMenu","loadMode","cm","getMode","modeOption","resetModeState","iter","stateAfter","styles","frontier","startWorker","regChange","wrappingChanged","addClass","rmClass","findMaxLine","estimateLineHeights","clearCaches","updateScrollbars","estimateHeight","th","textHeight","wrapping","perLine","Math","max","clientWidth","charWidth","lineIsHidden","widgetsHeight","widgets","ceil","est","estHeight","updateLineHeight","keyMapChanged","map","keyMap","theme","guttersChanged","alignHorizontally","specs","removeChildren","gutterClass","gElt","updateGutterSpace","offsetWidth","marginLeft","left","fixedGutter","lineLength","merged","cur","collapsedSpanAtStart","found","find","from","to","collapsedSpanAtEnd","getLine","indexOf","lineNumbers","concat","splice","hScrollbarTakesSpace","clientHeight","measureForScrollbars","scroll","barHeight","scrollWidth","barWidth","docHeight","round","paddingVert","sWidth","scrollbarWidth","scrollHeight","needsH","needsV","bottom","firstChild","right","coverGutterNextToScrollbar","checkedOverlayScrollbar","w","mac","mac_geMountainLion","barMouseDown","e","e_target","operation","onMouseDown","on","visibleLines","viewport","top","scrollTop","floor","paddingTop","lineAtHeight","ensure","ensureFrom","ensureTo","heightAtLine","min","lastLine","comp","compensateForHScroll","scrollLeft","gutterW","hidden","gutter","align","alignable","j","last","lineNumberFor","size","test","innerW","padding","String","lineNumberFormatter","firstLineNumber","getBoundingClientRect","DisplayUpdate","force","visible","editorIsHidden","wrapperHeight","oldViewFrom","oldViewTo","oldScrollerWidth","dims","getDimensions","updateDisplayIfNeeded","update","resetView","countDirtyView","end","viewportMargin","sawCollapsedSpans","visualLineNo","visualLineEndNo","different","adjustView","toUpdate","patchDisplay","offsetHeight","focus","postUpdateDisplay","updateHeightsInViewport","barMeasure","updateSelection","setDocumentHeight","signalLater","updateDisplaySimple","checkForWebkitWidthBug","prevBottom","offsetTop","bot","node","box","diff","updateWidgetHeight","rest","gutterLeft","clientLeft","nextSibling","offsetLeft","fixedPos","gutterTotalWidth","gutterWidth","wrapperWidth","updateNumbersFrom","rm","currentWheelTarget","parentNode","removeChild","container","lineN","lineView","updateNumber","lineNumber","changes","updateLineForChanges","document","createTextNode","buildLineElement","insertBefore","type","updateLineText","updateLineGutter","updateLineClasses","updateLineWidgets","ensureLineWrapped","replaceChild","updateLineBackground","cls","bgClass","background","wrap","getLineContent","ext","built","buildLineContent","textClass","wrapClass","markers","gutterMarkers","gutterWrap","k","id","insertLineWidgets","insertLineWidgetsFor","allowAbove","ws","widget","handleMouseEvents","ignoreEvents","positionLineWidget","above","noHScroll","coverGutter","paddingLeft","copyPos","x","Pos","maxPos","a","b","cmp","minPos","Selection","ranges","primIndex","Range","anchor","head","normalizeSelection","prim","sort","prev","inv","empty","simpleSelection","clipLine","clipPos","pos","clipToLen","linelen","isLine","l","clipPosArray","array","out","extendRange","range","other","extend","posBefore","extendSelection","setSelection","sel","primary","extendSelections","heads","newSel","replaceOneSelection","setSimpleSelection","filterSelectionChange","obj","signal","setSelectionReplaceHistory","history","lst","setSelectionNoUndo","addSelectionToHistory","NaN","hasHandler","bias","setSelectionInner","skipAtomicInSelection","ensureCursorVisible","equals","updateInput","selectionChanged","signalCursorActivity","reCheckSelection","sel_dontScroll","mayClear","newAnchor","skipAtomic","newHead","flipped","curPos","dir","cantEdit","search","markedSpans","sp","m","marker","inclusiveLeft","inclusiveRight","explicitlyCleared","atomic","newPos","drawSelection","result","curFragment","cursors","createDocumentFragment","selFragment","selection","collapsed","showCursorWhenSelecting","drawSelectionCursor","drawSelectionRange","moveInputWithCursor","headPos","cursorCoords","wrapOff","lineOff","teTop","teLeft","showSelection","drawn","removeChildrenAndAdd","output","singleCursorHeightPerLine","cursor","cursorHeight","otherCursor","add","fragment","rightSide","drawForLine","fromArg","toArg","coords","charCoords","lineObj","start","lineLen","iterateBidiSections","getOrder","rightPos","leftPos","tmp","leftSide","paddingH","sFrom","sTo","fromLine","toLine","singleVLine","visualLine","leftEnd","rightStart","restartBlink","clearInterval","blinker","visibility","cursorBlinkRate","setInterval","time","startState","set","highlightWorker","Date","workTime","copyState","getStateBefore","changedLines","oldStyles","highlighted","highlightLine","oldCls","styleClasses","newCls","classes","ischange","processLine","workDelay","runInOp","regLineChange","findStartLine","precise","minindent","minline","lim","innerMode","indented","countColumn","tabSize","save","window","getComputedStyle","currentStyle","data","parseInt","isNaN","ensureLineHeights","rect","curWidth","heights","rects","getClientRects","abs","mapFromLineView","cache","maps","caches","lineNo","before","updateExternalMeasurement","LineView","measureChar","measureCharPrepared","prepareMeasureForLine","findViewForLine","findViewIndex","info","hasHeights","prepared","varHeight","key","measureCharInner","bogus","rtop","rbottom","collapse","mStart","mEnd","insertLeft","nodeType","isExtendingChar","charAt","nullRect","maybeUpdateRectForZooming","rSpan","rbot","mid","screen","logicalXDPI","deviceXDPI","hasBadZoomedRects","scaleX","scaleY","logicalYDPI","deviceYDPI","clearLineMeasurementCacheFor","clearLineMeasurementCache","externalMeasure","pageScrollX","pageXOffset","documentElement","body","pageScrollY","pageYOffset","intoCoordSystem","context","widgetHeight","yOff","lOff","xOff","fromCoordSystem","localBox","lineSpaceBox","preparedMeasure","get","getBidi","partPos","part","order","level","bidiLeft","bidiRight","getBidiPartAt","val","bidiOther","estimateCoords","PosWithInfo","outside","xRel","coordsChar","y","coordsCharInner","mergedPos","getX","wrongLine","innerOff","adjust","bidi","dist","lineLeft","lineRight","fromX","fromOutside","toX","toOutside","moveVisually","xDiff","step","middle","middleX","measureText","viewChanged","startHeight","typing","changeObjs","cursorActivityHandlers","cursorActivityCalled","updateMaxLine","scrollToPos","nextOpId","operationGroup","ops","ownsGroup","delayedCallbacks","fireCallbacksForOps","group","callbacks","op","endOperations","endOperation_R1","endOperation_W1","endOperation_R2","endOperation_W2","endOperation_finish","mustUpdate","updatedDisplay","adjustWidthTo","maxScrollLeft","newSelectionNodes","setScrollLeft","forceScroll","scrollPosIntoView","margin","isCursor","maybeScrollWindow","maybeHiddenMarkers","unhidden","maybeUnhiddenMarkers","f","methodOp","docMethodOp","visualLineContinued","buildViewArray","nextPos","lendiff","cut","viewCuttingPoint","cutTop","cutBot","arr","oldN","newN","dirty","slowPoll","pollInterval","readInput","fastPoll","changed","missed","hasSelection","isReadOnly","disableInput","fakedLastChar","substring","somethingSelected","inputHasSelection","withOp","charCodeAt","same","inserted","textLines","splitLines","multiPaste","lastCopied","changeEvent","origin","makeChange","electricChars","smartIndent","getModeAt","changeEnd","indentLine","electricInput","minimal","selected","hasCopyEvent","getSelection","content","selectInput","readOnly","ensureFocus","reFocus","drag_","signalDOMEvent","e_stop","prepareCopyCut","getSelections","lineRange","getRange","setSelections","posFromMouse","clickInGutter","eventInWidget","e_preventDefault","word","findWordAt","captureRightClick","onContextMenu","setScrollTop","onScrollWheel","onKeyUp","onKeyDown","onKeyPress","dragDrop","onDragStart","onDrop","lastMiddleDown","selectionStart","selectionEnd","blur","onResize","setSize","liberal","forRect","target","space","clientX","clientY","colDiff","shiftKey","e_button","leftButtonDown","now","lastDoubleClick","lastClick","modifier","metaKey","ctrlKey","dragAndDrop","contains","leftButtonStartDrag","leftButtonSelect","dragEnd","e2","off","addNew","extendTo","lastPos","startCol","posCol","findColumn","startSel","ourIndex","scrollIntoView","oldRange","ourRange","sel_mouse","curCount","counter","editorSize","Infinity","move","up","lastSelOrigin","altKey","gutterEvent","prevent","signalfn","mX","mY","lineBox","e_defaultPrevented","g","childNodes","lastDrop","files","dataTransfer","FileReader","File","loadFile","file","reader","onload","change","readAsText","getData","listSelections","replaceRange","replaceSelection","setData","setDragImage","safari","img","src","presto","_top","gecko","isScroller","dx","wheelDeltaX","dy","wheelDeltaY","detail","axis","HORIZONTAL_AXIS","VERTICAL_AXIS","wheelDelta","outer","wheelPixelsPerUnit","pixels","wheelSamples","movedX","movedY","sample","doHandleBinding","bound","dropShift","commands","prevShift","Pass","allKeyMaps","extraKeys","handleKeyBinding","startMap","getKeyMap","auto","clearTimeout","maybeTransition","isModifierKey","name","keyName","handled","keymaps","lookupKey","motion","handleCharBinding","keyCode","returnValue","code","lastStoppedKey","showCrossHair","charCode","which","fromCharCode","prepareSelectAllHack","extval","rehide","cssText","oldCSS","scrollPos","selectAll","detectingSelectAll","contextMenuInGutter","reset","resetSelectionOnContextMenu","oldScrollY","scrollY","scrollTo","mouseup","adjustForChange","computeSelAfterChange","offsetPos","old","nw","computeReplacedSel","hint","oldPrev","newPrev","filterChange","canceled","cancel","undefined","ignoreReadOnly","split","sawReadOnlySpans","removeReadOnlyRanges","makeChangeInner","selAfter","addChangeToHistory","makeChangeSingleDoc","stretchSpansOverChange","rebased","linkedDocs","sharedHist","rebaseHist","makeChangeFromHistory","allowSelectionOnly","event","hist","undone","dest","lastOrigin","pushSelectionToHistory","clearRedo","antiChanges","generation","maxGeneration","filter","historyChangeFromChange","after","mergeOldSpans","shiftDoc","distance","spans","removed","getBetween","makeChangeSingleDocInEditor","updateDoc","recomputeMaxLength","checkWidthStart","isWholeLineUpdate","changesHandler","changeHandler","doScroll","innerHeight","phantom","scrollNode","limit","endCoords","calculateScrollPos","startTop","startLeft","x1","y1","x2","y2","snapMargin","screentop","docBottom","atTop","atBottom","newTop","screenleft","screenw","tooWide","addToScrollPos","resolveScrollToPos","getCursor","cursorScrollMargin","sPos","how","aggressive","indent","curSpace","indentation","curSpaceString","indentUnit","indentString","indentWithTabs","spaceStr","changeLine","handle","changeType","no","deleteNearSelection","compute","kill","toKill","replaced","findPosH","unit","visually","findNextLine","possible","moveOnce","boundToLine","moveLogically","origDir","sawType","helper","getHelper","isWordChar","hitSide","findPosV","pageSize","option","deflt","notOnInit","markText","shared","markTextShared","TextMarker","clearWhenEmpty","replacedWith","widgetNode","conflictingCollapsedRange","addToHistory","curLine","addMarkedSpan","MarkedSpan","clearOnEnter","clear","clearHistory","nextMarkerId","title","startStyle","endStyle","cloneNode","linked","isParent","SharedTextMarker","findSharedMarkers","findMarks","parent","copySharedMarkers","mFrom","mTo","subMark","detachSharedMarkers","subMarker","getMarkedSpanFor","span","removeMarkedSpan","attachLine","markedSpansBefore","startCh","isInsert","startsBefore","endsAfter","markedSpansAfter","endCh","oldFirst","oldLast","sameLine","offset","clearEmptySpans","newMarkers","gapMarkers","gap","getOldSpans","stretched","oldCur","stretchCur","mark","parts","mk","newParts","dfrom","dto","detachMarkedSpans","detachLine","attachMarkedSpans","extraLeft","extraRight","compareCollapsedMarkers","lenDiff","aPos","bPos","fromCmp","toCmp","collapsedSpanAtSide","sps","vis","lineIsHiddenInner","adjustScrollWhenAboveVisible","parentStyle","getGutterElement","addLineWidget","LineWidget","insertAt","aboveVisible","updateLine","cleanUpLine","extractLineClasses","lineClass","prop","RegExp","callBlankLine","blankLine","inner","readToken","stream","runMode","lineClasses","forceToEnd","flattenSpans","curStart","curStyle","StringStream","eol","maxHighlightLength","addModeClass","mName","st","o","overlay","at","i_end","opaque","getLineStyles","startAt","interpretTokenStyle","styleToClassCacheWithMode","styleToClassCache","builder","col","addToken","buildToken","getOption","buildTokenSplitSpaces","hasBadBidiRects","buildTokenBadBidi","insertLineContent","joinClasses","zeroWidthElement","defaultSpecialCharPlaceholder","special","specialChars","mustWrap","lastIndex","exec","skipped","txt","tabWidth","specialCharPlaceholder","fullStyle","buildCollapsedSpan","ignoreWidget","allText","spanStyle","spanEndStyle","spanStartStyle","nextChange","foundBookmarks","upto","tokenText","wholeLineUpdateBefore","spansFor","firstLine","lastText","lastSpans","nlines","added","Line","remove","insert","LeafChunk","BranchChunk","children","chunkSize","sharedHistOnly","propagate","skip","rel","chunk","child","sz","getLines","h","lh","bidiOrdering","History","startGen","undoDepth","lastModTime","lastSelTime","lastOp","lastSelOp","histChange","attachLocalSpans","clearSelectionEvents","lastChangeEvent","opId","historyEventDelay","selectionEventCanBeMerged","existing","removeClearedSpans","copyHistoryArray","events","newGroup","instantiateSel","copy","prototype","deepCopy","newChanges","rebaseHistSelSingle","rebaseHistArray","sub","ok","copied","defaultPrevented","srcElement","button","emitter","bnd","_handlers","list","orphanDelayedCallbacks","fireOrphanDelayed","delayed","override","codemirrorIgnore","cursorActivity","eventMixin","ctor","string","goal","nextTab","spaceStrs","createObj","base","props","inst","Object","create","isWordCharBasic","isEmpty","extendingChars","tag","createElement","count","activeElement","classTest","as","forEachCodeMirror","getElementsByClassName","byClass","globalsRegistered","registerGlobalHandlers","resizeTimer","knownScrollbarWidth","zwspSupported","badBidiRects","r0","r1","badZoomedRects","normal","fromRange","lineStart","visual","lineEnd","lineStartSmart","firstNonWS","inWS","compareBidiLevel","linedir","moveInLine","byUnit","navigator","userAgent","ie_upto10","ie_11up","documentMode","qtwebkit","chrome","vendor","platform","windows","presto_version","flipCtrlCmd","cmpPos","here","there","constructor","setOption","getDoc","addKeyMap","removeKeyMap","addOverlay","spec","modeSpec","removeOverlay","indentSelection","newRanges","getTokenAt","current","getTokenTypeAt","getHelpers","helpers","help","helperType","_global","pred","getStateAfter","defaultTextHeight","defaultCharWidth","setGutterMarker","gutterID","clearGutter","removeLineWidget","lineInfo","getViewport","addWidget","vert","horiz","vspace","hspace","triggerOnKeyDown","triggerOnKeyPress","triggerOnKeyUp","execCommand","cmd","amount","moveH","extendSelectionsBy","rtlMoveVisually","sel_move","deleteH","goalColumn","moveV","goals","startChar","check","toggleOverwrite","hasFocus","getScrollInfo","co","interpret","refresh","oldHeight","swapDoc","getInputField","getWrapperElement","getScrollerElement","setValue","integer","disabled","tabIndex","modes","mimeModes","defineMode","dependencies","defineMIME","mime","resolveMode","mfactory","modeObj","modeExtensions","exts","modeProps","skipToEnd","extendMode","properties","defineExtension","func","defineDocExtension","defineOption","defineInitHook","registerHelper","registerGlobalHelper","predicate","nstate","a1","a2","singleSelection","killLine","deleteLine","delLineLeft","delWrappedLineLeft","delWrappedLineRight","undo","redo","undoSelection","redoSelection","goDocStart","goDocEnd","goLineStart","goLineStartSmart","goLineEnd","goLineRight","goLineLeft","goLineLeftSmart","goLineUp","goLineDown","goPageUp","goPageDown","goCharLeft","goCharRight","goColumnLeft","goColumnRight","goWordLeft","goGroupRight","goGroupLeft","goWordRight","delCharBefore","delCharAfter","delWordBefore","delWordAfter","delGroupBefore","delGroupAfter","indentAuto","indentMore","indentLess","insertTab","insertSoftTab","spaces","replaceSelections","defaultTab","transposeChars","newlineAndIndent","basic","Left","Right","Up","Down","End","Home","PageUp","PageDown","Delete","Backspace","Shift-Backspace","Tab","Shift-Tab","Enter","Insert","Esc","pcDefault","Ctrl-A","Ctrl-D","Ctrl-Z","Shift-Ctrl-Z","Ctrl-Y","Ctrl-Home","Ctrl-End","Ctrl-Up","Ctrl-Down","Ctrl-Left","Ctrl-Right","Alt-Left","Alt-Right","Ctrl-Backspace","Ctrl-Delete","Ctrl-S","Ctrl-F","Ctrl-G","Shift-Ctrl-G","Shift-Ctrl-F","Shift-Ctrl-R","Ctrl-[","Ctrl-]","Ctrl-U","Shift-Ctrl-U","Alt-U","fallthrough","macDefault","Cmd-A","Cmd-D","Cmd-Z","Shift-Cmd-Z","Cmd-Y","Cmd-Home","Cmd-Up","Cmd-End","Cmd-Down","Cmd-Left","Cmd-Right","Alt-Backspace","Ctrl-Alt-Backspace","Alt-Delete","Cmd-S","Cmd-F","Cmd-G","Shift-Cmd-G","Cmd-Alt-F","Shift-Cmd-Alt-F","Cmd-[","Cmd-]","Cmd-Backspace","Cmd-Delete","Cmd-U","Shift-Cmd-U","emacsy","Ctrl-B","Ctrl-P","Ctrl-N","Alt-F","Alt-B","Ctrl-E","Ctrl-V","Shift-Ctrl-V","Ctrl-H","Alt-D","Ctrl-K","Ctrl-T","lookup","nofallthrough","keyNames","noShift","altGraphKey","fromTextArea","textarea","getValue","tabindex","placeholder","getAttribute","form","leaveSubmitMethodAlone","realSubmit","submit","wrappedSubmit","getTextArea","toTextArea","lastColumnPos","lastColumnValue","sol","peek","eat","eatWhile","eatSpace","skipTo","backUp","column","pattern","consume","caseInsensitive","cased","toLowerCase","hideFirstChars","side","dHeight","oldH","removeInner","insertInner","iterN","spilled","newleaf","maybeSpill","me","sibling","myIndex","used","nextDocId","cleanGeneration","lineSep","getLineHandle","getLineNumber","getLineHandleVisualStart","lineCount","setCursor","addSelection","dup","setExtending","getExtending","historySize","markClean","changeGeneration","forceSplit","isClean","gen","getHistory","setHistory","histData","addLineClass","where","removeLineClass","setBookmark","realOpts","findMarksAt","getAllMarks","posFromIndex","indexFromPos","copyHistory","linkedDoc","unlinkDoc","link","splitIds","iterLinkedDocs","getEditor","eachLine","dontDelegate","method","preventDefault","e_stopPropagation","stopPropagation","cancelBubble","addEventListener","attachEvent","removeEventListener","detachEvent","ms","startIndex","startValue","select","_e","nonASCIISingleCaseWordChar","toUpperCase","createRange","setEnd","setStart","createTextRange","moveToElementText","moveEnd","moveStart","div","nl","rt","te","ownerDocument","parentElement","compareEndPoints","oncopy",27,32,33,34,35,36,37,38,39,40,44,45,46,59,61,91,92,93,107,109,127,173,186,187,188,189,190,191,192,219,220,221,222,63232,63233,63234,63235,63272,63273,63275,63276,63277,63302,"charType","lowTypes","arabicTypes","BidiSpan","bidiRE","isNeutral","isStrong","countsAsLeft","countsAsNum","outerType","types","nstart","unshift","version","config","parserConfig","readRegexp","escaped","inSet","ret","tp","cont","tokenBase","tokenize","tokenString","tokenComment","lastType","isOperatorChar","tokenQuasi","wordRE","known","keywords","propertyIsEnumerable","quote","jsonldMode","isJsonldKeyword","maybeEnd","findFatArrow","fatArrowAt","arrow","depth","sawSomething","bracket","brackets","JSLexical","inScope","varname","v","localVars","cx","vars","parseJS","cc","marked","lexical","combinator","jsonMode","expression","statement","pass","register","inList","globalVars","pushcontext","defaultVars","popcontext","pushlex","poplex","expect","wanted","exp","vardef","block","maybeelse","functiondef","forspec","maybelabel","funarg","afterModule","afterExport","afterImport","expressionInner","expressionNoComma","noComma","arrowBodyNoComma","arrowBody","commasep","maybeop","maybeoperatorNoComma","maybeoperatorComma","atomicTypes","maybeexpressionNoComma","maybeexpression","comprehension","arrayLiteral","contCommasep","objprop","quasi","expr","property","continueQuasi","getterSetter","afterprop","what","proceed","maybetype","isTS","typedef","maybeAssign","vardefCont","proppattern","_type","forspec1","forspec2","formaybeinof","forspec3","classNameAfter","classBody","classGetterSetter","maybeFrom","importSpec","maybeArrayComprehension","statementIndent","jsonld","json","typescript","wordCharacters","kw","A","B","C","operator","atom","jsKeywords","if","while","with","else","do","try","finally","return","break","continue","new","delete","throw","debugger","var","const","let","function","catch","for","switch","case","default","in","typeof","instanceof","true","false","null","class","super","yield","export","import","extends","tsKeywords","interface","public","private","protected","static","number","bool","any","attr","variable","regexp","jsonld-keyword","basecolumn","textAfter","firstChar","closing","doubleIndentSwitch","blockCommentStart","blockCommentEnd","lineComment","fold","showTooltip","tt","opacity","hideTooltip","showTooltipFor","hide","tooltip","LintState","hasGutter","timeout","onMouseOver","parseOptions","Function","getAnnotations","clearMarks","lint","GUTTER_ID","makeMarker","labels","severity","multiple","tooltips","getMaxSeverity","groupByLine","annotations","ann","annotationTooltip","tip","message","startLinting","passOptions","async","updateLinting","annotationsNotSorted","anns","maxSeverity","tipLabel","formatAnnotation","__annotation","onUpdateLinting","onChange","delay","popupSpanTooltip","hasLintGutter","findOpening","openCh","lineText","lastIndexOf","tokenType","startToken","endToken","nextOpen","nextClose","hasImport","semi","has","hasInclude","doFold","allowFolded","finder","minSize","marks","__isFold","cleared","myWidget","makeWidget","myRange","editorOptions","foldOptions","defaultOptions","newFoldFunction","rangeFinder","toggleFold","foldCode","unfold","foldAll","unfoldAll","funcs","minFoldSize","scanUp","State","opts","indicatorOpen","indicatorFolded","isFolded","updateFoldInfo","foldGutter","updateInViewport","vp","onGutterClick","changeUpdate","foldOnChangeTimeSpan","onViewportChange","updateViewportTimeSpan","onFold","findMatchingBracket","strict","matching","scanForBracket","forward","maxScanLen","maxScanLineLength","maxScanLines","re","bracketRegex","matchBrackets","autoclear","maxHighlightLen","maxHighlightLineLength","ie_lt8","doMatchBrackets","currentlyHighlighted","(",")"],"mappings":"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","sourcesContent":["/* Jison generated parser */\nvar jsonlint = (function(){\nvar parser = {trace: function trace() { },\nyy: {},\nsymbols_: {\"error\":2,\"JSONString\":3,\"STRING\":4,\"JSONNumber\":5,\"NUMBER\":6,\"JSONNullLiteral\":7,\"NULL\":8,\"JSONBooleanLiteral\":9,\"TRUE\":10,\"FALSE\":11,\"JSONText\":12,\"JSONValue\":13,\"EOF\":14,\"JSONObject\":15,\"JSONArray\":16,\"{\":17,\"}\":18,\"JSONMemberList\":19,\"JSONMember\":20,\":\":21,\",\":22,\"[\":23,\"]\":24,\"JSONElementList\":25,\"$accept\":0,\"$end\":1},\nterminals_: {2:\"error\",4:\"STRING\",6:\"NUMBER\",8:\"NULL\",10:\"TRUE\",11:\"FALSE\",14:\"EOF\",17:\"{\",18:\"}\",21:\":\",22:\",\",23:\"[\",24:\"]\"},\nproductions_: [0,[3,1],[5,1],[7,1],[9,1],[9,1],[12,2],[13,1],[13,1],[13,1],[13,1],[13,1],[13,1],[15,2],[15,3],[20,3],[19,1],[19,3],[16,2],[16,3],[25,1],[25,3]],\nperformAction: function anonymous(yytext,yyleng,yylineno,yy,yystate,$$,_$) {\n\nvar $0 = $$.length - 1;\nswitch (yystate) {\ncase 1: // replace escaped characters with actual character\n          this.$ = yytext.replace(/\\\\(\\\\|\")/g, \"$\"+\"1\")\n                     .replace(/\\\\n/g,'\\n')\n                     .replace(/\\\\r/g,'\\r')\n                     .replace(/\\\\t/g,'\\t')\n                     .replace(/\\\\v/g,'\\v')\n                     .replace(/\\\\f/g,'\\f')\n                     .replace(/\\\\b/g,'\\b');\n        \nbreak;\ncase 2:this.$ = Number(yytext);\nbreak;\ncase 3:this.$ = null;\nbreak;\ncase 4:this.$ = true;\nbreak;\ncase 5:this.$ = false;\nbreak;\ncase 6:return this.$ = $$[$0-1];\nbreak;\ncase 13:this.$ = {};\nbreak;\ncase 14:this.$ = $$[$0-1];\nbreak;\ncase 15:this.$ = [$$[$0-2], $$[$0]];\nbreak;\ncase 16:this.$ = {}; this.$[$$[$0][0]] = $$[$0][1];\nbreak;\ncase 17:this.$ = $$[$0-2]; $$[$0-2][$$[$0][0]] = $$[$0][1];\nbreak;\ncase 18:this.$ = [];\nbreak;\ncase 19:this.$ = $$[$0-1];\nbreak;\ncase 20:this.$ = [$$[$0]];\nbreak;\ncase 21:this.$ = $$[$0-2]; $$[$0-2].push($$[$0]);\nbreak;\n}\n},\ntable: [{3:5,4:[1,12],5:6,6:[1,13],7:3,8:[1,9],9:4,10:[1,10],11:[1,11],12:1,13:2,15:7,16:8,17:[1,14],23:[1,15]},{1:[3]},{14:[1,16]},{14:[2,7],18:[2,7],22:[2,7],24:[2,7]},{14:[2,8],18:[2,8],22:[2,8],24:[2,8]},{14:[2,9],18:[2,9],22:[2,9],24:[2,9]},{14:[2,10],18:[2,10],22:[2,10],24:[2,10]},{14:[2,11],18:[2,11],22:[2,11],24:[2,11]},{14:[2,12],18:[2,12],22:[2,12],24:[2,12]},{14:[2,3],18:[2,3],22:[2,3],24:[2,3]},{14:[2,4],18:[2,4],22:[2,4],24:[2,4]},{14:[2,5],18:[2,5],22:[2,5],24:[2,5]},{14:[2,1],18:[2,1],21:[2,1],22:[2,1],24:[2,1]},{14:[2,2],18:[2,2],22:[2,2],24:[2,2]},{3:20,4:[1,12],18:[1,17],19:18,20:19},{3:5,4:[1,12],5:6,6:[1,13],7:3,8:[1,9],9:4,10:[1,10],11:[1,11],13:23,15:7,16:8,17:[1,14],23:[1,15],24:[1,21],25:22},{1:[2,6]},{14:[2,13],18:[2,13],22:[2,13],24:[2,13]},{18:[1,24],22:[1,25]},{18:[2,16],22:[2,16]},{21:[1,26]},{14:[2,18],18:[2,18],22:[2,18],24:[2,18]},{22:[1,28],24:[1,27]},{22:[2,20],24:[2,20]},{14:[2,14],18:[2,14],22:[2,14],24:[2,14]},{3:20,4:[1,12],20:29},{3:5,4:[1,12],5:6,6:[1,13],7:3,8:[1,9],9:4,10:[1,10],11:[1,11],13:30,15:7,16:8,17:[1,14],23:[1,15]},{14:[2,19],18:[2,19],22:[2,19],24:[2,19]},{3:5,4:[1,12],5:6,6:[1,13],7:3,8:[1,9],9:4,10:[1,10],11:[1,11],13:31,15:7,16:8,17:[1,14],23:[1,15]},{18:[2,17],22:[2,17]},{18:[2,15],22:[2,15]},{22:[2,21],24:[2,21]}],\ndefaultActions: {16:[2,6]},\nparseError: function parseError(str, hash) {\n    throw new Error(str);\n},\nparse: function parse(input) {\n    var self = this,\n        stack = [0],\n        vstack = [null], // semantic value stack\n        lstack = [], // location stack\n        table = this.table,\n        yytext = '',\n        yylineno = 0,\n        yyleng = 0,\n        recovering = 0,\n        TERROR = 2,\n        EOF = 1;\n\n    //this.reductionCount = this.shiftCount = 0;\n\n    this.lexer.setInput(input);\n    this.lexer.yy = this.yy;\n    this.yy.lexer = this.lexer;\n    if (typeof this.lexer.yylloc == 'undefined')\n        this.lexer.yylloc = {};\n    var yyloc = this.lexer.yylloc;\n    lstack.push(yyloc);\n\n    if (typeof this.yy.parseError === 'function')\n        this.parseError = this.yy.parseError;\n\n    function popStack (n) {\n        stack.length = stack.length - 2*n;\n        vstack.length = vstack.length - n;\n        lstack.length = lstack.length - n;\n    }\n\n    function lex() {\n        var token;\n        token = self.lexer.lex() || 1; // $end = 1\n        // if token isn't its numeric value, convert\n        if (typeof token !== 'number') {\n            token = self.symbols_[token] || token;\n        }\n        return token;\n    }\n\n    var symbol, preErrorSymbol, state, action, a, r, yyval={},p,len,newState, expected;\n    while (true) {\n        // retreive state number from top of stack\n        state = stack[stack.length-1];\n\n        // use default actions if available\n        if (this.defaultActions[state]) {\n            action = this.defaultActions[state];\n        } else {\n            if (symbol == null)\n                symbol = lex();\n            // read action for current state and first input\n            action = table[state] && table[state][symbol];\n        }\n\n        // handle parse error\n        _handle_error:\n        if (typeof action === 'undefined' || !action.length || !action[0]) {\n\n            if (!recovering) {\n                // Report error\n                expected = [];\n                for (p in table[state]) if (this.terminals_[p] && p > 2) {\n                    expected.push(\"'\"+this.terminals_[p]+\"'\");\n                }\n                var errStr = '';\n                if (this.lexer.showPosition) {\n                    errStr = 'Parse error on line '+(yylineno+1)+\":\\n\"+this.lexer.showPosition()+\"\\nExpecting \"+expected.join(', ') + \", got '\" + this.terminals_[symbol]+ \"'\";\n                } else {\n                    errStr = 'Parse error on line '+(yylineno+1)+\": Unexpected \" +\n                                  (symbol == 1 /*EOF*/ ? \"end of input\" :\n                                              (\"'\"+(this.terminals_[symbol] || symbol)+\"'\"));\n                }\n                this.parseError(errStr,\n                    {text: this.lexer.match, token: this.terminals_[symbol] || symbol, line: this.lexer.yylineno, loc: yyloc, expected: expected});\n            }\n\n            // just recovered from another error\n            if (recovering == 3) {\n                if (symbol == EOF) {\n                    throw new Error(errStr || 'Parsing halted.');\n                }\n\n                // discard current lookahead and grab another\n                yyleng = this.lexer.yyleng;\n                yytext = this.lexer.yytext;\n                yylineno = this.lexer.yylineno;\n                yyloc = this.lexer.yylloc;\n                symbol = lex();\n            }\n\n            // try to recover from error\n            while (1) {\n                // check for error recovery rule in this state\n                if ((TERROR.toString()) in table[state]) {\n                    break;\n                }\n                if (state == 0) {\n                    throw new Error(errStr || 'Parsing halted.');\n                }\n                popStack(1);\n                state = stack[stack.length-1];\n            }\n\n            preErrorSymbol = symbol; // save the lookahead token\n            symbol = TERROR;         // insert generic error symbol as new lookahead\n            state = stack[stack.length-1];\n            action = table[state] && table[state][TERROR];\n            recovering = 3; // allow 3 real symbols to be shifted before reporting a new error\n        }\n\n        // this shouldn't happen, unless resolve defaults are off\n        if (action[0] instanceof Array && action.length > 1) {\n            throw new Error('Parse Error: multiple actions possible at state: '+state+', token: '+symbol);\n        }\n\n        switch (action[0]) {\n\n            case 1: // shift\n                //this.shiftCount++;\n\n                stack.push(symbol);\n                vstack.push(this.lexer.yytext);\n                lstack.push(this.lexer.yylloc);\n                stack.push(action[1]); // push state\n                symbol = null;\n                if (!preErrorSymbol) { // normal execution/no error\n                    yyleng = this.lexer.yyleng;\n                    yytext = this.lexer.yytext;\n                    yylineno = this.lexer.yylineno;\n                    yyloc = this.lexer.yylloc;\n                    if (recovering > 0)\n                        recovering--;\n                } else { // error just occurred, resume old lookahead f/ before error\n                    symbol = preErrorSymbol;\n                    preErrorSymbol = null;\n                }\n                break;\n\n            case 2: // reduce\n                //this.reductionCount++;\n\n                len = this.productions_[action[1]][1];\n\n                // perform semantic action\n                yyval.$ = vstack[vstack.length-len]; // default to $$ = $1\n                // default location, uses first token for firsts, last for lasts\n                yyval._$ = {\n                    first_line: lstack[lstack.length-(len||1)].first_line,\n                    last_line: lstack[lstack.length-1].last_line,\n                    first_column: lstack[lstack.length-(len||1)].first_column,\n                    last_column: lstack[lstack.length-1].last_column\n                };\n                r = this.performAction.call(yyval, yytext, yyleng, yylineno, this.yy, action[1], vstack, lstack);\n\n                if (typeof r !== 'undefined') {\n                    return r;\n                }\n\n                // pop off stack\n                if (len) {\n                    stack = stack.slice(0,-1*len*2);\n                    vstack = vstack.slice(0, -1*len);\n                    lstack = lstack.slice(0, -1*len);\n                }\n\n                stack.push(this.productions_[action[1]][0]);    // push nonterminal (reduce)\n                vstack.push(yyval.$);\n                lstack.push(yyval._$);\n                // goto new state = table[STATE][NONTERMINAL]\n                newState = table[stack[stack.length-2]][stack[stack.length-1]];\n                stack.push(newState);\n                break;\n\n            case 3: // accept\n                return true;\n        }\n\n    }\n\n    return true;\n}};\n/* Jison generated lexer */\nvar lexer = (function(){\nvar lexer = ({EOF:1,\nparseError:function parseError(str, hash) {\n        if (this.yy.parseError) {\n            this.yy.parseError(str, hash);\n        } else {\n            throw new Error(str);\n        }\n    },\nsetInput:function (input) {\n        this._input = input;\n        this._more = this._less = this.done = false;\n        this.yylineno = this.yyleng = 0;\n        this.yytext = this.matched = this.match = '';\n        this.conditionStack = ['INITIAL'];\n        this.yylloc = {first_line:1,first_column:0,last_line:1,last_column:0};\n        return this;\n    },\ninput:function () {\n        var ch = this._input[0];\n        this.yytext+=ch;\n        this.yyleng++;\n        this.match+=ch;\n        this.matched+=ch;\n        var lines = ch.match(/\\n/);\n        if (lines) this.yylineno++;\n        this._input = this._input.slice(1);\n        return ch;\n    },\nunput:function (ch) {\n        this._input = ch + this._input;\n        return this;\n    },\nmore:function () {\n        this._more = true;\n        return this;\n    },\nless:function (n) {\n        this._input = this.match.slice(n) + this._input;\n    },\npastInput:function () {\n        var past = this.matched.substr(0, this.matched.length - this.match.length);\n        return (past.length > 20 ? '...':'') + past.substr(-20).replace(/\\n/g, \"\");\n    },\nupcomingInput:function () {\n        var next = this.match;\n        if (next.length < 20) {\n            next += this._input.substr(0, 20-next.length);\n        }\n        return (next.substr(0,20)+(next.length > 20 ? '...':'')).replace(/\\n/g, \"\");\n    },\nshowPosition:function () {\n        var pre = this.pastInput();\n        var c = new Array(pre.length + 1).join(\"-\");\n        return pre + this.upcomingInput() + \"\\n\" + c+\"^\";\n    },\nnext:function () {\n        if (this.done) {\n            return this.EOF;\n        }\n        if (!this._input) this.done = true;\n\n        var token,\n            match,\n            tempMatch,\n            index,\n            col,\n            lines;\n        if (!this._more) {\n            this.yytext = '';\n            this.match = '';\n        }\n        var rules = this._currentRules();\n        for (var i=0;i < rules.length; i++) {\n            tempMatch = this._input.match(this.rules[rules[i]]);\n            if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {\n                match = tempMatch;\n                index = i;\n                if (!this.options.flex) break;\n            }\n        }\n        if (match) {\n            lines = match[0].match(/\\n.*/g);\n            if (lines) this.yylineno += lines.length;\n            this.yylloc = {first_line: this.yylloc.last_line,\n                           last_line: this.yylineno+1,\n                           first_column: this.yylloc.last_column,\n                           last_column: lines ? lines[lines.length-1].length-1 : this.yylloc.last_column + match[0].length}\n            this.yytext += match[0];\n            this.match += match[0];\n            this.yyleng = this.yytext.length;\n            this._more = false;\n            this._input = this._input.slice(match[0].length);\n            this.matched += match[0];\n            token = this.performAction.call(this, this.yy, this, rules[index],this.conditionStack[this.conditionStack.length-1]);\n            if (this.done && this._input) this.done = false;\n            if (token) return token;\n            else return;\n        }\n        if (this._input === \"\") {\n            return this.EOF;\n        } else {\n            this.parseError('Lexical error on line '+(this.yylineno+1)+'. Unrecognized text.\\n'+this.showPosition(), \n                    {text: \"\", token: null, line: this.yylineno});\n        }\n    },\nlex:function lex() {\n        var r = this.next();\n        if (typeof r !== 'undefined') {\n            return r;\n        } else {\n            return this.lex();\n        }\n    },\nbegin:function begin(condition) {\n        this.conditionStack.push(condition);\n    },\npopState:function popState() {\n        return this.conditionStack.pop();\n    },\n_currentRules:function _currentRules() {\n        return this.conditions[this.conditionStack[this.conditionStack.length-1]].rules;\n    },\ntopState:function () {\n        return this.conditionStack[this.conditionStack.length-2];\n    },\npushState:function begin(condition) {\n        this.begin(condition);\n    }});\nlexer.options = {};\nlexer.performAction = function anonymous(yy,yy_,$avoiding_name_collisions,YY_START) {\n\nvar YYSTATE=YY_START\nswitch($avoiding_name_collisions) {\ncase 0:/* skip whitespace */\nbreak;\ncase 1:return 6\nbreak;\ncase 2:yy_.yytext = yy_.yytext.substr(1,yy_.yyleng-2); return 4\nbreak;\ncase 3:return 17\nbreak;\ncase 4:return 18\nbreak;\ncase 5:return 23\nbreak;\ncase 6:return 24\nbreak;\ncase 7:return 22\nbreak;\ncase 8:return 21\nbreak;\ncase 9:return 10\nbreak;\ncase 10:return 11\nbreak;\ncase 11:return 8\nbreak;\ncase 12:return 14\nbreak;\ncase 13:return 'INVALID'\nbreak;\n}\n};\nlexer.rules = [/^(?:\\s+)/,/^(?:(-?([0-9]|[1-9][0-9]+))(\\.[0-9]+)?([eE][-+]?[0-9]+)?\\b)/,/^(?:\"(?:\\\\[\\\\\"bfnrt/]|\\\\u[a-fA-F0-9]{4}|[^\\\\\\0-\\x09\\x0a-\\x1f\"])*\")/,/^(?:\\{)/,/^(?:\\})/,/^(?:\\[)/,/^(?:\\])/,/^(?:,)/,/^(?::)/,/^(?:true\\b)/,/^(?:false\\b)/,/^(?:null\\b)/,/^(?:$)/,/^(?:.)/];\nlexer.conditions = {\"INITIAL\":{\"rules\":[0,1,2,3,4,5,6,7,8,9,10,11,12,13],\"inclusive\":true}};\n\n\n;\nreturn lexer;})()\nparser.lexer = lexer;\nreturn parser;\n})();\nif (typeof require !== 'undefined' && typeof exports !== 'undefined') {\nexports.parser = jsonlint;\nexports.parse = function () { return jsonlint.parse.apply(jsonlint, arguments); }\nexports.main = function commonjsMain(args) {\n    if (!args[1])\n        throw new Error('Usage: '+args[0]+' FILE');\n    if (typeof process !== 'undefined') {\n        var source = require('fs').readFileSync(require('path').join(process.cwd(), args[1]), \"utf8\");\n    } else {\n        var cwd = require(\"file\").path(require(\"file\").cwd());\n        var source = cwd.join(args[1]).read({charset: \"utf-8\"});\n    }\n    return exports.parser.parse(source);\n}\nif (typeof module !== 'undefined' && require.main === module) {\n  exports.main(typeof process !== 'undefined' ? process.argv.slice(1) : require(\"system\").args);\n}\n}","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n// This is CodeMirror (http://codemirror.net), a code editor\n// implemented in JavaScript on top of the browser's DOM.\n//\n// You can find some technical background for some of the code below\n// at http://marijnhaverbeke.nl/blog/#cm-internals .\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    module.exports = mod();\n  else if (typeof define == \"function\" && define.amd) // AMD\n    return define([], mod);\n  else // Plain browser env\n    this.CodeMirror = mod();\n})(function() {\n  \"use strict\";\n\n  // BROWSER SNIFFING\n\n  // Kludges for bugs and behavior differences that can't be feature\n  // detected are enabled based on userAgent etc sniffing.\n\n  var gecko = /gecko\\/\\d/i.test(navigator.userAgent);\n  // ie_uptoN means Internet Explorer version N or lower\n  var ie_upto10 = /MSIE \\d/.test(navigator.userAgent);\n  var ie_11up = /Trident\\/(?:[7-9]|\\d{2,})\\..*rv:(\\d+)/.exec(navigator.userAgent);\n  var ie = ie_upto10 || ie_11up;\n  var ie_version = ie && (ie_upto10 ? document.documentMode || 6 : ie_11up[1]);\n  var webkit = /WebKit\\//.test(navigator.userAgent);\n  var qtwebkit = webkit && /Qt\\/\\d+\\.\\d+/.test(navigator.userAgent);\n  var chrome = /Chrome\\//.test(navigator.userAgent);\n  var presto = /Opera\\//.test(navigator.userAgent);\n  var safari = /Apple Computer/.test(navigator.vendor);\n  var khtml = /KHTML\\//.test(navigator.userAgent);\n  var mac_geMountainLion = /Mac OS X 1\\d\\D([8-9]|\\d\\d)\\D/.test(navigator.userAgent);\n  var phantom = /PhantomJS/.test(navigator.userAgent);\n\n  var ios = /AppleWebKit/.test(navigator.userAgent) && /Mobile\\/\\w+/.test(navigator.userAgent);\n  // This is woefully incomplete. Suggestions for alternative methods welcome.\n  var mobile = ios || /Android|webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(navigator.userAgent);\n  var mac = ios || /Mac/.test(navigator.platform);\n  var windows = /win/i.test(navigator.platform);\n\n  var presto_version = presto && navigator.userAgent.match(/Version\\/(\\d*\\.\\d*)/);\n  if (presto_version) presto_version = Number(presto_version[1]);\n  if (presto_version && presto_version >= 15) { presto = false; webkit = true; }\n  // Some browsers use the wrong event properties to signal cmd/ctrl on OS X\n  var flipCtrlCmd = mac && (qtwebkit || presto && (presto_version == null || presto_version < 12.11));\n  var captureRightClick = gecko || (ie && ie_version >= 9);\n\n  // Optimize some code when these features are not used.\n  var sawReadOnlySpans = false, sawCollapsedSpans = false;\n\n  // EDITOR CONSTRUCTOR\n\n  // A CodeMirror instance represents an editor. This is the object\n  // that user code is usually dealing with.\n\n  function CodeMirror(place, options) {\n    if (!(this instanceof CodeMirror)) return new CodeMirror(place, options);\n\n    this.options = options = options ? copyObj(options) : {};\n    // Determine effective options based on given values and defaults.\n    copyObj(defaults, options, false);\n    setGuttersForLineNumbers(options);\n\n    var doc = options.value;\n    if (typeof doc == \"string\") doc = new Doc(doc, options.mode);\n    this.doc = doc;\n\n    var display = this.display = new Display(place, doc);\n    display.wrapper.CodeMirror = this;\n    updateGutters(this);\n    themeChanged(this);\n    if (options.lineWrapping)\n      this.display.wrapper.className += \" CodeMirror-wrap\";\n    if (options.autofocus && !mobile) focusInput(this);\n\n    this.state = {\n      keyMaps: [],  // stores maps added by addKeyMap\n      overlays: [], // highlighting overlays, as added by addOverlay\n      modeGen: 0,   // bumped when mode/overlay changes, used to invalidate highlighting info\n      overwrite: false, focused: false,\n      suppressEdits: false, // used to disable editing during key handlers when in readOnly mode\n      pasteIncoming: false, cutIncoming: false, // help recognize paste/cut edits in readInput\n      draggingText: false,\n      highlight: new Delayed() // stores highlight worker timeout\n    };\n\n    // Override magic textarea content restore that IE sometimes does\n    // on our hidden textarea on reload\n    if (ie && ie_version < 11) setTimeout(bind(resetInput, this, true), 20);\n\n    registerEventHandlers(this);\n    ensureGlobalHandlers();\n\n    startOperation(this);\n    this.curOp.forceUpdate = true;\n    attachDoc(this, doc);\n\n    if ((options.autofocus && !mobile) || activeElt() == display.input)\n      setTimeout(bind(onFocus, this), 20);\n    else\n      onBlur(this);\n\n    for (var opt in optionHandlers) if (optionHandlers.hasOwnProperty(opt))\n      optionHandlers[opt](this, options[opt], Init);\n    maybeUpdateLineNumberWidth(this);\n    for (var i = 0; i < initHooks.length; ++i) initHooks[i](this);\n    endOperation(this);\n  }\n\n  // DISPLAY CONSTRUCTOR\n\n  // The display handles the DOM integration, both for input reading\n  // and content drawing. It holds references to DOM nodes and\n  // display-related state.\n\n  function Display(place, doc) {\n    var d = this;\n\n    // The semihidden textarea that is focused when the editor is\n    // focused, and receives input.\n    var input = d.input = elt(\"textarea\", null, null, \"position: absolute; padding: 0; width: 1px; height: 1em; outline: none\");\n    // The textarea is kept positioned near the cursor to prevent the\n    // fact that it'll be scrolled into view on input from scrolling\n    // our fake cursor out of view. On webkit, when wrap=off, paste is\n    // very slow. So make the area wide instead.\n    if (webkit) input.style.width = \"1000px\";\n    else input.setAttribute(\"wrap\", \"off\");\n    // If border: 0; -- iOS fails to open keyboard (issue #1287)\n    if (ios) input.style.border = \"1px solid black\";\n    input.setAttribute(\"autocorrect\", \"off\"); input.setAttribute(\"autocapitalize\", \"off\"); input.setAttribute(\"spellcheck\", \"false\");\n\n    // Wraps and hides input textarea\n    d.inputDiv = elt(\"div\", [input], null, \"overflow: hidden; position: relative; width: 3px; height: 0px;\");\n    // The fake scrollbar elements.\n    d.scrollbarH = elt(\"div\", [elt(\"div\", null, null, \"height: 100%; min-height: 1px\")], \"CodeMirror-hscrollbar\");\n    d.scrollbarV = elt(\"div\", [elt(\"div\", null, null, \"min-width: 1px\")], \"CodeMirror-vscrollbar\");\n    // Covers bottom-right square when both scrollbars are present.\n    d.scrollbarFiller = elt(\"div\", null, \"CodeMirror-scrollbar-filler\");\n    // Covers bottom of gutter when coverGutterNextToScrollbar is on\n    // and h scrollbar is present.\n    d.gutterFiller = elt(\"div\", null, \"CodeMirror-gutter-filler\");\n    // Will contain the actual code, positioned to cover the viewport.\n    d.lineDiv = elt(\"div\", null, \"CodeMirror-code\");\n    // Elements are added to these to represent selection and cursors.\n    d.selectionDiv = elt(\"div\", null, null, \"position: relative; z-index: 1\");\n    d.cursorDiv = elt(\"div\", null, \"CodeMirror-cursors\");\n    // A visibility: hidden element used to find the size of things.\n    d.measure = elt(\"div\", null, \"CodeMirror-measure\");\n    // When lines outside of the viewport are measured, they are drawn in this.\n    d.lineMeasure = elt(\"div\", null, \"CodeMirror-measure\");\n    // Wraps everything that needs to exist inside the vertically-padded coordinate system\n    d.lineSpace = elt(\"div\", [d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv],\n                      null, \"position: relative; outline: none\");\n    // Moved around its parent to cover visible view.\n    d.mover = elt(\"div\", [elt(\"div\", [d.lineSpace], \"CodeMirror-lines\")], null, \"position: relative\");\n    // Set to the height of the document, allowing scrolling.\n    d.sizer = elt(\"div\", [d.mover], \"CodeMirror-sizer\");\n    // Behavior of elts with overflow: auto and padding is\n    // inconsistent across browsers. This is used to ensure the\n    // scrollable area is big enough.\n    d.heightForcer = elt(\"div\", null, null, \"position: absolute; height: \" + scrollerCutOff + \"px; width: 1px;\");\n    // Will contain the gutters, if any.\n    d.gutters = elt(\"div\", null, \"CodeMirror-gutters\");\n    d.lineGutter = null;\n    // Actual scrollable element.\n    d.scroller = elt(\"div\", [d.sizer, d.heightForcer, d.gutters], \"CodeMirror-scroll\");\n    d.scroller.setAttribute(\"tabIndex\", \"-1\");\n    // The element in which the editor lives.\n    d.wrapper = elt(\"div\", [d.inputDiv, d.scrollbarH, d.scrollbarV,\n                            d.scrollbarFiller, d.gutterFiller, d.scroller], \"CodeMirror\");\n\n    // Work around IE7 z-index bug (not perfect, hence IE7 not really being supported)\n    if (ie && ie_version < 8) { d.gutters.style.zIndex = -1; d.scroller.style.paddingRight = 0; }\n    // Needed to hide big blue blinking cursor on Mobile Safari\n    if (ios) input.style.width = \"0px\";\n    if (!webkit) d.scroller.draggable = true;\n    // Needed to handle Tab key in KHTML\n    if (khtml) { d.inputDiv.style.height = \"1px\"; d.inputDiv.style.position = \"absolute\"; }\n    // Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8).\n    if (ie && ie_version < 8) d.scrollbarH.style.minHeight = d.scrollbarV.style.minWidth = \"18px\";\n\n    if (place.appendChild) place.appendChild(d.wrapper);\n    else place(d.wrapper);\n\n    // Current rendered range (may be bigger than the view window).\n    d.viewFrom = d.viewTo = doc.first;\n    // Information about the rendered lines.\n    d.view = [];\n    // Holds info about a single rendered line when it was rendered\n    // for measurement, while not in view.\n    d.externalMeasured = null;\n    // Empty space (in pixels) above the view\n    d.viewOffset = 0;\n    d.lastSizeC = 0;\n    d.updateLineNumbers = null;\n\n    // Used to only resize the line number gutter when necessary (when\n    // the amount of lines crosses a boundary that makes its width change)\n    d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;\n    // See readInput and resetInput\n    d.prevInput = \"\";\n    // Set to true when a non-horizontal-scrolling line widget is\n    // added. As an optimization, line widget aligning is skipped when\n    // this is false.\n    d.alignWidgets = false;\n    // Flag that indicates whether we expect input to appear real soon\n    // now (after some event like 'keypress' or 'input') and are\n    // polling intensively.\n    d.pollingFast = false;\n    // Self-resetting timeout for the poller\n    d.poll = new Delayed();\n\n    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;\n\n    // Tracks when resetInput has punted to just putting a short\n    // string into the textarea instead of the full selection.\n    d.inaccurateSelection = false;\n\n    // Tracks the maximum line length so that the horizontal scrollbar\n    // can be kept static when scrolling.\n    d.maxLine = null;\n    d.maxLineLength = 0;\n    d.maxLineChanged = false;\n\n    // Used for measuring wheel scrolling granularity\n    d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;\n\n    // True when shift is held down.\n    d.shift = false;\n\n    // Used to track whether anything happened since the context menu\n    // was opened.\n    d.selForContextMenu = null;\n  }\n\n  // STATE UPDATES\n\n  // Used to get the editor into a consistent state again when options change.\n\n  function loadMode(cm) {\n    cm.doc.mode = CodeMirror.getMode(cm.options, cm.doc.modeOption);\n    resetModeState(cm);\n  }\n\n  function resetModeState(cm) {\n    cm.doc.iter(function(line) {\n      if (line.stateAfter) line.stateAfter = null;\n      if (line.styles) line.styles = null;\n    });\n    cm.doc.frontier = cm.doc.first;\n    startWorker(cm, 100);\n    cm.state.modeGen++;\n    if (cm.curOp) regChange(cm);\n  }\n\n  function wrappingChanged(cm) {\n    if (cm.options.lineWrapping) {\n      addClass(cm.display.wrapper, \"CodeMirror-wrap\");\n      cm.display.sizer.style.minWidth = \"\";\n    } else {\n      rmClass(cm.display.wrapper, \"CodeMirror-wrap\");\n      findMaxLine(cm);\n    }\n    estimateLineHeights(cm);\n    regChange(cm);\n    clearCaches(cm);\n    setTimeout(function(){updateScrollbars(cm);}, 100);\n  }\n\n  // Returns a function that estimates the height of a line, to use as\n  // first approximation until the line becomes visible (and is thus\n  // properly measurable).\n  function estimateHeight(cm) {\n    var th = textHeight(cm.display), wrapping = cm.options.lineWrapping;\n    var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);\n    return function(line) {\n      if (lineIsHidden(cm.doc, line)) return 0;\n\n      var widgetsHeight = 0;\n      if (line.widgets) for (var i = 0; i < line.widgets.length; i++) {\n        if (line.widgets[i].height) widgetsHeight += line.widgets[i].height;\n      }\n\n      if (wrapping)\n        return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th;\n      else\n        return widgetsHeight + th;\n    };\n  }\n\n  function estimateLineHeights(cm) {\n    var doc = cm.doc, est = estimateHeight(cm);\n    doc.iter(function(line) {\n      var estHeight = est(line);\n      if (estHeight != line.height) updateLineHeight(line, estHeight);\n    });\n  }\n\n  function keyMapChanged(cm) {\n    var map = keyMap[cm.options.keyMap], style = map.style;\n    cm.display.wrapper.className = cm.display.wrapper.className.replace(/\\s*cm-keymap-\\S+/g, \"\") +\n      (style ? \" cm-keymap-\" + style : \"\");\n  }\n\n  function themeChanged(cm) {\n    cm.display.wrapper.className = cm.display.wrapper.className.replace(/\\s*cm-s-\\S+/g, \"\") +\n      cm.options.theme.replace(/(^|\\s)\\s*/g, \" cm-s-\");\n    clearCaches(cm);\n  }\n\n  function guttersChanged(cm) {\n    updateGutters(cm);\n    regChange(cm);\n    setTimeout(function(){alignHorizontally(cm);}, 20);\n  }\n\n  // Rebuild the gutter elements, ensure the margin to the left of the\n  // code matches their width.\n  function updateGutters(cm) {\n    var gutters = cm.display.gutters, specs = cm.options.gutters;\n    removeChildren(gutters);\n    for (var i = 0; i < specs.length; ++i) {\n      var gutterClass = specs[i];\n      var gElt = gutters.appendChild(elt(\"div\", null, \"CodeMirror-gutter \" + gutterClass));\n      if (gutterClass == \"CodeMirror-linenumbers\") {\n        cm.display.lineGutter = gElt;\n        gElt.style.width = (cm.display.lineNumWidth || 1) + \"px\";\n      }\n    }\n    gutters.style.display = i ? \"\" : \"none\";\n    updateGutterSpace(cm);\n  }\n\n  function updateGutterSpace(cm) {\n    var width = cm.display.gutters.offsetWidth;\n    cm.display.sizer.style.marginLeft = width + \"px\";\n    cm.display.scrollbarH.style.left = cm.options.fixedGutter ? width + \"px\" : 0;\n  }\n\n  // Compute the character length of a line, taking into account\n  // collapsed ranges (see markText) that might hide parts, and join\n  // other lines onto it.\n  function lineLength(line) {\n    if (line.height == 0) return 0;\n    var len = line.text.length, merged, cur = line;\n    while (merged = collapsedSpanAtStart(cur)) {\n      var found = merged.find(0, true);\n      cur = found.from.line;\n      len += found.from.ch - found.to.ch;\n    }\n    cur = line;\n    while (merged = collapsedSpanAtEnd(cur)) {\n      var found = merged.find(0, true);\n      len -= cur.text.length - found.from.ch;\n      cur = found.to.line;\n      len += cur.text.length - found.to.ch;\n    }\n    return len;\n  }\n\n  // Find the longest line in the document.\n  function findMaxLine(cm) {\n    var d = cm.display, doc = cm.doc;\n    d.maxLine = getLine(doc, doc.first);\n    d.maxLineLength = lineLength(d.maxLine);\n    d.maxLineChanged = true;\n    doc.iter(function(line) {\n      var len = lineLength(line);\n      if (len > d.maxLineLength) {\n        d.maxLineLength = len;\n        d.maxLine = line;\n      }\n    });\n  }\n\n  // Make sure the gutters options contains the element\n  // \"CodeMirror-linenumbers\" when the lineNumbers option is true.\n  function setGuttersForLineNumbers(options) {\n    var found = indexOf(options.gutters, \"CodeMirror-linenumbers\");\n    if (found == -1 && options.lineNumbers) {\n      options.gutters = options.gutters.concat([\"CodeMirror-linenumbers\"]);\n    } else if (found > -1 && !options.lineNumbers) {\n      options.gutters = options.gutters.slice(0);\n      options.gutters.splice(found, 1);\n    }\n  }\n\n  // SCROLLBARS\n\n  function hScrollbarTakesSpace(cm) {\n    return cm.display.scroller.clientHeight - cm.display.wrapper.clientHeight < scrollerCutOff - 3;\n  }\n\n  // Prepare DOM reads needed to update the scrollbars. Done in one\n  // shot to minimize update/measure roundtrips.\n  function measureForScrollbars(cm) {\n    var scroll = cm.display.scroller;\n    return {\n      clientHeight: scroll.clientHeight,\n      barHeight: cm.display.scrollbarV.clientHeight,\n      scrollWidth: scroll.scrollWidth, clientWidth: scroll.clientWidth,\n      hScrollbarTakesSpace: hScrollbarTakesSpace(cm),\n      barWidth: cm.display.scrollbarH.clientWidth,\n      docHeight: Math.round(cm.doc.height + paddingVert(cm.display))\n    };\n  }\n\n  // Re-synchronize the fake scrollbars with the actual size of the\n  // content.\n  function updateScrollbars(cm, measure) {\n    if (!measure) measure = measureForScrollbars(cm);\n    var d = cm.display, sWidth = scrollbarWidth(d.measure);\n    var scrollHeight = measure.docHeight + scrollerCutOff;\n    var needsH = measure.scrollWidth > measure.clientWidth;\n    if (needsH && measure.scrollWidth <= measure.clientWidth + 1 &&\n        sWidth > 0 && !measure.hScrollbarTakesSpace)\n      needsH = false; // (Issue #2562)\n    var needsV = scrollHeight > measure.clientHeight;\n\n    if (needsV) {\n      d.scrollbarV.style.display = \"block\";\n      d.scrollbarV.style.bottom = needsH ? sWidth + \"px\" : \"0\";\n      // A bug in IE8 can cause this value to be negative, so guard it.\n      d.scrollbarV.firstChild.style.height =\n        Math.max(0, scrollHeight - measure.clientHeight + (measure.barHeight || d.scrollbarV.clientHeight)) + \"px\";\n    } else {\n      d.scrollbarV.style.display = \"\";\n      d.scrollbarV.firstChild.style.height = \"0\";\n    }\n    if (needsH) {\n      d.scrollbarH.style.display = \"block\";\n      d.scrollbarH.style.right = needsV ? sWidth + \"px\" : \"0\";\n      d.scrollbarH.firstChild.style.width =\n        (measure.scrollWidth - measure.clientWidth + (measure.barWidth || d.scrollbarH.clientWidth)) + \"px\";\n    } else {\n      d.scrollbarH.style.display = \"\";\n      d.scrollbarH.firstChild.style.width = \"0\";\n    }\n    if (needsH && needsV) {\n      d.scrollbarFiller.style.display = \"block\";\n      d.scrollbarFiller.style.height = d.scrollbarFiller.style.width = sWidth + \"px\";\n    } else d.scrollbarFiller.style.display = \"\";\n    if (needsH && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {\n      d.gutterFiller.style.display = \"block\";\n      d.gutterFiller.style.height = sWidth + \"px\";\n      d.gutterFiller.style.width = d.gutters.offsetWidth + \"px\";\n    } else d.gutterFiller.style.display = \"\";\n\n    if (!cm.state.checkedOverlayScrollbar && measure.clientHeight > 0) {\n      if (sWidth === 0) {\n        var w = mac && !mac_geMountainLion ? \"12px\" : \"18px\";\n        d.scrollbarV.style.minWidth = d.scrollbarH.style.minHeight = w;\n        var barMouseDown = function(e) {\n          if (e_target(e) != d.scrollbarV && e_target(e) != d.scrollbarH)\n            operation(cm, onMouseDown)(e);\n        };\n        on(d.scrollbarV, \"mousedown\", barMouseDown);\n        on(d.scrollbarH, \"mousedown\", barMouseDown);\n      }\n      cm.state.checkedOverlayScrollbar = true;\n    }\n  }\n\n  // Compute the lines that are visible in a given viewport (defaults\n  // the the current scroll position). viewport may contain top,\n  // height, and ensure (see op.scrollToPos) properties.\n  function visibleLines(display, doc, viewport) {\n    var top = viewport && viewport.top != null ? Math.max(0, viewport.top) : display.scroller.scrollTop;\n    top = Math.floor(top - paddingTop(display));\n    var bottom = viewport && viewport.bottom != null ? viewport.bottom : top + display.wrapper.clientHeight;\n\n    var from = lineAtHeight(doc, top), to = lineAtHeight(doc, bottom);\n    // Ensure is a {from: {line, ch}, to: {line, ch}} object, and\n    // forces those lines into the viewport (if possible).\n    if (viewport && viewport.ensure) {\n      var ensureFrom = viewport.ensure.from.line, ensureTo = viewport.ensure.to.line;\n      if (ensureFrom < from)\n        return {from: ensureFrom,\n                to: lineAtHeight(doc, heightAtLine(getLine(doc, ensureFrom)) + display.wrapper.clientHeight)};\n      if (Math.min(ensureTo, doc.lastLine()) >= to)\n        return {from: lineAtHeight(doc, heightAtLine(getLine(doc, ensureTo)) - display.wrapper.clientHeight),\n                to: ensureTo};\n    }\n    return {from: from, to: Math.max(to, from + 1)};\n  }\n\n  // LINE NUMBERS\n\n  // Re-align line numbers and gutter marks to compensate for\n  // horizontal scrolling.\n  function alignHorizontally(cm) {\n    var display = cm.display, view = display.view;\n    if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) return;\n    var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;\n    var gutterW = display.gutters.offsetWidth, left = comp + \"px\";\n    for (var i = 0; i < view.length; i++) if (!view[i].hidden) {\n      if (cm.options.fixedGutter && view[i].gutter)\n        view[i].gutter.style.left = left;\n      var align = view[i].alignable;\n      if (align) for (var j = 0; j < align.length; j++)\n        align[j].style.left = left;\n    }\n    if (cm.options.fixedGutter)\n      display.gutters.style.left = (comp + gutterW) + \"px\";\n  }\n\n  // Used to ensure that the line number gutter is still the right\n  // size for the current document size. Returns true when an update\n  // is needed.\n  function maybeUpdateLineNumberWidth(cm) {\n    if (!cm.options.lineNumbers) return false;\n    var doc = cm.doc, last = lineNumberFor(cm.options, doc.first + doc.size - 1), display = cm.display;\n    if (last.length != display.lineNumChars) {\n      var test = display.measure.appendChild(elt(\"div\", [elt(\"div\", last)],\n                                                 \"CodeMirror-linenumber CodeMirror-gutter-elt\"));\n      var innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW;\n      display.lineGutter.style.width = \"\";\n      display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding);\n      display.lineNumWidth = display.lineNumInnerWidth + padding;\n      display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;\n      display.lineGutter.style.width = display.lineNumWidth + \"px\";\n      updateGutterSpace(cm);\n      return true;\n    }\n    return false;\n  }\n\n  function lineNumberFor(options, i) {\n    return String(options.lineNumberFormatter(i + options.firstLineNumber));\n  }\n\n  // Computes display.scroller.scrollLeft + display.gutters.offsetWidth,\n  // but using getBoundingClientRect to get a sub-pixel-accurate\n  // result.\n  function compensateForHScroll(display) {\n    return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left;\n  }\n\n  // DISPLAY DRAWING\n\n  function DisplayUpdate(cm, viewport, force) {\n    var display = cm.display;\n\n    this.viewport = viewport;\n    // Store some values that we'll need later (but don't want to force a relayout for)\n    this.visible = visibleLines(display, cm.doc, viewport);\n    this.editorIsHidden = !display.wrapper.offsetWidth;\n    this.wrapperHeight = display.wrapper.clientHeight;\n    this.oldViewFrom = display.viewFrom; this.oldViewTo = display.viewTo;\n    this.oldScrollerWidth = display.scroller.clientWidth;\n    this.force = force;\n    this.dims = getDimensions(cm);\n  }\n\n  // Does the actual updating of the line display. Bails out\n  // (returning false) when there is nothing to be done and forced is\n  // false.\n  function updateDisplayIfNeeded(cm, update) {\n    var display = cm.display, doc = cm.doc;\n    if (update.editorIsHidden) {\n      resetView(cm);\n      return false;\n    }\n\n    // Bail out if the visible area is already rendered and nothing changed.\n    if (!update.force &&\n        update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo &&\n        (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo) &&\n        countDirtyView(cm) == 0)\n      return false;\n\n    if (maybeUpdateLineNumberWidth(cm)) {\n      resetView(cm);\n      update.dims = getDimensions(cm);\n    }\n\n    // Compute a suitable new viewport (from & to)\n    var end = doc.first + doc.size;\n    var from = Math.max(update.visible.from - cm.options.viewportMargin, doc.first);\n    var to = Math.min(end, update.visible.to + cm.options.viewportMargin);\n    if (display.viewFrom < from && from - display.viewFrom < 20) from = Math.max(doc.first, display.viewFrom);\n    if (display.viewTo > to && display.viewTo - to < 20) to = Math.min(end, display.viewTo);\n    if (sawCollapsedSpans) {\n      from = visualLineNo(cm.doc, from);\n      to = visualLineEndNo(cm.doc, to);\n    }\n\n    var different = from != display.viewFrom || to != display.viewTo ||\n      display.lastSizeC != update.wrapperHeight;\n    adjustView(cm, from, to);\n\n    display.viewOffset = heightAtLine(getLine(cm.doc, display.viewFrom));\n    // Position the mover div to align with the current scroll position\n    cm.display.mover.style.top = display.viewOffset + \"px\";\n\n    var toUpdate = countDirtyView(cm);\n    if (!different && toUpdate == 0 && !update.force &&\n        (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo))\n      return false;\n\n    // For big changes, we hide the enclosing element during the\n    // update, since that speeds up the operations on most browsers.\n    var focused = activeElt();\n    if (toUpdate > 4) display.lineDiv.style.display = \"none\";\n    patchDisplay(cm, display.updateLineNumbers, update.dims);\n    if (toUpdate > 4) display.lineDiv.style.display = \"\";\n    // There might have been a widget with a focused element that got\n    // hidden or updated, if so re-focus it.\n    if (focused && activeElt() != focused && focused.offsetHeight) focused.focus();\n\n    // Prevent selection and cursors from interfering with the scroll\n    // width.\n    removeChildren(display.cursorDiv);\n    removeChildren(display.selectionDiv);\n\n    if (different) {\n      display.lastSizeC = update.wrapperHeight;\n      startWorker(cm, 400);\n    }\n\n    display.updateLineNumbers = null;\n\n    return true;\n  }\n\n  function postUpdateDisplay(cm, update) {\n    var force = update.force, viewport = update.viewport;\n    for (var first = true;; first = false) {\n      if (first && cm.options.lineWrapping && update.oldScrollerWidth != cm.display.scroller.clientWidth) {\n        force = true;\n      } else {\n        force = false;\n        // Clip forced viewport to actual scrollable area.\n        if (viewport && viewport.top != null)\n          viewport = {top: Math.min(cm.doc.height + paddingVert(cm.display) - scrollerCutOff -\n                                    cm.display.scroller.clientHeight, viewport.top)};\n        // Updated line heights might result in the drawn area not\n        // actually covering the viewport. Keep looping until it does.\n        update.visible = visibleLines(cm.display, cm.doc, viewport);\n        if (update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo)\n          break;\n      }\n      if (!updateDisplayIfNeeded(cm, update)) break;\n      updateHeightsInViewport(cm);\n      var barMeasure = measureForScrollbars(cm);\n      updateSelection(cm);\n      setDocumentHeight(cm, barMeasure);\n      updateScrollbars(cm, barMeasure);\n    }\n\n    signalLater(cm, \"update\", cm);\n    if (cm.display.viewFrom != update.oldViewFrom || cm.display.viewTo != update.oldViewTo)\n      signalLater(cm, \"viewportChange\", cm, cm.display.viewFrom, cm.display.viewTo);\n  }\n\n  function updateDisplaySimple(cm, viewport) {\n    var update = new DisplayUpdate(cm, viewport);\n    if (updateDisplayIfNeeded(cm, update)) {\n      updateHeightsInViewport(cm);\n      postUpdateDisplay(cm, update);\n      var barMeasure = measureForScrollbars(cm);\n      updateSelection(cm);\n      setDocumentHeight(cm, barMeasure);\n      updateScrollbars(cm, barMeasure);\n    }\n  }\n\n  function setDocumentHeight(cm, measure) {\n    cm.display.sizer.style.minHeight = cm.display.heightForcer.style.top = measure.docHeight + \"px\";\n    cm.display.gutters.style.height = Math.max(measure.docHeight, measure.clientHeight - scrollerCutOff) + \"px\";\n  }\n\n  function checkForWebkitWidthBug(cm, measure) {\n    // Work around Webkit bug where it sometimes reserves space for a\n    // non-existing phantom scrollbar in the scroller (Issue #2420)\n    if (cm.display.sizer.offsetWidth + cm.display.gutters.offsetWidth < cm.display.scroller.clientWidth - 1) {\n      cm.display.sizer.style.minHeight = cm.display.heightForcer.style.top = \"0px\";\n      cm.display.gutters.style.height = measure.docHeight + \"px\";\n    }\n  }\n\n  // Read the actual heights of the rendered lines, and update their\n  // stored heights to match.\n  function updateHeightsInViewport(cm) {\n    var display = cm.display;\n    var prevBottom = display.lineDiv.offsetTop;\n    for (var i = 0; i < display.view.length; i++) {\n      var cur = display.view[i], height;\n      if (cur.hidden) continue;\n      if (ie && ie_version < 8) {\n        var bot = cur.node.offsetTop + cur.node.offsetHeight;\n        height = bot - prevBottom;\n        prevBottom = bot;\n      } else {\n        var box = cur.node.getBoundingClientRect();\n        height = box.bottom - box.top;\n      }\n      var diff = cur.line.height - height;\n      if (height < 2) height = textHeight(display);\n      if (diff > .001 || diff < -.001) {\n        updateLineHeight(cur.line, height);\n        updateWidgetHeight(cur.line);\n        if (cur.rest) for (var j = 0; j < cur.rest.length; j++)\n          updateWidgetHeight(cur.rest[j]);\n      }\n    }\n  }\n\n  // Read and store the height of line widgets associated with the\n  // given line.\n  function updateWidgetHeight(line) {\n    if (line.widgets) for (var i = 0; i < line.widgets.length; ++i)\n      line.widgets[i].height = line.widgets[i].node.offsetHeight;\n  }\n\n  // Do a bulk-read of the DOM positions and sizes needed to draw the\n  // view, so that we don't interleave reading and writing to the DOM.\n  function getDimensions(cm) {\n    var d = cm.display, left = {}, width = {};\n    var gutterLeft = d.gutters.clientLeft;\n    for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {\n      left[cm.options.gutters[i]] = n.offsetLeft + n.clientLeft + gutterLeft;\n      width[cm.options.gutters[i]] = n.clientWidth;\n    }\n    return {fixedPos: compensateForHScroll(d),\n            gutterTotalWidth: d.gutters.offsetWidth,\n            gutterLeft: left,\n            gutterWidth: width,\n            wrapperWidth: d.wrapper.clientWidth};\n  }\n\n  // Sync the actual display DOM structure with display.view, removing\n  // nodes for lines that are no longer in view, and creating the ones\n  // that are not there yet, and updating the ones that are out of\n  // date.\n  function patchDisplay(cm, updateNumbersFrom, dims) {\n    var display = cm.display, lineNumbers = cm.options.lineNumbers;\n    var container = display.lineDiv, cur = container.firstChild;\n\n    function rm(node) {\n      var next = node.nextSibling;\n      // Works around a throw-scroll bug in OS X Webkit\n      if (webkit && mac && cm.display.currentWheelTarget == node)\n        node.style.display = \"none\";\n      else\n        node.parentNode.removeChild(node);\n      return next;\n    }\n\n    var view = display.view, lineN = display.viewFrom;\n    // Loop over the elements in the view, syncing cur (the DOM nodes\n    // in display.lineDiv) with the view as we go.\n    for (var i = 0; i < view.length; i++) {\n      var lineView = view[i];\n      if (lineView.hidden) {\n      } else if (!lineView.node) { // Not drawn yet\n        var node = buildLineElement(cm, lineView, lineN, dims);\n        container.insertBefore(node, cur);\n      } else { // Already drawn\n        while (cur != lineView.node) cur = rm(cur);\n        var updateNumber = lineNumbers && updateNumbersFrom != null &&\n          updateNumbersFrom <= lineN && lineView.lineNumber;\n        if (lineView.changes) {\n          if (indexOf(lineView.changes, \"gutter\") > -1) updateNumber = false;\n          updateLineForChanges(cm, lineView, lineN, dims);\n        }\n        if (updateNumber) {\n          removeChildren(lineView.lineNumber);\n          lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)));\n        }\n        cur = lineView.node.nextSibling;\n      }\n      lineN += lineView.size;\n    }\n    while (cur) cur = rm(cur);\n  }\n\n  // When an aspect of a line changes, a string is added to\n  // lineView.changes. This updates the relevant part of the line's\n  // DOM structure.\n  function updateLineForChanges(cm, lineView, lineN, dims) {\n    for (var j = 0; j < lineView.changes.length; j++) {\n      var type = lineView.changes[j];\n      if (type == \"text\") updateLineText(cm, lineView);\n      else if (type == \"gutter\") updateLineGutter(cm, lineView, lineN, dims);\n      else if (type == \"class\") updateLineClasses(lineView);\n      else if (type == \"widget\") updateLineWidgets(lineView, dims);\n    }\n    lineView.changes = null;\n  }\n\n  // Lines with gutter elements, widgets or a background class need to\n  // be wrapped, and have the extra elements added to the wrapper div\n  function ensureLineWrapped(lineView) {\n    if (lineView.node == lineView.text) {\n      lineView.node = elt(\"div\", null, null, \"position: relative\");\n      if (lineView.text.parentNode)\n        lineView.text.parentNode.replaceChild(lineView.node, lineView.text);\n      lineView.node.appendChild(lineView.text);\n      if (ie && ie_version < 8) lineView.node.style.zIndex = 2;\n    }\n    return lineView.node;\n  }\n\n  function updateLineBackground(lineView) {\n    var cls = lineView.bgClass ? lineView.bgClass + \" \" + (lineView.line.bgClass || \"\") : lineView.line.bgClass;\n    if (cls) cls += \" CodeMirror-linebackground\";\n    if (lineView.background) {\n      if (cls) lineView.background.className = cls;\n      else { lineView.background.parentNode.removeChild(lineView.background); lineView.background = null; }\n    } else if (cls) {\n      var wrap = ensureLineWrapped(lineView);\n      lineView.background = wrap.insertBefore(elt(\"div\", null, cls), wrap.firstChild);\n    }\n  }\n\n  // Wrapper around buildLineContent which will reuse the structure\n  // in display.externalMeasured when possible.\n  function getLineContent(cm, lineView) {\n    var ext = cm.display.externalMeasured;\n    if (ext && ext.line == lineView.line) {\n      cm.display.externalMeasured = null;\n      lineView.measure = ext.measure;\n      return ext.built;\n    }\n    return buildLineContent(cm, lineView);\n  }\n\n  // Redraw the line's text. Interacts with the background and text\n  // classes because the mode may output tokens that influence these\n  // classes.\n  function updateLineText(cm, lineView) {\n    var cls = lineView.text.className;\n    var built = getLineContent(cm, lineView);\n    if (lineView.text == lineView.node) lineView.node = built.pre;\n    lineView.text.parentNode.replaceChild(built.pre, lineView.text);\n    lineView.text = built.pre;\n    if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {\n      lineView.bgClass = built.bgClass;\n      lineView.textClass = built.textClass;\n      updateLineClasses(lineView);\n    } else if (cls) {\n      lineView.text.className = cls;\n    }\n  }\n\n  function updateLineClasses(lineView) {\n    updateLineBackground(lineView);\n    if (lineView.line.wrapClass)\n      ensureLineWrapped(lineView).className = lineView.line.wrapClass;\n    else if (lineView.node != lineView.text)\n      lineView.node.className = \"\";\n    var textClass = lineView.textClass ? lineView.textClass + \" \" + (lineView.line.textClass || \"\") : lineView.line.textClass;\n    lineView.text.className = textClass || \"\";\n  }\n\n  function updateLineGutter(cm, lineView, lineN, dims) {\n    if (lineView.gutter) {\n      lineView.node.removeChild(lineView.gutter);\n      lineView.gutter = null;\n    }\n    var markers = lineView.line.gutterMarkers;\n    if (cm.options.lineNumbers || markers) {\n      var wrap = ensureLineWrapped(lineView);\n      var gutterWrap = lineView.gutter =\n        wrap.insertBefore(elt(\"div\", null, \"CodeMirror-gutter-wrapper\", \"position: absolute; left: \" +\n                              (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + \"px\"),\n                          lineView.text);\n      if (cm.options.lineNumbers && (!markers || !markers[\"CodeMirror-linenumbers\"]))\n        lineView.lineNumber = gutterWrap.appendChild(\n          elt(\"div\", lineNumberFor(cm.options, lineN),\n              \"CodeMirror-linenumber CodeMirror-gutter-elt\",\n              \"left: \" + dims.gutterLeft[\"CodeMirror-linenumbers\"] + \"px; width: \"\n              + cm.display.lineNumInnerWidth + \"px\"));\n      if (markers) for (var k = 0; k < cm.options.gutters.length; ++k) {\n        var id = cm.options.gutters[k], found = markers.hasOwnProperty(id) && markers[id];\n        if (found)\n          gutterWrap.appendChild(elt(\"div\", [found], \"CodeMirror-gutter-elt\", \"left: \" +\n                                     dims.gutterLeft[id] + \"px; width: \" + dims.gutterWidth[id] + \"px\"));\n      }\n    }\n  }\n\n  function updateLineWidgets(lineView, dims) {\n    if (lineView.alignable) lineView.alignable = null;\n    for (var node = lineView.node.firstChild, next; node; node = next) {\n      var next = node.nextSibling;\n      if (node.className == \"CodeMirror-linewidget\")\n        lineView.node.removeChild(node);\n    }\n    insertLineWidgets(lineView, dims);\n  }\n\n  // Build a line's DOM representation from scratch\n  function buildLineElement(cm, lineView, lineN, dims) {\n    var built = getLineContent(cm, lineView);\n    lineView.text = lineView.node = built.pre;\n    if (built.bgClass) lineView.bgClass = built.bgClass;\n    if (built.textClass) lineView.textClass = built.textClass;\n\n    updateLineClasses(lineView);\n    updateLineGutter(cm, lineView, lineN, dims);\n    insertLineWidgets(lineView, dims);\n    return lineView.node;\n  }\n\n  // A lineView may contain multiple logical lines (when merged by\n  // collapsed spans). The widgets for all of them need to be drawn.\n  function insertLineWidgets(lineView, dims) {\n    insertLineWidgetsFor(lineView.line, lineView, dims, true);\n    if (lineView.rest) for (var i = 0; i < lineView.rest.length; i++)\n      insertLineWidgetsFor(lineView.rest[i], lineView, dims, false);\n  }\n\n  function insertLineWidgetsFor(line, lineView, dims, allowAbove) {\n    if (!line.widgets) return;\n    var wrap = ensureLineWrapped(lineView);\n    for (var i = 0, ws = line.widgets; i < ws.length; ++i) {\n      var widget = ws[i], node = elt(\"div\", [widget.node], \"CodeMirror-linewidget\");\n      if (!widget.handleMouseEvents) node.ignoreEvents = true;\n      positionLineWidget(widget, node, lineView, dims);\n      if (allowAbove && widget.above)\n        wrap.insertBefore(node, lineView.gutter || lineView.text);\n      else\n        wrap.appendChild(node);\n      signalLater(widget, \"redraw\");\n    }\n  }\n\n  function positionLineWidget(widget, node, lineView, dims) {\n    if (widget.noHScroll) {\n      (lineView.alignable || (lineView.alignable = [])).push(node);\n      var width = dims.wrapperWidth;\n      node.style.left = dims.fixedPos + \"px\";\n      if (!widget.coverGutter) {\n        width -= dims.gutterTotalWidth;\n        node.style.paddingLeft = dims.gutterTotalWidth + \"px\";\n      }\n      node.style.width = width + \"px\";\n    }\n    if (widget.coverGutter) {\n      node.style.zIndex = 5;\n      node.style.position = \"relative\";\n      if (!widget.noHScroll) node.style.marginLeft = -dims.gutterTotalWidth + \"px\";\n    }\n  }\n\n  // POSITION OBJECT\n\n  // A Pos instance represents a position within the text.\n  var Pos = CodeMirror.Pos = function(line, ch) {\n    if (!(this instanceof Pos)) return new Pos(line, ch);\n    this.line = line; this.ch = ch;\n  };\n\n  // Compare two positions, return 0 if they are the same, a negative\n  // number when a is less, and a positive number otherwise.\n  var cmp = CodeMirror.cmpPos = function(a, b) { return a.line - b.line || a.ch - b.ch; };\n\n  function copyPos(x) {return Pos(x.line, x.ch);}\n  function maxPos(a, b) { return cmp(a, b) < 0 ? b : a; }\n  function minPos(a, b) { return cmp(a, b) < 0 ? a : b; }\n\n  // SELECTION / CURSOR\n\n  // Selection objects are immutable. A new one is created every time\n  // the selection changes. A selection is one or more non-overlapping\n  // (and non-touching) ranges, sorted, and an integer that indicates\n  // which one is the primary selection (the one that's scrolled into\n  // view, that getCursor returns, etc).\n  function Selection(ranges, primIndex) {\n    this.ranges = ranges;\n    this.primIndex = primIndex;\n  }\n\n  Selection.prototype = {\n    primary: function() { return this.ranges[this.primIndex]; },\n    equals: function(other) {\n      if (other == this) return true;\n      if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) return false;\n      for (var i = 0; i < this.ranges.length; i++) {\n        var here = this.ranges[i], there = other.ranges[i];\n        if (cmp(here.anchor, there.anchor) != 0 || cmp(here.head, there.head) != 0) return false;\n      }\n      return true;\n    },\n    deepCopy: function() {\n      for (var out = [], i = 0; i < this.ranges.length; i++)\n        out[i] = new Range(copyPos(this.ranges[i].anchor), copyPos(this.ranges[i].head));\n      return new Selection(out, this.primIndex);\n    },\n    somethingSelected: function() {\n      for (var i = 0; i < this.ranges.length; i++)\n        if (!this.ranges[i].empty()) return true;\n      return false;\n    },\n    contains: function(pos, end) {\n      if (!end) end = pos;\n      for (var i = 0; i < this.ranges.length; i++) {\n        var range = this.ranges[i];\n        if (cmp(end, range.from()) >= 0 && cmp(pos, range.to()) <= 0)\n          return i;\n      }\n      return -1;\n    }\n  };\n\n  function Range(anchor, head) {\n    this.anchor = anchor; this.head = head;\n  }\n\n  Range.prototype = {\n    from: function() { return minPos(this.anchor, this.head); },\n    to: function() { return maxPos(this.anchor, this.head); },\n    empty: function() {\n      return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch;\n    }\n  };\n\n  // Take an unsorted, potentially overlapping set of ranges, and\n  // build a selection out of it. 'Consumes' ranges array (modifying\n  // it).\n  function normalizeSelection(ranges, primIndex) {\n    var prim = ranges[primIndex];\n    ranges.sort(function(a, b) { return cmp(a.from(), b.from()); });\n    primIndex = indexOf(ranges, prim);\n    for (var i = 1; i < ranges.length; i++) {\n      var cur = ranges[i], prev = ranges[i - 1];\n      if (cmp(prev.to(), cur.from()) >= 0) {\n        var from = minPos(prev.from(), cur.from()), to = maxPos(prev.to(), cur.to());\n        var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;\n        if (i <= primIndex) --primIndex;\n        ranges.splice(--i, 2, new Range(inv ? to : from, inv ? from : to));\n      }\n    }\n    return new Selection(ranges, primIndex);\n  }\n\n  function simpleSelection(anchor, head) {\n    return new Selection([new Range(anchor, head || anchor)], 0);\n  }\n\n  // Most of the external API clips given positions to make sure they\n  // actually exist within the document.\n  function clipLine(doc, n) {return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1));}\n  function clipPos(doc, pos) {\n    if (pos.line < doc.first) return Pos(doc.first, 0);\n    var last = doc.first + doc.size - 1;\n    if (pos.line > last) return Pos(last, getLine(doc, last).text.length);\n    return clipToLen(pos, getLine(doc, pos.line).text.length);\n  }\n  function clipToLen(pos, linelen) {\n    var ch = pos.ch;\n    if (ch == null || ch > linelen) return Pos(pos.line, linelen);\n    else if (ch < 0) return Pos(pos.line, 0);\n    else return pos;\n  }\n  function isLine(doc, l) {return l >= doc.first && l < doc.first + doc.size;}\n  function clipPosArray(doc, array) {\n    for (var out = [], i = 0; i < array.length; i++) out[i] = clipPos(doc, array[i]);\n    return out;\n  }\n\n  // SELECTION UPDATES\n\n  // The 'scroll' parameter given to many of these indicated whether\n  // the new cursor position should be scrolled into view after\n  // modifying the selection.\n\n  // If shift is held or the extend flag is set, extends a range to\n  // include a given position (and optionally a second position).\n  // Otherwise, simply returns the range between the given positions.\n  // Used for cursor motion and such.\n  function extendRange(doc, range, head, other) {\n    if (doc.cm && doc.cm.display.shift || doc.extend) {\n      var anchor = range.anchor;\n      if (other) {\n        var posBefore = cmp(head, anchor) < 0;\n        if (posBefore != (cmp(other, anchor) < 0)) {\n          anchor = head;\n          head = other;\n        } else if (posBefore != (cmp(head, other) < 0)) {\n          head = other;\n        }\n      }\n      return new Range(anchor, head);\n    } else {\n      return new Range(other || head, head);\n    }\n  }\n\n  // Extend the primary selection range, discard the rest.\n  function extendSelection(doc, head, other, options) {\n    setSelection(doc, new Selection([extendRange(doc, doc.sel.primary(), head, other)], 0), options);\n  }\n\n  // Extend all selections (pos is an array of selections with length\n  // equal the number of selections)\n  function extendSelections(doc, heads, options) {\n    for (var out = [], i = 0; i < doc.sel.ranges.length; i++)\n      out[i] = extendRange(doc, doc.sel.ranges[i], heads[i], null);\n    var newSel = normalizeSelection(out, doc.sel.primIndex);\n    setSelection(doc, newSel, options);\n  }\n\n  // Updates a single range in the selection.\n  function replaceOneSelection(doc, i, range, options) {\n    var ranges = doc.sel.ranges.slice(0);\n    ranges[i] = range;\n    setSelection(doc, normalizeSelection(ranges, doc.sel.primIndex), options);\n  }\n\n  // Reset the selection to a single range.\n  function setSimpleSelection(doc, anchor, head, options) {\n    setSelection(doc, simpleSelection(anchor, head), options);\n  }\n\n  // Give beforeSelectionChange handlers a change to influence a\n  // selection update.\n  function filterSelectionChange(doc, sel) {\n    var obj = {\n      ranges: sel.ranges,\n      update: function(ranges) {\n        this.ranges = [];\n        for (var i = 0; i < ranges.length; i++)\n          this.ranges[i] = new Range(clipPos(doc, ranges[i].anchor),\n                                     clipPos(doc, ranges[i].head));\n      }\n    };\n    signal(doc, \"beforeSelectionChange\", doc, obj);\n    if (doc.cm) signal(doc.cm, \"beforeSelectionChange\", doc.cm, obj);\n    if (obj.ranges != sel.ranges) return normalizeSelection(obj.ranges, obj.ranges.length - 1);\n    else return sel;\n  }\n\n  function setSelectionReplaceHistory(doc, sel, options) {\n    var done = doc.history.done, last = lst(done);\n    if (last && last.ranges) {\n      done[done.length - 1] = sel;\n      setSelectionNoUndo(doc, sel, options);\n    } else {\n      setSelection(doc, sel, options);\n    }\n  }\n\n  // Set a new selection.\n  function setSelection(doc, sel, options) {\n    setSelectionNoUndo(doc, sel, options);\n    addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options);\n  }\n\n  function setSelectionNoUndo(doc, sel, options) {\n    if (hasHandler(doc, \"beforeSelectionChange\") || doc.cm && hasHandler(doc.cm, \"beforeSelectionChange\"))\n      sel = filterSelectionChange(doc, sel);\n\n    var bias = options && options.bias ||\n      (cmp(sel.primary().head, doc.sel.primary().head) < 0 ? -1 : 1);\n    setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, true));\n\n    if (!(options && options.scroll === false) && doc.cm)\n      ensureCursorVisible(doc.cm);\n  }\n\n  function setSelectionInner(doc, sel) {\n    if (sel.equals(doc.sel)) return;\n\n    doc.sel = sel;\n\n    if (doc.cm) {\n      doc.cm.curOp.updateInput = doc.cm.curOp.selectionChanged = true;\n      signalCursorActivity(doc.cm);\n    }\n    signalLater(doc, \"cursorActivity\", doc);\n  }\n\n  // Verify that the selection does not partially select any atomic\n  // marked ranges.\n  function reCheckSelection(doc) {\n    setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, false), sel_dontScroll);\n  }\n\n  // Return a selection that does not partially select any atomic\n  // ranges.\n  function skipAtomicInSelection(doc, sel, bias, mayClear) {\n    var out;\n    for (var i = 0; i < sel.ranges.length; i++) {\n      var range = sel.ranges[i];\n      var newAnchor = skipAtomic(doc, range.anchor, bias, mayClear);\n      var newHead = skipAtomic(doc, range.head, bias, mayClear);\n      if (out || newAnchor != range.anchor || newHead != range.head) {\n        if (!out) out = sel.ranges.slice(0, i);\n        out[i] = new Range(newAnchor, newHead);\n      }\n    }\n    return out ? normalizeSelection(out, sel.primIndex) : sel;\n  }\n\n  // Ensure a given position is not inside an atomic range.\n  function skipAtomic(doc, pos, bias, mayClear) {\n    var flipped = false, curPos = pos;\n    var dir = bias || 1;\n    doc.cantEdit = false;\n    search: for (;;) {\n      var line = getLine(doc, curPos.line);\n      if (line.markedSpans) {\n        for (var i = 0; i < line.markedSpans.length; ++i) {\n          var sp = line.markedSpans[i], m = sp.marker;\n          if ((sp.from == null || (m.inclusiveLeft ? sp.from <= curPos.ch : sp.from < curPos.ch)) &&\n              (sp.to == null || (m.inclusiveRight ? sp.to >= curPos.ch : sp.to > curPos.ch))) {\n            if (mayClear) {\n              signal(m, \"beforeCursorEnter\");\n              if (m.explicitlyCleared) {\n                if (!line.markedSpans) break;\n                else {--i; continue;}\n              }\n            }\n            if (!m.atomic) continue;\n            var newPos = m.find(dir < 0 ? -1 : 1);\n            if (cmp(newPos, curPos) == 0) {\n              newPos.ch += dir;\n              if (newPos.ch < 0) {\n                if (newPos.line > doc.first) newPos = clipPos(doc, Pos(newPos.line - 1));\n                else newPos = null;\n              } else if (newPos.ch > line.text.length) {\n                if (newPos.line < doc.first + doc.size - 1) newPos = Pos(newPos.line + 1, 0);\n                else newPos = null;\n              }\n              if (!newPos) {\n                if (flipped) {\n                  // Driven in a corner -- no valid cursor position found at all\n                  // -- try again *with* clearing, if we didn't already\n                  if (!mayClear) return skipAtomic(doc, pos, bias, true);\n                  // Otherwise, turn off editing until further notice, and return the start of the doc\n                  doc.cantEdit = true;\n                  return Pos(doc.first, 0);\n                }\n                flipped = true; newPos = pos; dir = -dir;\n              }\n            }\n            curPos = newPos;\n            continue search;\n          }\n        }\n      }\n      return curPos;\n    }\n  }\n\n  // SELECTION DRAWING\n\n  // Redraw the selection and/or cursor\n  function drawSelection(cm) {\n    var display = cm.display, doc = cm.doc, result = {};\n    var curFragment = result.cursors = document.createDocumentFragment();\n    var selFragment = result.selection = document.createDocumentFragment();\n\n    for (var i = 0; i < doc.sel.ranges.length; i++) {\n      var range = doc.sel.ranges[i];\n      var collapsed = range.empty();\n      if (collapsed || cm.options.showCursorWhenSelecting)\n        drawSelectionCursor(cm, range, curFragment);\n      if (!collapsed)\n        drawSelectionRange(cm, range, selFragment);\n    }\n\n    // Move the hidden textarea near the cursor to prevent scrolling artifacts\n    if (cm.options.moveInputWithCursor) {\n      var headPos = cursorCoords(cm, doc.sel.primary().head, \"div\");\n      var wrapOff = display.wrapper.getBoundingClientRect(), lineOff = display.lineDiv.getBoundingClientRect();\n      result.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10,\n                                          headPos.top + lineOff.top - wrapOff.top));\n      result.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10,\n                                           headPos.left + lineOff.left - wrapOff.left));\n    }\n\n    return result;\n  }\n\n  function showSelection(cm, drawn) {\n    removeChildrenAndAdd(cm.display.cursorDiv, drawn.cursors);\n    removeChildrenAndAdd(cm.display.selectionDiv, drawn.selection);\n    if (drawn.teTop != null) {\n      cm.display.inputDiv.style.top = drawn.teTop + \"px\";\n      cm.display.inputDiv.style.left = drawn.teLeft + \"px\";\n    }\n  }\n\n  function updateSelection(cm) {\n    showSelection(cm, drawSelection(cm));\n  }\n\n  // Draws a cursor for the given range\n  function drawSelectionCursor(cm, range, output) {\n    var pos = cursorCoords(cm, range.head, \"div\", null, null, !cm.options.singleCursorHeightPerLine);\n\n    var cursor = output.appendChild(elt(\"div\", \"\\u00a0\", \"CodeMirror-cursor\"));\n    cursor.style.left = pos.left + \"px\";\n    cursor.style.top = pos.top + \"px\";\n    cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + \"px\";\n\n    if (pos.other) {\n      // Secondary cursor, shown when on a 'jump' in bi-directional text\n      var otherCursor = output.appendChild(elt(\"div\", \"\\u00a0\", \"CodeMirror-cursor CodeMirror-secondarycursor\"));\n      otherCursor.style.display = \"\";\n      otherCursor.style.left = pos.other.left + \"px\";\n      otherCursor.style.top = pos.other.top + \"px\";\n      otherCursor.style.height = (pos.other.bottom - pos.other.top) * .85 + \"px\";\n    }\n  }\n\n  // Draws the given range as a highlighted selection\n  function drawSelectionRange(cm, range, output) {\n    var display = cm.display, doc = cm.doc;\n    var fragment = document.createDocumentFragment();\n    var padding = paddingH(cm.display), leftSide = padding.left, rightSide = display.lineSpace.offsetWidth - padding.right;\n\n    function add(left, top, width, bottom) {\n      if (top < 0) top = 0;\n      top = Math.round(top);\n      bottom = Math.round(bottom);\n      fragment.appendChild(elt(\"div\", null, \"CodeMirror-selected\", \"position: absolute; left: \" + left +\n                               \"px; top: \" + top + \"px; width: \" + (width == null ? rightSide - left : width) +\n                               \"px; height: \" + (bottom - top) + \"px\"));\n    }\n\n    function drawForLine(line, fromArg, toArg) {\n      var lineObj = getLine(doc, line);\n      var lineLen = lineObj.text.length;\n      var start, end;\n      function coords(ch, bias) {\n        return charCoords(cm, Pos(line, ch), \"div\", lineObj, bias);\n      }\n\n      iterateBidiSections(getOrder(lineObj), fromArg || 0, toArg == null ? lineLen : toArg, function(from, to, dir) {\n        var leftPos = coords(from, \"left\"), rightPos, left, right;\n        if (from == to) {\n          rightPos = leftPos;\n          left = right = leftPos.left;\n        } else {\n          rightPos = coords(to - 1, \"right\");\n          if (dir == \"rtl\") { var tmp = leftPos; leftPos = rightPos; rightPos = tmp; }\n          left = leftPos.left;\n          right = rightPos.right;\n        }\n        if (fromArg == null && from == 0) left = leftSide;\n        if (rightPos.top - leftPos.top > 3) { // Different lines, draw top part\n          add(left, leftPos.top, null, leftPos.bottom);\n          left = leftSide;\n          if (leftPos.bottom < rightPos.top) add(left, leftPos.bottom, null, rightPos.top);\n        }\n        if (toArg == null && to == lineLen) right = rightSide;\n        if (!start || leftPos.top < start.top || leftPos.top == start.top && leftPos.left < start.left)\n          start = leftPos;\n        if (!end || rightPos.bottom > end.bottom || rightPos.bottom == end.bottom && rightPos.right > end.right)\n          end = rightPos;\n        if (left < leftSide + 1) left = leftSide;\n        add(left, rightPos.top, right - left, rightPos.bottom);\n      });\n      return {start: start, end: end};\n    }\n\n    var sFrom = range.from(), sTo = range.to();\n    if (sFrom.line == sTo.line) {\n      drawForLine(sFrom.line, sFrom.ch, sTo.ch);\n    } else {\n      var fromLine = getLine(doc, sFrom.line), toLine = getLine(doc, sTo.line);\n      var singleVLine = visualLine(fromLine) == visualLine(toLine);\n      var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end;\n      var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;\n      if (singleVLine) {\n        if (leftEnd.top < rightStart.top - 2) {\n          add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);\n          add(leftSide, rightStart.top, rightStart.left, rightStart.bottom);\n        } else {\n          add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);\n        }\n      }\n      if (leftEnd.bottom < rightStart.top)\n        add(leftSide, leftEnd.bottom, null, rightStart.top);\n    }\n\n    output.appendChild(fragment);\n  }\n\n  // Cursor-blinking\n  function restartBlink(cm) {\n    if (!cm.state.focused) return;\n    var display = cm.display;\n    clearInterval(display.blinker);\n    var on = true;\n    display.cursorDiv.style.visibility = \"\";\n    if (cm.options.cursorBlinkRate > 0)\n      display.blinker = setInterval(function() {\n        display.cursorDiv.style.visibility = (on = !on) ? \"\" : \"hidden\";\n      }, cm.options.cursorBlinkRate);\n    else if (cm.options.cursorBlinkRate < 0)\n      display.cursorDiv.style.visibility = \"hidden\";\n  }\n\n  // HIGHLIGHT WORKER\n\n  function startWorker(cm, time) {\n    if (cm.doc.mode.startState && cm.doc.frontier < cm.display.viewTo)\n      cm.state.highlight.set(time, bind(highlightWorker, cm));\n  }\n\n  function highlightWorker(cm) {\n    var doc = cm.doc;\n    if (doc.frontier < doc.first) doc.frontier = doc.first;\n    if (doc.frontier >= cm.display.viewTo) return;\n    var end = +new Date + cm.options.workTime;\n    var state = copyState(doc.mode, getStateBefore(cm, doc.frontier));\n    var changedLines = [];\n\n    doc.iter(doc.frontier, Math.min(doc.first + doc.size, cm.display.viewTo + 500), function(line) {\n      if (doc.frontier >= cm.display.viewFrom) { // Visible\n        var oldStyles = line.styles;\n        var highlighted = highlightLine(cm, line, state, true);\n        line.styles = highlighted.styles;\n        var oldCls = line.styleClasses, newCls = highlighted.classes;\n        if (newCls) line.styleClasses = newCls;\n        else if (oldCls) line.styleClasses = null;\n        var ischange = !oldStyles || oldStyles.length != line.styles.length ||\n          oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass);\n        for (var i = 0; !ischange && i < oldStyles.length; ++i) ischange = oldStyles[i] != line.styles[i];\n        if (ischange) changedLines.push(doc.frontier);\n        line.stateAfter = copyState(doc.mode, state);\n      } else {\n        processLine(cm, line.text, state);\n        line.stateAfter = doc.frontier % 5 == 0 ? copyState(doc.mode, state) : null;\n      }\n      ++doc.frontier;\n      if (+new Date > end) {\n        startWorker(cm, cm.options.workDelay);\n        return true;\n      }\n    });\n    if (changedLines.length) runInOp(cm, function() {\n      for (var i = 0; i < changedLines.length; i++)\n        regLineChange(cm, changedLines[i], \"text\");\n    });\n  }\n\n  // Finds the line to start with when starting a parse. Tries to\n  // find a line with a stateAfter, so that it can start with a\n  // valid state. If that fails, it returns the line with the\n  // smallest indentation, which tends to need the least context to\n  // parse correctly.\n  function findStartLine(cm, n, precise) {\n    var minindent, minline, doc = cm.doc;\n    var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1000 : 100);\n    for (var search = n; search > lim; --search) {\n      if (search <= doc.first) return doc.first;\n      var line = getLine(doc, search - 1);\n      if (line.stateAfter && (!precise || search <= doc.frontier)) return search;\n      var indented = countColumn(line.text, null, cm.options.tabSize);\n      if (minline == null || minindent > indented) {\n        minline = search - 1;\n        minindent = indented;\n      }\n    }\n    return minline;\n  }\n\n  function getStateBefore(cm, n, precise) {\n    var doc = cm.doc, display = cm.display;\n    if (!doc.mode.startState) return true;\n    var pos = findStartLine(cm, n, precise), state = pos > doc.first && getLine(doc, pos-1).stateAfter;\n    if (!state) state = startState(doc.mode);\n    else state = copyState(doc.mode, state);\n    doc.iter(pos, n, function(line) {\n      processLine(cm, line.text, state);\n      var save = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo;\n      line.stateAfter = save ? copyState(doc.mode, state) : null;\n      ++pos;\n    });\n    if (precise) doc.frontier = pos;\n    return state;\n  }\n\n  // POSITION MEASUREMENT\n\n  function paddingTop(display) {return display.lineSpace.offsetTop;}\n  function paddingVert(display) {return display.mover.offsetHeight - display.lineSpace.offsetHeight;}\n  function paddingH(display) {\n    if (display.cachedPaddingH) return display.cachedPaddingH;\n    var e = removeChildrenAndAdd(display.measure, elt(\"pre\", \"x\"));\n    var style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle;\n    var data = {left: parseInt(style.paddingLeft), right: parseInt(style.paddingRight)};\n    if (!isNaN(data.left) && !isNaN(data.right)) display.cachedPaddingH = data;\n    return data;\n  }\n\n  // Ensure the lineView.wrapping.heights array is populated. This is\n  // an array of bottom offsets for the lines that make up a drawn\n  // line. When lineWrapping is on, there might be more than one\n  // height.\n  function ensureLineHeights(cm, lineView, rect) {\n    var wrapping = cm.options.lineWrapping;\n    var curWidth = wrapping && cm.display.scroller.clientWidth;\n    if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {\n      var heights = lineView.measure.heights = [];\n      if (wrapping) {\n        lineView.measure.width = curWidth;\n        var rects = lineView.text.firstChild.getClientRects();\n        for (var i = 0; i < rects.length - 1; i++) {\n          var cur = rects[i], next = rects[i + 1];\n          if (Math.abs(cur.bottom - next.bottom) > 2)\n            heights.push((cur.bottom + next.top) / 2 - rect.top);\n        }\n      }\n      heights.push(rect.bottom - rect.top);\n    }\n  }\n\n  // Find a line map (mapping character offsets to text nodes) and a\n  // measurement cache for the given line number. (A line view might\n  // contain multiple lines when collapsed ranges are present.)\n  function mapFromLineView(lineView, line, lineN) {\n    if (lineView.line == line)\n      return {map: lineView.measure.map, cache: lineView.measure.cache};\n    for (var i = 0; i < lineView.rest.length; i++)\n      if (lineView.rest[i] == line)\n        return {map: lineView.measure.maps[i], cache: lineView.measure.caches[i]};\n    for (var i = 0; i < lineView.rest.length; i++)\n      if (lineNo(lineView.rest[i]) > lineN)\n        return {map: lineView.measure.maps[i], cache: lineView.measure.caches[i], before: true};\n  }\n\n  // Render a line into the hidden node display.externalMeasured. Used\n  // when measurement is needed for a line that's not in the viewport.\n  function updateExternalMeasurement(cm, line) {\n    line = visualLine(line);\n    var lineN = lineNo(line);\n    var view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN);\n    view.lineN = lineN;\n    var built = view.built = buildLineContent(cm, view);\n    view.text = built.pre;\n    removeChildrenAndAdd(cm.display.lineMeasure, built.pre);\n    return view;\n  }\n\n  // Get a {top, bottom, left, right} box (in line-local coordinates)\n  // for a given character.\n  function measureChar(cm, line, ch, bias) {\n    return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias);\n  }\n\n  // Find a line view that corresponds to the given line number.\n  function findViewForLine(cm, lineN) {\n    if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo)\n      return cm.display.view[findViewIndex(cm, lineN)];\n    var ext = cm.display.externalMeasured;\n    if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size)\n      return ext;\n  }\n\n  // Measurement can be split in two steps, the set-up work that\n  // applies to the whole line, and the measurement of the actual\n  // character. Functions like coordsChar, that need to do a lot of\n  // measurements in a row, can thus ensure that the set-up work is\n  // only done once.\n  function prepareMeasureForLine(cm, line) {\n    var lineN = lineNo(line);\n    var view = findViewForLine(cm, lineN);\n    if (view && !view.text)\n      view = null;\n    else if (view && view.changes)\n      updateLineForChanges(cm, view, lineN, getDimensions(cm));\n    if (!view)\n      view = updateExternalMeasurement(cm, line);\n\n    var info = mapFromLineView(view, line, lineN);\n    return {\n      line: line, view: view, rect: null,\n      map: info.map, cache: info.cache, before: info.before,\n      hasHeights: false\n    };\n  }\n\n  // Given a prepared measurement object, measures the position of an\n  // actual character (or fetches it from the cache).\n  function measureCharPrepared(cm, prepared, ch, bias, varHeight) {\n    if (prepared.before) ch = -1;\n    var key = ch + (bias || \"\"), found;\n    if (prepared.cache.hasOwnProperty(key)) {\n      found = prepared.cache[key];\n    } else {\n      if (!prepared.rect)\n        prepared.rect = prepared.view.text.getBoundingClientRect();\n      if (!prepared.hasHeights) {\n        ensureLineHeights(cm, prepared.view, prepared.rect);\n        prepared.hasHeights = true;\n      }\n      found = measureCharInner(cm, prepared, ch, bias);\n      if (!found.bogus) prepared.cache[key] = found;\n    }\n    return {left: found.left, right: found.right,\n            top: varHeight ? found.rtop : found.top,\n            bottom: varHeight ? found.rbottom : found.bottom};\n  }\n\n  var nullRect = {left: 0, right: 0, top: 0, bottom: 0};\n\n  function measureCharInner(cm, prepared, ch, bias) {\n    var map = prepared.map;\n\n    var node, start, end, collapse;\n    // First, search the line map for the text node corresponding to,\n    // or closest to, the target character.\n    for (var i = 0; i < map.length; i += 3) {\n      var mStart = map[i], mEnd = map[i + 1];\n      if (ch < mStart) {\n        start = 0; end = 1;\n        collapse = \"left\";\n      } else if (ch < mEnd) {\n        start = ch - mStart;\n        end = start + 1;\n      } else if (i == map.length - 3 || ch == mEnd && map[i + 3] > ch) {\n        end = mEnd - mStart;\n        start = end - 1;\n        if (ch >= mEnd) collapse = \"right\";\n      }\n      if (start != null) {\n        node = map[i + 2];\n        if (mStart == mEnd && bias == (node.insertLeft ? \"left\" : \"right\"))\n          collapse = bias;\n        if (bias == \"left\" && start == 0)\n          while (i && map[i - 2] == map[i - 3] && map[i - 1].insertLeft) {\n            node = map[(i -= 3) + 2];\n            collapse = \"left\";\n          }\n        if (bias == \"right\" && start == mEnd - mStart)\n          while (i < map.length - 3 && map[i + 3] == map[i + 4] && !map[i + 5].insertLeft) {\n            node = map[(i += 3) + 2];\n            collapse = \"right\";\n          }\n        break;\n      }\n    }\n\n    var rect;\n    if (node.nodeType == 3) { // If it is a text node, use a range to retrieve the coordinates.\n      for (var i = 0; i < 4; i++) { // Retry a maximum of 4 times when nonsense rectangles are returned\n        while (start && isExtendingChar(prepared.line.text.charAt(mStart + start))) --start;\n        while (mStart + end < mEnd && isExtendingChar(prepared.line.text.charAt(mStart + end))) ++end;\n        if (ie && ie_version < 9 && start == 0 && end == mEnd - mStart) {\n          rect = node.parentNode.getBoundingClientRect();\n        } else if (ie && cm.options.lineWrapping) {\n          var rects = range(node, start, end).getClientRects();\n          if (rects.length)\n            rect = rects[bias == \"right\" ? rects.length - 1 : 0];\n          else\n            rect = nullRect;\n        } else {\n          rect = range(node, start, end).getBoundingClientRect() || nullRect;\n        }\n        if (rect.left || rect.right || start == 0) break;\n        end = start;\n        start = start - 1;\n        collapse = \"right\";\n      }\n      if (ie && ie_version < 11) rect = maybeUpdateRectForZooming(cm.display.measure, rect);\n    } else { // If it is a widget, simply get the box for the whole widget.\n      if (start > 0) collapse = bias = \"right\";\n      var rects;\n      if (cm.options.lineWrapping && (rects = node.getClientRects()).length > 1)\n        rect = rects[bias == \"right\" ? rects.length - 1 : 0];\n      else\n        rect = node.getBoundingClientRect();\n    }\n    if (ie && ie_version < 9 && !start && (!rect || !rect.left && !rect.right)) {\n      var rSpan = node.parentNode.getClientRects()[0];\n      if (rSpan)\n        rect = {left: rSpan.left, right: rSpan.left + charWidth(cm.display), top: rSpan.top, bottom: rSpan.bottom};\n      else\n        rect = nullRect;\n    }\n\n    var rtop = rect.top - prepared.rect.top, rbot = rect.bottom - prepared.rect.top;\n    var mid = (rtop + rbot) / 2;\n    var heights = prepared.view.measure.heights;\n    for (var i = 0; i < heights.length - 1; i++)\n      if (mid < heights[i]) break;\n    var top = i ? heights[i - 1] : 0, bot = heights[i];\n    var result = {left: (collapse == \"right\" ? rect.right : rect.left) - prepared.rect.left,\n                  right: (collapse == \"left\" ? rect.left : rect.right) - prepared.rect.left,\n                  top: top, bottom: bot};\n    if (!rect.left && !rect.right) result.bogus = true;\n    if (!cm.options.singleCursorHeightPerLine) { result.rtop = rtop; result.rbottom = rbot; }\n\n    return result;\n  }\n\n  // Work around problem with bounding client rects on ranges being\n  // returned incorrectly when zoomed on IE10 and below.\n  function maybeUpdateRectForZooming(measure, rect) {\n    if (!window.screen || screen.logicalXDPI == null ||\n        screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure))\n      return rect;\n    var scaleX = screen.logicalXDPI / screen.deviceXDPI;\n    var scaleY = screen.logicalYDPI / screen.deviceYDPI;\n    return {left: rect.left * scaleX, right: rect.right * scaleX,\n            top: rect.top * scaleY, bottom: rect.bottom * scaleY};\n  }\n\n  function clearLineMeasurementCacheFor(lineView) {\n    if (lineView.measure) {\n      lineView.measure.cache = {};\n      lineView.measure.heights = null;\n      if (lineView.rest) for (var i = 0; i < lineView.rest.length; i++)\n        lineView.measure.caches[i] = {};\n    }\n  }\n\n  function clearLineMeasurementCache(cm) {\n    cm.display.externalMeasure = null;\n    removeChildren(cm.display.lineMeasure);\n    for (var i = 0; i < cm.display.view.length; i++)\n      clearLineMeasurementCacheFor(cm.display.view[i]);\n  }\n\n  function clearCaches(cm) {\n    clearLineMeasurementCache(cm);\n    cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null;\n    if (!cm.options.lineWrapping) cm.display.maxLineChanged = true;\n    cm.display.lineNumChars = null;\n  }\n\n  function pageScrollX() { return window.pageXOffset || (document.documentElement || document.body).scrollLeft; }\n  function pageScrollY() { return window.pageYOffset || (document.documentElement || document.body).scrollTop; }\n\n  // Converts a {top, bottom, left, right} box from line-local\n  // coordinates into another coordinate system. Context may be one of\n  // \"line\", \"div\" (display.lineDiv), \"local\"/null (editor), or \"page\".\n  function intoCoordSystem(cm, lineObj, rect, context) {\n    if (lineObj.widgets) for (var i = 0; i < lineObj.widgets.length; ++i) if (lineObj.widgets[i].above) {\n      var size = widgetHeight(lineObj.widgets[i]);\n      rect.top += size; rect.bottom += size;\n    }\n    if (context == \"line\") return rect;\n    if (!context) context = \"local\";\n    var yOff = heightAtLine(lineObj);\n    if (context == \"local\") yOff += paddingTop(cm.display);\n    else yOff -= cm.display.viewOffset;\n    if (context == \"page\" || context == \"window\") {\n      var lOff = cm.display.lineSpace.getBoundingClientRect();\n      yOff += lOff.top + (context == \"window\" ? 0 : pageScrollY());\n      var xOff = lOff.left + (context == \"window\" ? 0 : pageScrollX());\n      rect.left += xOff; rect.right += xOff;\n    }\n    rect.top += yOff; rect.bottom += yOff;\n    return rect;\n  }\n\n  // Coverts a box from \"div\" coords to another coordinate system.\n  // Context may be \"window\", \"page\", \"div\", or \"local\"/null.\n  function fromCoordSystem(cm, coords, context) {\n    if (context == \"div\") return coords;\n    var left = coords.left, top = coords.top;\n    // First move into \"page\" coordinate system\n    if (context == \"page\") {\n      left -= pageScrollX();\n      top -= pageScrollY();\n    } else if (context == \"local\" || !context) {\n      var localBox = cm.display.sizer.getBoundingClientRect();\n      left += localBox.left;\n      top += localBox.top;\n    }\n\n    var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();\n    return {left: left - lineSpaceBox.left, top: top - lineSpaceBox.top};\n  }\n\n  function charCoords(cm, pos, context, lineObj, bias) {\n    if (!lineObj) lineObj = getLine(cm.doc, pos.line);\n    return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context);\n  }\n\n  // Returns a box for a given cursor position, which may have an\n  // 'other' property containing the position of the secondary cursor\n  // on a bidi boundary.\n  function cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {\n    lineObj = lineObj || getLine(cm.doc, pos.line);\n    if (!preparedMeasure) preparedMeasure = prepareMeasureForLine(cm, lineObj);\n    function get(ch, right) {\n      var m = measureCharPrepared(cm, preparedMeasure, ch, right ? \"right\" : \"left\", varHeight);\n      if (right) m.left = m.right; else m.right = m.left;\n      return intoCoordSystem(cm, lineObj, m, context);\n    }\n    function getBidi(ch, partPos) {\n      var part = order[partPos], right = part.level % 2;\n      if (ch == bidiLeft(part) && partPos && part.level < order[partPos - 1].level) {\n        part = order[--partPos];\n        ch = bidiRight(part) - (part.level % 2 ? 0 : 1);\n        right = true;\n      } else if (ch == bidiRight(part) && partPos < order.length - 1 && part.level < order[partPos + 1].level) {\n        part = order[++partPos];\n        ch = bidiLeft(part) - part.level % 2;\n        right = false;\n      }\n      if (right && ch == part.to && ch > part.from) return get(ch - 1);\n      return get(ch, right);\n    }\n    var order = getOrder(lineObj), ch = pos.ch;\n    if (!order) return get(ch);\n    var partPos = getBidiPartAt(order, ch);\n    var val = getBidi(ch, partPos);\n    if (bidiOther != null) val.other = getBidi(ch, bidiOther);\n    return val;\n  }\n\n  // Used to cheaply estimate the coordinates for a position. Used for\n  // intermediate scroll updates.\n  function estimateCoords(cm, pos) {\n    var left = 0, pos = clipPos(cm.doc, pos);\n    if (!cm.options.lineWrapping) left = charWidth(cm.display) * pos.ch;\n    var lineObj = getLine(cm.doc, pos.line);\n    var top = heightAtLine(lineObj) + paddingTop(cm.display);\n    return {left: left, right: left, top: top, bottom: top + lineObj.height};\n  }\n\n  // Positions returned by coordsChar contain some extra information.\n  // xRel is the relative x position of the input coordinates compared\n  // to the found position (so xRel > 0 means the coordinates are to\n  // the right of the character position, for example). When outside\n  // is true, that means the coordinates lie outside the line's\n  // vertical range.\n  function PosWithInfo(line, ch, outside, xRel) {\n    var pos = Pos(line, ch);\n    pos.xRel = xRel;\n    if (outside) pos.outside = true;\n    return pos;\n  }\n\n  // Compute the character position closest to the given coordinates.\n  // Input must be lineSpace-local (\"div\" coordinate system).\n  function coordsChar(cm, x, y) {\n    var doc = cm.doc;\n    y += cm.display.viewOffset;\n    if (y < 0) return PosWithInfo(doc.first, 0, true, -1);\n    var lineN = lineAtHeight(doc, y), last = doc.first + doc.size - 1;\n    if (lineN > last)\n      return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, true, 1);\n    if (x < 0) x = 0;\n\n    var lineObj = getLine(doc, lineN);\n    for (;;) {\n      var found = coordsCharInner(cm, lineObj, lineN, x, y);\n      var merged = collapsedSpanAtEnd(lineObj);\n      var mergedPos = merged && merged.find(0, true);\n      if (merged && (found.ch > mergedPos.from.ch || found.ch == mergedPos.from.ch && found.xRel > 0))\n        lineN = lineNo(lineObj = mergedPos.to.line);\n      else\n        return found;\n    }\n  }\n\n  function coordsCharInner(cm, lineObj, lineNo, x, y) {\n    var innerOff = y - heightAtLine(lineObj);\n    var wrongLine = false, adjust = 2 * cm.display.wrapper.clientWidth;\n    var preparedMeasure = prepareMeasureForLine(cm, lineObj);\n\n    function getX(ch) {\n      var sp = cursorCoords(cm, Pos(lineNo, ch), \"line\", lineObj, preparedMeasure);\n      wrongLine = true;\n      if (innerOff > sp.bottom) return sp.left - adjust;\n      else if (innerOff < sp.top) return sp.left + adjust;\n      else wrongLine = false;\n      return sp.left;\n    }\n\n    var bidi = getOrder(lineObj), dist = lineObj.text.length;\n    var from = lineLeft(lineObj), to = lineRight(lineObj);\n    var fromX = getX(from), fromOutside = wrongLine, toX = getX(to), toOutside = wrongLine;\n\n    if (x > toX) return PosWithInfo(lineNo, to, toOutside, 1);\n    // Do a binary search between these bounds.\n    for (;;) {\n      if (bidi ? to == from || to == moveVisually(lineObj, from, 1) : to - from <= 1) {\n        var ch = x < fromX || x - fromX <= toX - x ? from : to;\n        var xDiff = x - (ch == from ? fromX : toX);\n        while (isExtendingChar(lineObj.text.charAt(ch))) ++ch;\n        var pos = PosWithInfo(lineNo, ch, ch == from ? fromOutside : toOutside,\n                              xDiff < -1 ? -1 : xDiff > 1 ? 1 : 0);\n        return pos;\n      }\n      var step = Math.ceil(dist / 2), middle = from + step;\n      if (bidi) {\n        middle = from;\n        for (var i = 0; i < step; ++i) middle = moveVisually(lineObj, middle, 1);\n      }\n      var middleX = getX(middle);\n      if (middleX > x) {to = middle; toX = middleX; if (toOutside = wrongLine) toX += 1000; dist = step;}\n      else {from = middle; fromX = middleX; fromOutside = wrongLine; dist -= step;}\n    }\n  }\n\n  var measureText;\n  // Compute the default text height.\n  function textHeight(display) {\n    if (display.cachedTextHeight != null) return display.cachedTextHeight;\n    if (measureText == null) {\n      measureText = elt(\"pre\");\n      // Measure a bunch of lines, for browsers that compute\n      // fractional heights.\n      for (var i = 0; i < 49; ++i) {\n        measureText.appendChild(document.createTextNode(\"x\"));\n        measureText.appendChild(elt(\"br\"));\n      }\n      measureText.appendChild(document.createTextNode(\"x\"));\n    }\n    removeChildrenAndAdd(display.measure, measureText);\n    var height = measureText.offsetHeight / 50;\n    if (height > 3) display.cachedTextHeight = height;\n    removeChildren(display.measure);\n    return height || 1;\n  }\n\n  // Compute the default character width.\n  function charWidth(display) {\n    if (display.cachedCharWidth != null) return display.cachedCharWidth;\n    var anchor = elt(\"span\", \"xxxxxxxxxx\");\n    var pre = elt(\"pre\", [anchor]);\n    removeChildrenAndAdd(display.measure, pre);\n    var rect = anchor.getBoundingClientRect(), width = (rect.right - rect.left) / 10;\n    if (width > 2) display.cachedCharWidth = width;\n    return width || 10;\n  }\n\n  // OPERATIONS\n\n  // Operations are used to wrap a series of changes to the editor\n  // state in such a way that each change won't have to update the\n  // cursor and display (which would be awkward, slow, and\n  // error-prone). Instead, display updates are batched and then all\n  // combined and executed at once.\n\n  var operationGroup = null;\n\n  var nextOpId = 0;\n  // Start a new operation.\n  function startOperation(cm) {\n    cm.curOp = {\n      cm: cm,\n      viewChanged: false,      // Flag that indicates that lines might need to be redrawn\n      startHeight: cm.doc.height, // Used to detect need to update scrollbar\n      forceUpdate: false,      // Used to force a redraw\n      updateInput: null,       // Whether to reset the input textarea\n      typing: false,           // Whether this reset should be careful to leave existing text (for compositing)\n      changeObjs: null,        // Accumulated changes, for firing change events\n      cursorActivityHandlers: null, // Set of handlers to fire cursorActivity on\n      cursorActivityCalled: 0, // Tracks which cursorActivity handlers have been called already\n      selectionChanged: false, // Whether the selection needs to be redrawn\n      updateMaxLine: false,    // Set when the widest line needs to be determined anew\n      scrollLeft: null, scrollTop: null, // Intermediate scroll position, not pushed to DOM yet\n      scrollToPos: null,       // Used to scroll to a specific position\n      id: ++nextOpId           // Unique ID\n    };\n    if (operationGroup) {\n      operationGroup.ops.push(cm.curOp);\n    } else {\n      cm.curOp.ownsGroup = operationGroup = {\n        ops: [cm.curOp],\n        delayedCallbacks: []\n      };\n    }\n  }\n\n  function fireCallbacksForOps(group) {\n    // Calls delayed callbacks and cursorActivity handlers until no\n    // new ones appear\n    var callbacks = group.delayedCallbacks, i = 0;\n    do {\n      for (; i < callbacks.length; i++)\n        callbacks[i]();\n      for (var j = 0; j < group.ops.length; j++) {\n        var op = group.ops[j];\n        if (op.cursorActivityHandlers)\n          while (op.cursorActivityCalled < op.cursorActivityHandlers.length)\n            op.cursorActivityHandlers[op.cursorActivityCalled++](op.cm);\n      }\n    } while (i < callbacks.length);\n  }\n\n  // Finish an operation, updating the display and signalling delayed events\n  function endOperation(cm) {\n    var op = cm.curOp, group = op.ownsGroup;\n    if (!group) return;\n\n    try { fireCallbacksForOps(group); }\n    finally {\n      operationGroup = null;\n      for (var i = 0; i < group.ops.length; i++)\n        group.ops[i].cm.curOp = null;\n      endOperations(group);\n    }\n  }\n\n  // The DOM updates done when an operation finishes are batched so\n  // that the minimum number of relayouts are required.\n  function endOperations(group) {\n    var ops = group.ops;\n    for (var i = 0; i < ops.length; i++) // Read DOM\n      endOperation_R1(ops[i]);\n    for (var i = 0; i < ops.length; i++) // Write DOM (maybe)\n      endOperation_W1(ops[i]);\n    for (var i = 0; i < ops.length; i++) // Read DOM\n      endOperation_R2(ops[i]);\n    for (var i = 0; i < ops.length; i++) // Write DOM (maybe)\n      endOperation_W2(ops[i]);\n    for (var i = 0; i < ops.length; i++) // Read DOM\n      endOperation_finish(ops[i]);\n  }\n\n  function endOperation_R1(op) {\n    var cm = op.cm, display = cm.display;\n    if (op.updateMaxLine) findMaxLine(cm);\n\n    op.mustUpdate = op.viewChanged || op.forceUpdate || op.scrollTop != null ||\n      op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom ||\n                         op.scrollToPos.to.line >= display.viewTo) ||\n      display.maxLineChanged && cm.options.lineWrapping;\n    op.update = op.mustUpdate &&\n      new DisplayUpdate(cm, op.mustUpdate && {top: op.scrollTop, ensure: op.scrollToPos}, op.forceUpdate);\n  }\n\n  function endOperation_W1(op) {\n    op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update);\n  }\n\n  function endOperation_R2(op) {\n    var cm = op.cm, display = cm.display;\n    if (op.updatedDisplay) updateHeightsInViewport(cm);\n\n    op.barMeasure = measureForScrollbars(cm);\n\n    // If the max line changed since it was last measured, measure it,\n    // and ensure the document's width matches it.\n    // updateDisplay_W2 will use these properties to do the actual resizing\n    if (display.maxLineChanged && !cm.options.lineWrapping) {\n      op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3;\n      op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo +\n                                  scrollerCutOff - display.scroller.clientWidth);\n    }\n\n    if (op.updatedDisplay || op.selectionChanged)\n      op.newSelectionNodes = drawSelection(cm);\n  }\n\n  function endOperation_W2(op) {\n    var cm = op.cm;\n\n    if (op.adjustWidthTo != null) {\n      cm.display.sizer.style.minWidth = op.adjustWidthTo + \"px\";\n      if (op.maxScrollLeft < cm.doc.scrollLeft)\n        setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), true);\n      cm.display.maxLineChanged = false;\n    }\n\n    if (op.newSelectionNodes)\n      showSelection(cm, op.newSelectionNodes);\n    if (op.updatedDisplay)\n      setDocumentHeight(cm, op.barMeasure);\n    if (op.updatedDisplay || op.startHeight != cm.doc.height)\n      updateScrollbars(cm, op.barMeasure);\n\n    if (op.selectionChanged) restartBlink(cm);\n\n    if (cm.state.focused && op.updateInput)\n      resetInput(cm, op.typing);\n  }\n\n  function endOperation_finish(op) {\n    var cm = op.cm, display = cm.display, doc = cm.doc;\n\n    if (op.adjustWidthTo != null && Math.abs(op.barMeasure.scrollWidth - cm.display.scroller.scrollWidth) > 1)\n      updateScrollbars(cm);\n\n    if (op.updatedDisplay) postUpdateDisplay(cm, op.update);\n\n    // Abort mouse wheel delta measurement, when scrolling explicitly\n    if (display.wheelStartX != null && (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos))\n      display.wheelStartX = display.wheelStartY = null;\n\n    // Propagate the scroll position to the actual DOM scroller\n    if (op.scrollTop != null && (display.scroller.scrollTop != op.scrollTop || op.forceScroll)) {\n      var top = Math.max(0, Math.min(display.scroller.scrollHeight - display.scroller.clientHeight, op.scrollTop));\n      display.scroller.scrollTop = display.scrollbarV.scrollTop = doc.scrollTop = top;\n    }\n    if (op.scrollLeft != null && (display.scroller.scrollLeft != op.scrollLeft || op.forceScroll)) {\n      var left = Math.max(0, Math.min(display.scroller.scrollWidth - display.scroller.clientWidth, op.scrollLeft));\n      display.scroller.scrollLeft = display.scrollbarH.scrollLeft = doc.scrollLeft = left;\n      alignHorizontally(cm);\n    }\n    // If we need to scroll a specific position into view, do so.\n    if (op.scrollToPos) {\n      var coords = scrollPosIntoView(cm, clipPos(doc, op.scrollToPos.from),\n                                     clipPos(doc, op.scrollToPos.to), op.scrollToPos.margin);\n      if (op.scrollToPos.isCursor && cm.state.focused) maybeScrollWindow(cm, coords);\n    }\n\n    // Fire events for markers that are hidden/unidden by editing or\n    // undoing\n    var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;\n    if (hidden) for (var i = 0; i < hidden.length; ++i)\n      if (!hidden[i].lines.length) signal(hidden[i], \"hide\");\n    if (unhidden) for (var i = 0; i < unhidden.length; ++i)\n      if (unhidden[i].lines.length) signal(unhidden[i], \"unhide\");\n\n    if (display.wrapper.offsetHeight)\n      doc.scrollTop = cm.display.scroller.scrollTop;\n\n    // Apply workaround for two webkit bugs\n    if (op.updatedDisplay && webkit) {\n      if (cm.options.lineWrapping)\n        checkForWebkitWidthBug(cm, op.barMeasure); // (Issue #2420)\n      if (op.barMeasure.scrollWidth > op.barMeasure.clientWidth &&\n          op.barMeasure.scrollWidth < op.barMeasure.clientWidth + 1 &&\n          !hScrollbarTakesSpace(cm))\n        updateScrollbars(cm); // (Issue #2562)\n    }\n\n    // Fire change events, and delayed event handlers\n    if (op.changeObjs)\n      signal(cm, \"changes\", cm, op.changeObjs);\n  }\n\n  // Run the given function in an operation\n  function runInOp(cm, f) {\n    if (cm.curOp) return f();\n    startOperation(cm);\n    try { return f(); }\n    finally { endOperation(cm); }\n  }\n  // Wraps a function in an operation. Returns the wrapped function.\n  function operation(cm, f) {\n    return function() {\n      if (cm.curOp) return f.apply(cm, arguments);\n      startOperation(cm);\n      try { return f.apply(cm, arguments); }\n      finally { endOperation(cm); }\n    };\n  }\n  // Used to add methods to editor and doc instances, wrapping them in\n  // operations.\n  function methodOp(f) {\n    return function() {\n      if (this.curOp) return f.apply(this, arguments);\n      startOperation(this);\n      try { return f.apply(this, arguments); }\n      finally { endOperation(this); }\n    };\n  }\n  function docMethodOp(f) {\n    return function() {\n      var cm = this.cm;\n      if (!cm || cm.curOp) return f.apply(this, arguments);\n      startOperation(cm);\n      try { return f.apply(this, arguments); }\n      finally { endOperation(cm); }\n    };\n  }\n\n  // VIEW TRACKING\n\n  // These objects are used to represent the visible (currently drawn)\n  // part of the document. A LineView may correspond to multiple\n  // logical lines, if those are connected by collapsed ranges.\n  function LineView(doc, line, lineN) {\n    // The starting line\n    this.line = line;\n    // Continuing lines, if any\n    this.rest = visualLineContinued(line);\n    // Number of logical lines in this visual line\n    this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1;\n    this.node = this.text = null;\n    this.hidden = lineIsHidden(doc, line);\n  }\n\n  // Create a range of LineView objects for the given lines.\n  function buildViewArray(cm, from, to) {\n    var array = [], nextPos;\n    for (var pos = from; pos < to; pos = nextPos) {\n      var view = new LineView(cm.doc, getLine(cm.doc, pos), pos);\n      nextPos = pos + view.size;\n      array.push(view);\n    }\n    return array;\n  }\n\n  // Updates the display.view data structure for a given change to the\n  // document. From and to are in pre-change coordinates. Lendiff is\n  // the amount of lines added or subtracted by the change. This is\n  // used for changes that span multiple lines, or change the way\n  // lines are divided into visual lines. regLineChange (below)\n  // registers single-line changes.\n  function regChange(cm, from, to, lendiff) {\n    if (from == null) from = cm.doc.first;\n    if (to == null) to = cm.doc.first + cm.doc.size;\n    if (!lendiff) lendiff = 0;\n\n    var display = cm.display;\n    if (lendiff && to < display.viewTo &&\n        (display.updateLineNumbers == null || display.updateLineNumbers > from))\n      display.updateLineNumbers = from;\n\n    cm.curOp.viewChanged = true;\n\n    if (from >= display.viewTo) { // Change after\n      if (sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo)\n        resetView(cm);\n    } else if (to <= display.viewFrom) { // Change before\n      if (sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom) {\n        resetView(cm);\n      } else {\n        display.viewFrom += lendiff;\n        display.viewTo += lendiff;\n      }\n    } else if (from <= display.viewFrom && to >= display.viewTo) { // Full overlap\n      resetView(cm);\n    } else if (from <= display.viewFrom) { // Top overlap\n      var cut = viewCuttingPoint(cm, to, to + lendiff, 1);\n      if (cut) {\n        display.view = display.view.slice(cut.index);\n        display.viewFrom = cut.lineN;\n        display.viewTo += lendiff;\n      } else {\n        resetView(cm);\n      }\n    } else if (to >= display.viewTo) { // Bottom overlap\n      var cut = viewCuttingPoint(cm, from, from, -1);\n      if (cut) {\n        display.view = display.view.slice(0, cut.index);\n        display.viewTo = cut.lineN;\n      } else {\n        resetView(cm);\n      }\n    } else { // Gap in the middle\n      var cutTop = viewCuttingPoint(cm, from, from, -1);\n      var cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);\n      if (cutTop && cutBot) {\n        display.view = display.view.slice(0, cutTop.index)\n          .concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN))\n          .concat(display.view.slice(cutBot.index));\n        display.viewTo += lendiff;\n      } else {\n        resetView(cm);\n      }\n    }\n\n    var ext = display.externalMeasured;\n    if (ext) {\n      if (to < ext.lineN)\n        ext.lineN += lendiff;\n      else if (from < ext.lineN + ext.size)\n        display.externalMeasured = null;\n    }\n  }\n\n  // Register a change to a single line. Type must be one of \"text\",\n  // \"gutter\", \"class\", \"widget\"\n  function regLineChange(cm, line, type) {\n    cm.curOp.viewChanged = true;\n    var display = cm.display, ext = cm.display.externalMeasured;\n    if (ext && line >= ext.lineN && line < ext.lineN + ext.size)\n      display.externalMeasured = null;\n\n    if (line < display.viewFrom || line >= display.viewTo) return;\n    var lineView = display.view[findViewIndex(cm, line)];\n    if (lineView.node == null) return;\n    var arr = lineView.changes || (lineView.changes = []);\n    if (indexOf(arr, type) == -1) arr.push(type);\n  }\n\n  // Clear the view.\n  function resetView(cm) {\n    cm.display.viewFrom = cm.display.viewTo = cm.doc.first;\n    cm.display.view = [];\n    cm.display.viewOffset = 0;\n  }\n\n  // Find the view element corresponding to a given line. Return null\n  // when the line isn't visible.\n  function findViewIndex(cm, n) {\n    if (n >= cm.display.viewTo) return null;\n    n -= cm.display.viewFrom;\n    if (n < 0) return null;\n    var view = cm.display.view;\n    for (var i = 0; i < view.length; i++) {\n      n -= view[i].size;\n      if (n < 0) return i;\n    }\n  }\n\n  function viewCuttingPoint(cm, oldN, newN, dir) {\n    var index = findViewIndex(cm, oldN), diff, view = cm.display.view;\n    if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size)\n      return {index: index, lineN: newN};\n    for (var i = 0, n = cm.display.viewFrom; i < index; i++)\n      n += view[i].size;\n    if (n != oldN) {\n      if (dir > 0) {\n        if (index == view.length - 1) return null;\n        diff = (n + view[index].size) - oldN;\n        index++;\n      } else {\n        diff = n - oldN;\n      }\n      oldN += diff; newN += diff;\n    }\n    while (visualLineNo(cm.doc, newN) != newN) {\n      if (index == (dir < 0 ? 0 : view.length - 1)) return null;\n      newN += dir * view[index - (dir < 0 ? 1 : 0)].size;\n      index += dir;\n    }\n    return {index: index, lineN: newN};\n  }\n\n  // Force the view to cover a given range, adding empty view element\n  // or clipping off existing ones as needed.\n  function adjustView(cm, from, to) {\n    var display = cm.display, view = display.view;\n    if (view.length == 0 || from >= display.viewTo || to <= display.viewFrom) {\n      display.view = buildViewArray(cm, from, to);\n      display.viewFrom = from;\n    } else {\n      if (display.viewFrom > from)\n        display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view);\n      else if (display.viewFrom < from)\n        display.view = display.view.slice(findViewIndex(cm, from));\n      display.viewFrom = from;\n      if (display.viewTo < to)\n        display.view = display.view.concat(buildViewArray(cm, display.viewTo, to));\n      else if (display.viewTo > to)\n        display.view = display.view.slice(0, findViewIndex(cm, to));\n    }\n    display.viewTo = to;\n  }\n\n  // Count the number of lines in the view whose DOM representation is\n  // out of date (or nonexistent).\n  function countDirtyView(cm) {\n    var view = cm.display.view, dirty = 0;\n    for (var i = 0; i < view.length; i++) {\n      var lineView = view[i];\n      if (!lineView.hidden && (!lineView.node || lineView.changes)) ++dirty;\n    }\n    return dirty;\n  }\n\n  // INPUT HANDLING\n\n  // Poll for input changes, using the normal rate of polling. This\n  // runs as long as the editor is focused.\n  function slowPoll(cm) {\n    if (cm.display.pollingFast) return;\n    cm.display.poll.set(cm.options.pollInterval, function() {\n      readInput(cm);\n      if (cm.state.focused) slowPoll(cm);\n    });\n  }\n\n  // When an event has just come in that is likely to add or change\n  // something in the input textarea, we poll faster, to ensure that\n  // the change appears on the screen quickly.\n  function fastPoll(cm) {\n    var missed = false;\n    cm.display.pollingFast = true;\n    function p() {\n      var changed = readInput(cm);\n      if (!changed && !missed) {missed = true; cm.display.poll.set(60, p);}\n      else {cm.display.pollingFast = false; slowPoll(cm);}\n    }\n    cm.display.poll.set(20, p);\n  }\n\n  // This will be set to an array of strings when copying, so that,\n  // when pasting, we know what kind of selections the copied text\n  // was made out of.\n  var lastCopied = null;\n\n  // Read input from the textarea, and update the document to match.\n  // When something is selected, it is present in the textarea, and\n  // selected (unless it is huge, in which case a placeholder is\n  // used). When nothing is selected, the cursor sits after previously\n  // seen text (can be empty), which is stored in prevInput (we must\n  // not reset the textarea when typing, because that breaks IME).\n  function readInput(cm) {\n    var input = cm.display.input, prevInput = cm.display.prevInput, doc = cm.doc;\n    // Since this is called a *lot*, try to bail out as cheaply as\n    // possible when it is clear that nothing happened. hasSelection\n    // will be the case when there is a lot of text in the textarea,\n    // in which case reading its value would be expensive.\n    if (!cm.state.focused || (hasSelection(input) && !prevInput) || isReadOnly(cm) || cm.options.disableInput)\n      return false;\n    // See paste handler for more on the fakedLastChar kludge\n    if (cm.state.pasteIncoming && cm.state.fakedLastChar) {\n      input.value = input.value.substring(0, input.value.length - 1);\n      cm.state.fakedLastChar = false;\n    }\n    var text = input.value;\n    // If nothing changed, bail.\n    if (text == prevInput && !cm.somethingSelected()) return false;\n    // Work around nonsensical selection resetting in IE9/10, and\n    // inexplicable appearance of private area unicode characters on\n    // some key combos in Mac (#2689).\n    if (ie && ie_version >= 9 && cm.display.inputHasSelection === text ||\n        mac && /[\\uf700-\\uf7ff]/.test(text)) {\n      resetInput(cm);\n      return false;\n    }\n\n    var withOp = !cm.curOp;\n    if (withOp) startOperation(cm);\n    cm.display.shift = false;\n\n    if (text.charCodeAt(0) == 0x200b && doc.sel == cm.display.selForContextMenu && !prevInput)\n      prevInput = \"\\u200b\";\n    // Find the part of the input that is actually new\n    var same = 0, l = Math.min(prevInput.length, text.length);\n    while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same)) ++same;\n    var inserted = text.slice(same), textLines = splitLines(inserted);\n\n    // When pasing N lines into N selections, insert one line per selection\n    var multiPaste = null;\n    if (cm.state.pasteIncoming && doc.sel.ranges.length > 1) {\n      if (lastCopied && lastCopied.join(\"\\n\") == inserted)\n        multiPaste = doc.sel.ranges.length % lastCopied.length == 0 && map(lastCopied, splitLines);\n      else if (textLines.length == doc.sel.ranges.length)\n        multiPaste = map(textLines, function(l) { return [l]; });\n    }\n\n    // Normal behavior is to insert the new text into every selection\n    for (var i = doc.sel.ranges.length - 1; i >= 0; i--) {\n      var range = doc.sel.ranges[i];\n      var from = range.from(), to = range.to();\n      // Handle deletion\n      if (same < prevInput.length)\n        from = Pos(from.line, from.ch - (prevInput.length - same));\n      // Handle overwrite\n      else if (cm.state.overwrite && range.empty() && !cm.state.pasteIncoming)\n        to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + lst(textLines).length));\n      var updateInput = cm.curOp.updateInput;\n      var changeEvent = {from: from, to: to, text: multiPaste ? multiPaste[i % multiPaste.length] : textLines,\n                         origin: cm.state.pasteIncoming ? \"paste\" : cm.state.cutIncoming ? \"cut\" : \"+input\"};\n      makeChange(cm.doc, changeEvent);\n      signalLater(cm, \"inputRead\", cm, changeEvent);\n      // When an 'electric' character is inserted, immediately trigger a reindent\n      if (inserted && !cm.state.pasteIncoming && cm.options.electricChars &&\n          cm.options.smartIndent && range.head.ch < 100 &&\n          (!i || doc.sel.ranges[i - 1].head.line != range.head.line)) {\n        var mode = cm.getModeAt(range.head);\n        var end = changeEnd(changeEvent);\n        if (mode.electricChars) {\n          for (var j = 0; j < mode.electricChars.length; j++)\n            if (inserted.indexOf(mode.electricChars.charAt(j)) > -1) {\n              indentLine(cm, end.line, \"smart\");\n              break;\n            }\n        } else if (mode.electricInput) {\n          if (mode.electricInput.test(getLine(doc, end.line).text.slice(0, end.ch)))\n            indentLine(cm, end.line, \"smart\");\n        }\n      }\n    }\n    ensureCursorVisible(cm);\n    cm.curOp.updateInput = updateInput;\n    cm.curOp.typing = true;\n\n    // Don't leave long text in the textarea, since it makes further polling slow\n    if (text.length > 1000 || text.indexOf(\"\\n\") > -1) input.value = cm.display.prevInput = \"\";\n    else cm.display.prevInput = text;\n    if (withOp) endOperation(cm);\n    cm.state.pasteIncoming = cm.state.cutIncoming = false;\n    return true;\n  }\n\n  // Reset the input to correspond to the selection (or to be empty,\n  // when not typing and nothing is selected)\n  function resetInput(cm, typing) {\n    var minimal, selected, doc = cm.doc;\n    if (cm.somethingSelected()) {\n      cm.display.prevInput = \"\";\n      var range = doc.sel.primary();\n      minimal = hasCopyEvent &&\n        (range.to().line - range.from().line > 100 || (selected = cm.getSelection()).length > 1000);\n      var content = minimal ? \"-\" : selected || cm.getSelection();\n      cm.display.input.value = content;\n      if (cm.state.focused) selectInput(cm.display.input);\n      if (ie && ie_version >= 9) cm.display.inputHasSelection = content;\n    } else if (!typing) {\n      cm.display.prevInput = cm.display.input.value = \"\";\n      if (ie && ie_version >= 9) cm.display.inputHasSelection = null;\n    }\n    cm.display.inaccurateSelection = minimal;\n  }\n\n  function focusInput(cm) {\n    if (cm.options.readOnly != \"nocursor\" && (!mobile || activeElt() != cm.display.input))\n      cm.display.input.focus();\n  }\n\n  function ensureFocus(cm) {\n    if (!cm.state.focused) { focusInput(cm); onFocus(cm); }\n  }\n\n  function isReadOnly(cm) {\n    return cm.options.readOnly || cm.doc.cantEdit;\n  }\n\n  // EVENT HANDLERS\n\n  // Attach the necessary event handlers when initializing the editor\n  function registerEventHandlers(cm) {\n    var d = cm.display;\n    on(d.scroller, \"mousedown\", operation(cm, onMouseDown));\n    // Older IE's will not fire a second mousedown for a double click\n    if (ie && ie_version < 11)\n      on(d.scroller, \"dblclick\", operation(cm, function(e) {\n        if (signalDOMEvent(cm, e)) return;\n        var pos = posFromMouse(cm, e);\n        if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) return;\n        e_preventDefault(e);\n        var word = cm.findWordAt(pos);\n        extendSelection(cm.doc, word.anchor, word.head);\n      }));\n    else\n      on(d.scroller, \"dblclick\", function(e) { signalDOMEvent(cm, e) || e_preventDefault(e); });\n    // Prevent normal selection in the editor (we handle our own)\n    on(d.lineSpace, \"selectstart\", function(e) {\n      if (!eventInWidget(d, e)) e_preventDefault(e);\n    });\n    // Some browsers fire contextmenu *after* opening the menu, at\n    // which point we can't mess with it anymore. Context menu is\n    // handled in onMouseDown for these browsers.\n    if (!captureRightClick) on(d.scroller, \"contextmenu\", function(e) {onContextMenu(cm, e);});\n\n    // Sync scrolling between fake scrollbars and real scrollable\n    // area, ensure viewport is updated when scrolling.\n    on(d.scroller, \"scroll\", function() {\n      if (d.scroller.clientHeight) {\n        setScrollTop(cm, d.scroller.scrollTop);\n        setScrollLeft(cm, d.scroller.scrollLeft, true);\n        signal(cm, \"scroll\", cm);\n      }\n    });\n    on(d.scrollbarV, \"scroll\", function() {\n      if (d.scroller.clientHeight) setScrollTop(cm, d.scrollbarV.scrollTop);\n    });\n    on(d.scrollbarH, \"scroll\", function() {\n      if (d.scroller.clientHeight) setScrollLeft(cm, d.scrollbarH.scrollLeft);\n    });\n\n    // Listen to wheel events in order to try and update the viewport on time.\n    on(d.scroller, \"mousewheel\", function(e){onScrollWheel(cm, e);});\n    on(d.scroller, \"DOMMouseScroll\", function(e){onScrollWheel(cm, e);});\n\n    // Prevent clicks in the scrollbars from killing focus\n    function reFocus() { if (cm.state.focused) setTimeout(bind(focusInput, cm), 0); }\n    on(d.scrollbarH, \"mousedown\", reFocus);\n    on(d.scrollbarV, \"mousedown\", reFocus);\n    // Prevent wrapper from ever scrolling\n    on(d.wrapper, \"scroll\", function() { d.wrapper.scrollTop = d.wrapper.scrollLeft = 0; });\n\n    on(d.input, \"keyup\", function(e) { onKeyUp.call(cm, e); });\n    on(d.input, \"input\", function() {\n      if (ie && ie_version >= 9 && cm.display.inputHasSelection) cm.display.inputHasSelection = null;\n      fastPoll(cm);\n    });\n    on(d.input, \"keydown\", operation(cm, onKeyDown));\n    on(d.input, \"keypress\", operation(cm, onKeyPress));\n    on(d.input, \"focus\", bind(onFocus, cm));\n    on(d.input, \"blur\", bind(onBlur, cm));\n\n    function drag_(e) {\n      if (!signalDOMEvent(cm, e)) e_stop(e);\n    }\n    if (cm.options.dragDrop) {\n      on(d.scroller, \"dragstart\", function(e){onDragStart(cm, e);});\n      on(d.scroller, \"dragenter\", drag_);\n      on(d.scroller, \"dragover\", drag_);\n      on(d.scroller, \"drop\", operation(cm, onDrop));\n    }\n    on(d.scroller, \"paste\", function(e) {\n      if (eventInWidget(d, e)) return;\n      cm.state.pasteIncoming = true;\n      focusInput(cm);\n      fastPoll(cm);\n    });\n    on(d.input, \"paste\", function() {\n      // Workaround for webkit bug https://bugs.webkit.org/show_bug.cgi?id=90206\n      // Add a char to the end of textarea before paste occur so that\n      // selection doesn't span to the end of textarea.\n      if (webkit && !cm.state.fakedLastChar && !(new Date - cm.state.lastMiddleDown < 200)) {\n        var start = d.input.selectionStart, end = d.input.selectionEnd;\n        d.input.value += \"$\";\n        // The selection end needs to be set before the start, otherwise there\n        // can be an intermediate non-empty selection between the two, which\n        // can override the middle-click paste buffer on linux and cause the\n        // wrong thing to get pasted.\n        d.input.selectionEnd = end;\n        d.input.selectionStart = start;\n        cm.state.fakedLastChar = true;\n      }\n      cm.state.pasteIncoming = true;\n      fastPoll(cm);\n    });\n\n    function prepareCopyCut(e) {\n      if (cm.somethingSelected()) {\n        lastCopied = cm.getSelections();\n        if (d.inaccurateSelection) {\n          d.prevInput = \"\";\n          d.inaccurateSelection = false;\n          d.input.value = lastCopied.join(\"\\n\");\n          selectInput(d.input);\n        }\n      } else {\n        var text = [], ranges = [];\n        for (var i = 0; i < cm.doc.sel.ranges.length; i++) {\n          var line = cm.doc.sel.ranges[i].head.line;\n          var lineRange = {anchor: Pos(line, 0), head: Pos(line + 1, 0)};\n          ranges.push(lineRange);\n          text.push(cm.getRange(lineRange.anchor, lineRange.head));\n        }\n        if (e.type == \"cut\") {\n          cm.setSelections(ranges, null, sel_dontScroll);\n        } else {\n          d.prevInput = \"\";\n          d.input.value = text.join(\"\\n\");\n          selectInput(d.input);\n        }\n        lastCopied = text;\n      }\n      if (e.type == \"cut\") cm.state.cutIncoming = true;\n    }\n    on(d.input, \"cut\", prepareCopyCut);\n    on(d.input, \"copy\", prepareCopyCut);\n\n    // Needed to handle Tab key in KHTML\n    if (khtml) on(d.sizer, \"mouseup\", function() {\n      if (activeElt() == d.input) d.input.blur();\n      focusInput(cm);\n    });\n  }\n\n  // Called when the window resizes\n  function onResize(cm) {\n    // Might be a text scaling operation, clear size caches.\n    var d = cm.display;\n    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;\n    cm.setSize();\n  }\n\n  // MOUSE EVENTS\n\n  // Return true when the given mouse event happened in a widget\n  function eventInWidget(display, e) {\n    for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {\n      if (!n || n.ignoreEvents || n.parentNode == display.sizer && n != display.mover) return true;\n    }\n  }\n\n  // Given a mouse event, find the corresponding position. If liberal\n  // is false, it checks whether a gutter or scrollbar was clicked,\n  // and returns null if it was. forRect is used by rectangular\n  // selections, and tries to estimate a character position even for\n  // coordinates beyond the right of the text.\n  function posFromMouse(cm, e, liberal, forRect) {\n    var display = cm.display;\n    if (!liberal) {\n      var target = e_target(e);\n      if (target == display.scrollbarH || target == display.scrollbarV ||\n          target == display.scrollbarFiller || target == display.gutterFiller) return null;\n    }\n    var x, y, space = display.lineSpace.getBoundingClientRect();\n    // Fails unpredictably on IE[67] when mouse is dragged around quickly.\n    try { x = e.clientX - space.left; y = e.clientY - space.top; }\n    catch (e) { return null; }\n    var coords = coordsChar(cm, x, y), line;\n    if (forRect && coords.xRel == 1 && (line = getLine(cm.doc, coords.line).text).length == coords.ch) {\n      var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length;\n      coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff));\n    }\n    return coords;\n  }\n\n  // A mouse down can be a single click, double click, triple click,\n  // start of selection drag, start of text drag, new cursor\n  // (ctrl-click), rectangle drag (alt-drag), or xwin\n  // middle-click-paste. Or it might be a click on something we should\n  // not interfere with, such as a scrollbar or widget.\n  function onMouseDown(e) {\n    if (signalDOMEvent(this, e)) return;\n    var cm = this, display = cm.display;\n    display.shift = e.shiftKey;\n\n    if (eventInWidget(display, e)) {\n      if (!webkit) {\n        // Briefly turn off draggability, to allow widgets to do\n        // normal dragging things.\n        display.scroller.draggable = false;\n        setTimeout(function(){display.scroller.draggable = true;}, 100);\n      }\n      return;\n    }\n    if (clickInGutter(cm, e)) return;\n    var start = posFromMouse(cm, e);\n    window.focus();\n\n    switch (e_button(e)) {\n    case 1:\n      if (start)\n        leftButtonDown(cm, e, start);\n      else if (e_target(e) == display.scroller)\n        e_preventDefault(e);\n      break;\n    case 2:\n      if (webkit) cm.state.lastMiddleDown = +new Date;\n      if (start) extendSelection(cm.doc, start);\n      setTimeout(bind(focusInput, cm), 20);\n      e_preventDefault(e);\n      break;\n    case 3:\n      if (captureRightClick) onContextMenu(cm, e);\n      break;\n    }\n  }\n\n  var lastClick, lastDoubleClick;\n  function leftButtonDown(cm, e, start) {\n    setTimeout(bind(ensureFocus, cm), 0);\n\n    var now = +new Date, type;\n    if (lastDoubleClick && lastDoubleClick.time > now - 400 && cmp(lastDoubleClick.pos, start) == 0) {\n      type = \"triple\";\n    } else if (lastClick && lastClick.time > now - 400 && cmp(lastClick.pos, start) == 0) {\n      type = \"double\";\n      lastDoubleClick = {time: now, pos: start};\n    } else {\n      type = \"single\";\n      lastClick = {time: now, pos: start};\n    }\n\n    var sel = cm.doc.sel, modifier = mac ? e.metaKey : e.ctrlKey;\n    if (cm.options.dragDrop && dragAndDrop && !isReadOnly(cm) &&\n        type == \"single\" && sel.contains(start) > -1 && sel.somethingSelected())\n      leftButtonStartDrag(cm, e, start, modifier);\n    else\n      leftButtonSelect(cm, e, start, type, modifier);\n  }\n\n  // Start a text drag. When it ends, see if any dragging actually\n  // happen, and treat as a click if it didn't.\n  function leftButtonStartDrag(cm, e, start, modifier) {\n    var display = cm.display;\n    var dragEnd = operation(cm, function(e2) {\n      if (webkit) display.scroller.draggable = false;\n      cm.state.draggingText = false;\n      off(document, \"mouseup\", dragEnd);\n      off(display.scroller, \"drop\", dragEnd);\n      if (Math.abs(e.clientX - e2.clientX) + Math.abs(e.clientY - e2.clientY) < 10) {\n        e_preventDefault(e2);\n        if (!modifier)\n          extendSelection(cm.doc, start);\n        focusInput(cm);\n        // Work around unexplainable focus problem in IE9 (#2127)\n        if (ie && ie_version == 9)\n          setTimeout(function() {document.body.focus(); focusInput(cm);}, 20);\n      }\n    });\n    // Let the drag handler handle this.\n    if (webkit) display.scroller.draggable = true;\n    cm.state.draggingText = dragEnd;\n    // IE's approach to draggable\n    if (display.scroller.dragDrop) display.scroller.dragDrop();\n    on(document, \"mouseup\", dragEnd);\n    on(display.scroller, \"drop\", dragEnd);\n  }\n\n  // Normal selection, as opposed to text dragging.\n  function leftButtonSelect(cm, e, start, type, addNew) {\n    var display = cm.display, doc = cm.doc;\n    e_preventDefault(e);\n\n    var ourRange, ourIndex, startSel = doc.sel;\n    if (addNew && !e.shiftKey) {\n      ourIndex = doc.sel.contains(start);\n      if (ourIndex > -1)\n        ourRange = doc.sel.ranges[ourIndex];\n      else\n        ourRange = new Range(start, start);\n    } else {\n      ourRange = doc.sel.primary();\n    }\n\n    if (e.altKey) {\n      type = \"rect\";\n      if (!addNew) ourRange = new Range(start, start);\n      start = posFromMouse(cm, e, true, true);\n      ourIndex = -1;\n    } else if (type == \"double\") {\n      var word = cm.findWordAt(start);\n      if (cm.display.shift || doc.extend)\n        ourRange = extendRange(doc, ourRange, word.anchor, word.head);\n      else\n        ourRange = word;\n    } else if (type == \"triple\") {\n      var line = new Range(Pos(start.line, 0), clipPos(doc, Pos(start.line + 1, 0)));\n      if (cm.display.shift || doc.extend)\n        ourRange = extendRange(doc, ourRange, line.anchor, line.head);\n      else\n        ourRange = line;\n    } else {\n      ourRange = extendRange(doc, ourRange, start);\n    }\n\n    if (!addNew) {\n      ourIndex = 0;\n      setSelection(doc, new Selection([ourRange], 0), sel_mouse);\n      startSel = doc.sel;\n    } else if (ourIndex > -1) {\n      replaceOneSelection(doc, ourIndex, ourRange, sel_mouse);\n    } else {\n      ourIndex = doc.sel.ranges.length;\n      setSelection(doc, normalizeSelection(doc.sel.ranges.concat([ourRange]), ourIndex),\n                   {scroll: false, origin: \"*mouse\"});\n    }\n\n    var lastPos = start;\n    function extendTo(pos) {\n      if (cmp(lastPos, pos) == 0) return;\n      lastPos = pos;\n\n      if (type == \"rect\") {\n        var ranges = [], tabSize = cm.options.tabSize;\n        var startCol = countColumn(getLine(doc, start.line).text, start.ch, tabSize);\n        var posCol = countColumn(getLine(doc, pos.line).text, pos.ch, tabSize);\n        var left = Math.min(startCol, posCol), right = Math.max(startCol, posCol);\n        for (var line = Math.min(start.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start.line, pos.line));\n             line <= end; line++) {\n          var text = getLine(doc, line).text, leftPos = findColumn(text, left, tabSize);\n          if (left == right)\n            ranges.push(new Range(Pos(line, leftPos), Pos(line, leftPos)));\n          else if (text.length > leftPos)\n            ranges.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right, tabSize))));\n        }\n        if (!ranges.length) ranges.push(new Range(start, start));\n        setSelection(doc, normalizeSelection(startSel.ranges.slice(0, ourIndex).concat(ranges), ourIndex),\n                     {origin: \"*mouse\", scroll: false});\n        cm.scrollIntoView(pos);\n      } else {\n        var oldRange = ourRange;\n        var anchor = oldRange.anchor, head = pos;\n        if (type != \"single\") {\n          if (type == \"double\")\n            var range = cm.findWordAt(pos);\n          else\n            var range = new Range(Pos(pos.line, 0), clipPos(doc, Pos(pos.line + 1, 0)));\n          if (cmp(range.anchor, anchor) > 0) {\n            head = range.head;\n            anchor = minPos(oldRange.from(), range.anchor);\n          } else {\n            head = range.anchor;\n            anchor = maxPos(oldRange.to(), range.head);\n          }\n        }\n        var ranges = startSel.ranges.slice(0);\n        ranges[ourIndex] = new Range(clipPos(doc, anchor), head);\n        setSelection(doc, normalizeSelection(ranges, ourIndex), sel_mouse);\n      }\n    }\n\n    var editorSize = display.wrapper.getBoundingClientRect();\n    // Used to ensure timeout re-tries don't fire when another extend\n    // happened in the meantime (clearTimeout isn't reliable -- at\n    // least on Chrome, the timeouts still happen even when cleared,\n    // if the clear happens after their scheduled firing time).\n    var counter = 0;\n\n    function extend(e) {\n      var curCount = ++counter;\n      var cur = posFromMouse(cm, e, true, type == \"rect\");\n      if (!cur) return;\n      if (cmp(cur, lastPos) != 0) {\n        ensureFocus(cm);\n        extendTo(cur);\n        var visible = visibleLines(display, doc);\n        if (cur.line >= visible.to || cur.line < visible.from)\n          setTimeout(operation(cm, function(){if (counter == curCount) extend(e);}), 150);\n      } else {\n        var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;\n        if (outside) setTimeout(operation(cm, function() {\n          if (counter != curCount) return;\n          display.scroller.scrollTop += outside;\n          extend(e);\n        }), 50);\n      }\n    }\n\n    function done(e) {\n      counter = Infinity;\n      e_preventDefault(e);\n      focusInput(cm);\n      off(document, \"mousemove\", move);\n      off(document, \"mouseup\", up);\n      doc.history.lastSelOrigin = null;\n    }\n\n    var move = operation(cm, function(e) {\n      if (!e_button(e)) done(e);\n      else extend(e);\n    });\n    var up = operation(cm, done);\n    on(document, \"mousemove\", move);\n    on(document, \"mouseup\", up);\n  }\n\n  // Determines whether an event happened in the gutter, and fires the\n  // handlers for the corresponding event.\n  function gutterEvent(cm, e, type, prevent, signalfn) {\n    try { var mX = e.clientX, mY = e.clientY; }\n    catch(e) { return false; }\n    if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right)) return false;\n    if (prevent) e_preventDefault(e);\n\n    var display = cm.display;\n    var lineBox = display.lineDiv.getBoundingClientRect();\n\n    if (mY > lineBox.bottom || !hasHandler(cm, type)) return e_defaultPrevented(e);\n    mY -= lineBox.top - display.viewOffset;\n\n    for (var i = 0; i < cm.options.gutters.length; ++i) {\n      var g = display.gutters.childNodes[i];\n      if (g && g.getBoundingClientRect().right >= mX) {\n        var line = lineAtHeight(cm.doc, mY);\n        var gutter = cm.options.gutters[i];\n        signalfn(cm, type, cm, line, gutter, e);\n        return e_defaultPrevented(e);\n      }\n    }\n  }\n\n  function clickInGutter(cm, e) {\n    return gutterEvent(cm, e, \"gutterClick\", true, signalLater);\n  }\n\n  // Kludge to work around strange IE behavior where it'll sometimes\n  // re-fire a series of drag-related events right after the drop (#1551)\n  var lastDrop = 0;\n\n  function onDrop(e) {\n    var cm = this;\n    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e))\n      return;\n    e_preventDefault(e);\n    if (ie) lastDrop = +new Date;\n    var pos = posFromMouse(cm, e, true), files = e.dataTransfer.files;\n    if (!pos || isReadOnly(cm)) return;\n    // Might be a file drop, in which case we simply extract the text\n    // and insert it.\n    if (files && files.length && window.FileReader && window.File) {\n      var n = files.length, text = Array(n), read = 0;\n      var loadFile = function(file, i) {\n        var reader = new FileReader;\n        reader.onload = operation(cm, function() {\n          text[i] = reader.result;\n          if (++read == n) {\n            pos = clipPos(cm.doc, pos);\n            var change = {from: pos, to: pos, text: splitLines(text.join(\"\\n\")), origin: \"paste\"};\n            makeChange(cm.doc, change);\n            setSelectionReplaceHistory(cm.doc, simpleSelection(pos, changeEnd(change)));\n          }\n        });\n        reader.readAsText(file);\n      };\n      for (var i = 0; i < n; ++i) loadFile(files[i], i);\n    } else { // Normal drop\n      // Don't do a replace if the drop happened inside of the selected text.\n      if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) {\n        cm.state.draggingText(e);\n        // Ensure the editor is re-focused\n        setTimeout(bind(focusInput, cm), 20);\n        return;\n      }\n      try {\n        var text = e.dataTransfer.getData(\"Text\");\n        if (text) {\n          if (cm.state.draggingText && !(mac ? e.metaKey : e.ctrlKey))\n            var selected = cm.listSelections();\n          setSelectionNoUndo(cm.doc, simpleSelection(pos, pos));\n          if (selected) for (var i = 0; i < selected.length; ++i)\n            replaceRange(cm.doc, \"\", selected[i].anchor, selected[i].head, \"drag\");\n          cm.replaceSelection(text, \"around\", \"paste\");\n          focusInput(cm);\n        }\n      }\n      catch(e){}\n    }\n  }\n\n  function onDragStart(cm, e) {\n    if (ie && (!cm.state.draggingText || +new Date - lastDrop < 100)) { e_stop(e); return; }\n    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) return;\n\n    e.dataTransfer.setData(\"Text\", cm.getSelection());\n\n    // Use dummy image instead of default browsers image.\n    // Recent Safari (~6.0.2) have a tendency to segfault when this happens, so we don't do it there.\n    if (e.dataTransfer.setDragImage && !safari) {\n      var img = elt(\"img\", null, null, \"position: fixed; left: 0; top: 0;\");\n      img.src = \"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\";\n      if (presto) {\n        img.width = img.height = 1;\n        cm.display.wrapper.appendChild(img);\n        // Force a relayout, or Opera won't use our image for some obscure reason\n        img._top = img.offsetTop;\n      }\n      e.dataTransfer.setDragImage(img, 0, 0);\n      if (presto) img.parentNode.removeChild(img);\n    }\n  }\n\n  // SCROLL EVENTS\n\n  // Sync the scrollable area and scrollbars, ensure the viewport\n  // covers the visible area.\n  function setScrollTop(cm, val) {\n    if (Math.abs(cm.doc.scrollTop - val) < 2) return;\n    cm.doc.scrollTop = val;\n    if (!gecko) updateDisplaySimple(cm, {top: val});\n    if (cm.display.scroller.scrollTop != val) cm.display.scroller.scrollTop = val;\n    if (cm.display.scrollbarV.scrollTop != val) cm.display.scrollbarV.scrollTop = val;\n    if (gecko) updateDisplaySimple(cm);\n    startWorker(cm, 100);\n  }\n  // Sync scroller and scrollbar, ensure the gutter elements are\n  // aligned.\n  function setScrollLeft(cm, val, isScroller) {\n    if (isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) return;\n    val = Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth);\n    cm.doc.scrollLeft = val;\n    alignHorizontally(cm);\n    if (cm.display.scroller.scrollLeft != val) cm.display.scroller.scrollLeft = val;\n    if (cm.display.scrollbarH.scrollLeft != val) cm.display.scrollbarH.scrollLeft = val;\n  }\n\n  // Since the delta values reported on mouse wheel events are\n  // unstandardized between browsers and even browser versions, and\n  // generally horribly unpredictable, this code starts by measuring\n  // the scroll effect that the first few mouse wheel events have,\n  // and, from that, detects the way it can convert deltas to pixel\n  // offsets afterwards.\n  //\n  // The reason we want to know the amount a wheel event will scroll\n  // is that it gives us a chance to update the display before the\n  // actual scrolling happens, reducing flickering.\n\n  var wheelSamples = 0, wheelPixelsPerUnit = null;\n  // Fill in a browser-detected starting value on browsers where we\n  // know one. These don't have to be accurate -- the result of them\n  // being wrong would just be a slight flicker on the first wheel\n  // scroll (if it is large enough).\n  if (ie) wheelPixelsPerUnit = -.53;\n  else if (gecko) wheelPixelsPerUnit = 15;\n  else if (chrome) wheelPixelsPerUnit = -.7;\n  else if (safari) wheelPixelsPerUnit = -1/3;\n\n  function onScrollWheel(cm, e) {\n    var dx = e.wheelDeltaX, dy = e.wheelDeltaY;\n    if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) dx = e.detail;\n    if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) dy = e.detail;\n    else if (dy == null) dy = e.wheelDelta;\n\n    var display = cm.display, scroll = display.scroller;\n    // Quit if there's nothing to scroll here\n    if (!(dx && scroll.scrollWidth > scroll.clientWidth ||\n          dy && scroll.scrollHeight > scroll.clientHeight)) return;\n\n    // Webkit browsers on OS X abort momentum scrolls when the target\n    // of the scroll event is removed from the scrollable element.\n    // This hack (see related code in patchDisplay) makes sure the\n    // element is kept around.\n    if (dy && mac && webkit) {\n      outer: for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) {\n        for (var i = 0; i < view.length; i++) {\n          if (view[i].node == cur) {\n            cm.display.currentWheelTarget = cur;\n            break outer;\n          }\n        }\n      }\n    }\n\n    // On some browsers, horizontal scrolling will cause redraws to\n    // happen before the gutter has been realigned, causing it to\n    // wriggle around in a most unseemly way. When we have an\n    // estimated pixels/delta value, we just handle horizontal\n    // scrolling entirely here. It'll be slightly off from native, but\n    // better than glitching out.\n    if (dx && !gecko && !presto && wheelPixelsPerUnit != null) {\n      if (dy)\n        setScrollTop(cm, Math.max(0, Math.min(scroll.scrollTop + dy * wheelPixelsPerUnit, scroll.scrollHeight - scroll.clientHeight)));\n      setScrollLeft(cm, Math.max(0, Math.min(scroll.scrollLeft + dx * wheelPixelsPerUnit, scroll.scrollWidth - scroll.clientWidth)));\n      e_preventDefault(e);\n      display.wheelStartX = null; // Abort measurement, if in progress\n      return;\n    }\n\n    // 'Project' the visible viewport to cover the area that is being\n    // scrolled into view (if we know enough to estimate it).\n    if (dy && wheelPixelsPerUnit != null) {\n      var pixels = dy * wheelPixelsPerUnit;\n      var top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight;\n      if (pixels < 0) top = Math.max(0, top + pixels - 50);\n      else bot = Math.min(cm.doc.height, bot + pixels + 50);\n      updateDisplaySimple(cm, {top: top, bottom: bot});\n    }\n\n    if (wheelSamples < 20) {\n      if (display.wheelStartX == null) {\n        display.wheelStartX = scroll.scrollLeft; display.wheelStartY = scroll.scrollTop;\n        display.wheelDX = dx; display.wheelDY = dy;\n        setTimeout(function() {\n          if (display.wheelStartX == null) return;\n          var movedX = scroll.scrollLeft - display.wheelStartX;\n          var movedY = scroll.scrollTop - display.wheelStartY;\n          var sample = (movedY && display.wheelDY && movedY / display.wheelDY) ||\n            (movedX && display.wheelDX && movedX / display.wheelDX);\n          display.wheelStartX = display.wheelStartY = null;\n          if (!sample) return;\n          wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);\n          ++wheelSamples;\n        }, 200);\n      } else {\n        display.wheelDX += dx; display.wheelDY += dy;\n      }\n    }\n  }\n\n  // KEY EVENTS\n\n  // Run a handler that was bound to a key.\n  function doHandleBinding(cm, bound, dropShift) {\n    if (typeof bound == \"string\") {\n      bound = commands[bound];\n      if (!bound) return false;\n    }\n    // Ensure previous input has been read, so that the handler sees a\n    // consistent view of the document\n    if (cm.display.pollingFast && readInput(cm)) cm.display.pollingFast = false;\n    var prevShift = cm.display.shift, done = false;\n    try {\n      if (isReadOnly(cm)) cm.state.suppressEdits = true;\n      if (dropShift) cm.display.shift = false;\n      done = bound(cm) != Pass;\n    } finally {\n      cm.display.shift = prevShift;\n      cm.state.suppressEdits = false;\n    }\n    return done;\n  }\n\n  // Collect the currently active keymaps.\n  function allKeyMaps(cm) {\n    var maps = cm.state.keyMaps.slice(0);\n    if (cm.options.extraKeys) maps.push(cm.options.extraKeys);\n    maps.push(cm.options.keyMap);\n    return maps;\n  }\n\n  var maybeTransition;\n  // Handle a key from the keydown event.\n  function handleKeyBinding(cm, e) {\n    // Handle automatic keymap transitions\n    var startMap = getKeyMap(cm.options.keyMap), next = startMap.auto;\n    clearTimeout(maybeTransition);\n    if (next && !isModifierKey(e)) maybeTransition = setTimeout(function() {\n      if (getKeyMap(cm.options.keyMap) == startMap) {\n        cm.options.keyMap = (next.call ? next.call(null, cm) : next);\n        keyMapChanged(cm);\n      }\n    }, 50);\n\n    var name = keyName(e, true), handled = false;\n    if (!name) return false;\n    var keymaps = allKeyMaps(cm);\n\n    if (e.shiftKey) {\n      // First try to resolve full name (including 'Shift-'). Failing\n      // that, see if there is a cursor-motion command (starting with\n      // 'go') bound to the keyname without 'Shift-'.\n      handled = lookupKey(\"Shift-\" + name, keymaps, function(b) {return doHandleBinding(cm, b, true);})\n             || lookupKey(name, keymaps, function(b) {\n                  if (typeof b == \"string\" ? /^go[A-Z]/.test(b) : b.motion)\n                    return doHandleBinding(cm, b);\n                });\n    } else {\n      handled = lookupKey(name, keymaps, function(b) { return doHandleBinding(cm, b); });\n    }\n\n    if (handled) {\n      e_preventDefault(e);\n      restartBlink(cm);\n      signalLater(cm, \"keyHandled\", cm, name, e);\n    }\n    return handled;\n  }\n\n  // Handle a key from the keypress event\n  function handleCharBinding(cm, e, ch) {\n    var handled = lookupKey(\"'\" + ch + \"'\", allKeyMaps(cm),\n                            function(b) { return doHandleBinding(cm, b, true); });\n    if (handled) {\n      e_preventDefault(e);\n      restartBlink(cm);\n      signalLater(cm, \"keyHandled\", cm, \"'\" + ch + \"'\", e);\n    }\n    return handled;\n  }\n\n  var lastStoppedKey = null;\n  function onKeyDown(e) {\n    var cm = this;\n    ensureFocus(cm);\n    if (signalDOMEvent(cm, e)) return;\n    // IE does strange things with escape.\n    if (ie && ie_version < 11 && e.keyCode == 27) e.returnValue = false;\n    var code = e.keyCode;\n    cm.display.shift = code == 16 || e.shiftKey;\n    var handled = handleKeyBinding(cm, e);\n    if (presto) {\n      lastStoppedKey = handled ? code : null;\n      // Opera has no cut event... we try to at least catch the key combo\n      if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey))\n        cm.replaceSelection(\"\", null, \"cut\");\n    }\n\n    // Turn mouse into crosshair when Alt is held on Mac.\n    if (code == 18 && !/\\bCodeMirror-crosshair\\b/.test(cm.display.lineDiv.className))\n      showCrossHair(cm);\n  }\n\n  function showCrossHair(cm) {\n    var lineDiv = cm.display.lineDiv;\n    addClass(lineDiv, \"CodeMirror-crosshair\");\n\n    function up(e) {\n      if (e.keyCode == 18 || !e.altKey) {\n        rmClass(lineDiv, \"CodeMirror-crosshair\");\n        off(document, \"keyup\", up);\n        off(document, \"mouseover\", up);\n      }\n    }\n    on(document, \"keyup\", up);\n    on(document, \"mouseover\", up);\n  }\n\n  function onKeyUp(e) {\n    if (e.keyCode == 16) this.doc.sel.shift = false;\n    signalDOMEvent(this, e);\n  }\n\n  function onKeyPress(e) {\n    var cm = this;\n    if (signalDOMEvent(cm, e) || e.ctrlKey && !e.altKey || mac && e.metaKey) return;\n    var keyCode = e.keyCode, charCode = e.charCode;\n    if (presto && keyCode == lastStoppedKey) {lastStoppedKey = null; e_preventDefault(e); return;}\n    if (((presto && (!e.which || e.which < 10)) || khtml) && handleKeyBinding(cm, e)) return;\n    var ch = String.fromCharCode(charCode == null ? keyCode : charCode);\n    if (handleCharBinding(cm, e, ch)) return;\n    if (ie && ie_version >= 9) cm.display.inputHasSelection = null;\n    fastPoll(cm);\n  }\n\n  // FOCUS/BLUR EVENTS\n\n  function onFocus(cm) {\n    if (cm.options.readOnly == \"nocursor\") return;\n    if (!cm.state.focused) {\n      signal(cm, \"focus\", cm);\n      cm.state.focused = true;\n      addClass(cm.display.wrapper, \"CodeMirror-focused\");\n      // The prevInput test prevents this from firing when a context\n      // menu is closed (since the resetInput would kill the\n      // select-all detection hack)\n      if (!cm.curOp && cm.display.selForContextMenu != cm.doc.sel) {\n        resetInput(cm);\n        if (webkit) setTimeout(bind(resetInput, cm, true), 0); // Issue #1730\n      }\n    }\n    slowPoll(cm);\n    restartBlink(cm);\n  }\n  function onBlur(cm) {\n    if (cm.state.focused) {\n      signal(cm, \"blur\", cm);\n      cm.state.focused = false;\n      rmClass(cm.display.wrapper, \"CodeMirror-focused\");\n    }\n    clearInterval(cm.display.blinker);\n    setTimeout(function() {if (!cm.state.focused) cm.display.shift = false;}, 150);\n  }\n\n  // CONTEXT MENU HANDLING\n\n  // To make the context menu work, we need to briefly unhide the\n  // textarea (making it as unobtrusive as possible) to let the\n  // right-click take effect on it.\n  function onContextMenu(cm, e) {\n    if (signalDOMEvent(cm, e, \"contextmenu\")) return;\n    var display = cm.display;\n    if (eventInWidget(display, e) || contextMenuInGutter(cm, e)) return;\n\n    var pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop;\n    if (!pos || presto) return; // Opera is difficult.\n\n    // Reset the current text selection only if the click is done outside of the selection\n    // and 'resetSelectionOnContextMenu' option is true.\n    var reset = cm.options.resetSelectionOnContextMenu;\n    if (reset && cm.doc.sel.contains(pos) == -1)\n      operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll);\n\n    var oldCSS = display.input.style.cssText;\n    display.inputDiv.style.position = \"absolute\";\n    display.input.style.cssText = \"position: fixed; width: 30px; height: 30px; top: \" + (e.clientY - 5) +\n      \"px; left: \" + (e.clientX - 5) + \"px; z-index: 1000; background: \" +\n      (ie ? \"rgba(255, 255, 255, .05)\" : \"transparent\") +\n      \"; outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);\";\n    if (webkit) var oldScrollY = window.scrollY; // Work around Chrome issue (#2712)\n    focusInput(cm);\n    if (webkit) window.scrollTo(null, oldScrollY);\n    resetInput(cm);\n    // Adds \"Select all\" to context menu in FF\n    if (!cm.somethingSelected()) display.input.value = display.prevInput = \" \";\n    display.selForContextMenu = cm.doc.sel;\n    clearTimeout(display.detectingSelectAll);\n\n    // Select-all will be greyed out if there's nothing to select, so\n    // this adds a zero-width space so that we can later check whether\n    // it got selected.\n    function prepareSelectAllHack() {\n      if (display.input.selectionStart != null) {\n        var selected = cm.somethingSelected();\n        var extval = display.input.value = \"\\u200b\" + (selected ? display.input.value : \"\");\n        display.prevInput = selected ? \"\" : \"\\u200b\";\n        display.input.selectionStart = 1; display.input.selectionEnd = extval.length;\n        // Re-set this, in case some other handler touched the\n        // selection in the meantime.\n        display.selForContextMenu = cm.doc.sel;\n      }\n    }\n    function rehide() {\n      display.inputDiv.style.position = \"relative\";\n      display.input.style.cssText = oldCSS;\n      if (ie && ie_version < 9) display.scrollbarV.scrollTop = display.scroller.scrollTop = scrollPos;\n      slowPoll(cm);\n\n      // Try to detect the user choosing select-all\n      if (display.input.selectionStart != null) {\n        if (!ie || (ie && ie_version < 9)) prepareSelectAllHack();\n        var i = 0, poll = function() {\n          if (display.selForContextMenu == cm.doc.sel && display.input.selectionStart == 0)\n            operation(cm, commands.selectAll)(cm);\n          else if (i++ < 10) display.detectingSelectAll = setTimeout(poll, 500);\n          else resetInput(cm);\n        };\n        display.detectingSelectAll = setTimeout(poll, 200);\n      }\n    }\n\n    if (ie && ie_version >= 9) prepareSelectAllHack();\n    if (captureRightClick) {\n      e_stop(e);\n      var mouseup = function() {\n        off(window, \"mouseup\", mouseup);\n        setTimeout(rehide, 20);\n      };\n      on(window, \"mouseup\", mouseup);\n    } else {\n      setTimeout(rehide, 50);\n    }\n  }\n\n  function contextMenuInGutter(cm, e) {\n    if (!hasHandler(cm, \"gutterContextMenu\")) return false;\n    return gutterEvent(cm, e, \"gutterContextMenu\", false, signal);\n  }\n\n  // UPDATING\n\n  // Compute the position of the end of a change (its 'to' property\n  // refers to the pre-change end).\n  var changeEnd = CodeMirror.changeEnd = function(change) {\n    if (!change.text) return change.to;\n    return Pos(change.from.line + change.text.length - 1,\n               lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0));\n  };\n\n  // Adjust a position to refer to the post-change position of the\n  // same text, or the end of the change if the change covers it.\n  function adjustForChange(pos, change) {\n    if (cmp(pos, change.from) < 0) return pos;\n    if (cmp(pos, change.to) <= 0) return changeEnd(change);\n\n    var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;\n    if (pos.line == change.to.line) ch += changeEnd(change).ch - change.to.ch;\n    return Pos(line, ch);\n  }\n\n  function computeSelAfterChange(doc, change) {\n    var out = [];\n    for (var i = 0; i < doc.sel.ranges.length; i++) {\n      var range = doc.sel.ranges[i];\n      out.push(new Range(adjustForChange(range.anchor, change),\n                         adjustForChange(range.head, change)));\n    }\n    return normalizeSelection(out, doc.sel.primIndex);\n  }\n\n  function offsetPos(pos, old, nw) {\n    if (pos.line == old.line)\n      return Pos(nw.line, pos.ch - old.ch + nw.ch);\n    else\n      return Pos(nw.line + (pos.line - old.line), pos.ch);\n  }\n\n  // Used by replaceSelections to allow moving the selection to the\n  // start or around the replaced test. Hint may be \"start\" or \"around\".\n  function computeReplacedSel(doc, changes, hint) {\n    var out = [];\n    var oldPrev = Pos(doc.first, 0), newPrev = oldPrev;\n    for (var i = 0; i < changes.length; i++) {\n      var change = changes[i];\n      var from = offsetPos(change.from, oldPrev, newPrev);\n      var to = offsetPos(changeEnd(change), oldPrev, newPrev);\n      oldPrev = change.to;\n      newPrev = to;\n      if (hint == \"around\") {\n        var range = doc.sel.ranges[i], inv = cmp(range.head, range.anchor) < 0;\n        out[i] = new Range(inv ? to : from, inv ? from : to);\n      } else {\n        out[i] = new Range(from, from);\n      }\n    }\n    return new Selection(out, doc.sel.primIndex);\n  }\n\n  // Allow \"beforeChange\" event handlers to influence a change\n  function filterChange(doc, change, update) {\n    var obj = {\n      canceled: false,\n      from: change.from,\n      to: change.to,\n      text: change.text,\n      origin: change.origin,\n      cancel: function() { this.canceled = true; }\n    };\n    if (update) obj.update = function(from, to, text, origin) {\n      if (from) this.from = clipPos(doc, from);\n      if (to) this.to = clipPos(doc, to);\n      if (text) this.text = text;\n      if (origin !== undefined) this.origin = origin;\n    };\n    signal(doc, \"beforeChange\", doc, obj);\n    if (doc.cm) signal(doc.cm, \"beforeChange\", doc.cm, obj);\n\n    if (obj.canceled) return null;\n    return {from: obj.from, to: obj.to, text: obj.text, origin: obj.origin};\n  }\n\n  // Apply a change to a document, and add it to the document's\n  // history, and propagating it to all linked documents.\n  function makeChange(doc, change, ignoreReadOnly) {\n    if (doc.cm) {\n      if (!doc.cm.curOp) return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly);\n      if (doc.cm.state.suppressEdits) return;\n    }\n\n    if (hasHandler(doc, \"beforeChange\") || doc.cm && hasHandler(doc.cm, \"beforeChange\")) {\n      change = filterChange(doc, change, true);\n      if (!change) return;\n    }\n\n    // Possibly split or suppress the update based on the presence\n    // of read-only spans in its range.\n    var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);\n    if (split) {\n      for (var i = split.length - 1; i >= 0; --i)\n        makeChangeInner(doc, {from: split[i].from, to: split[i].to, text: i ? [\"\"] : change.text});\n    } else {\n      makeChangeInner(doc, change);\n    }\n  }\n\n  function makeChangeInner(doc, change) {\n    if (change.text.length == 1 && change.text[0] == \"\" && cmp(change.from, change.to) == 0) return;\n    var selAfter = computeSelAfterChange(doc, change);\n    addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);\n\n    makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));\n    var rebased = [];\n\n    linkedDocs(doc, function(doc, sharedHist) {\n      if (!sharedHist && indexOf(rebased, doc.history) == -1) {\n        rebaseHist(doc.history, change);\n        rebased.push(doc.history);\n      }\n      makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change));\n    });\n  }\n\n  // Revert a change stored in a document's history.\n  function makeChangeFromHistory(doc, type, allowSelectionOnly) {\n    if (doc.cm && doc.cm.state.suppressEdits) return;\n\n    var hist = doc.history, event, selAfter = doc.sel;\n    var source = type == \"undo\" ? hist.done : hist.undone, dest = type == \"undo\" ? hist.undone : hist.done;\n\n    // Verify that there is a useable event (so that ctrl-z won't\n    // needlessly clear selection events)\n    for (var i = 0; i < source.length; i++) {\n      event = source[i];\n      if (allowSelectionOnly ? event.ranges && !event.equals(doc.sel) : !event.ranges)\n        break;\n    }\n    if (i == source.length) return;\n    hist.lastOrigin = hist.lastSelOrigin = null;\n\n    for (;;) {\n      event = source.pop();\n      if (event.ranges) {\n        pushSelectionToHistory(event, dest);\n        if (allowSelectionOnly && !event.equals(doc.sel)) {\n          setSelection(doc, event, {clearRedo: false});\n          return;\n        }\n        selAfter = event;\n      }\n      else break;\n    }\n\n    // Build up a reverse change object to add to the opposite history\n    // stack (redo when undoing, and vice versa).\n    var antiChanges = [];\n    pushSelectionToHistory(selAfter, dest);\n    dest.push({changes: antiChanges, generation: hist.generation});\n    hist.generation = event.generation || ++hist.maxGeneration;\n\n    var filter = hasHandler(doc, \"beforeChange\") || doc.cm && hasHandler(doc.cm, \"beforeChange\");\n\n    for (var i = event.changes.length - 1; i >= 0; --i) {\n      var change = event.changes[i];\n      change.origin = type;\n      if (filter && !filterChange(doc, change, false)) {\n        source.length = 0;\n        return;\n      }\n\n      antiChanges.push(historyChangeFromChange(doc, change));\n\n      var after = i ? computeSelAfterChange(doc, change) : lst(source);\n      makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));\n      if (!i && doc.cm) doc.cm.scrollIntoView({from: change.from, to: changeEnd(change)});\n      var rebased = [];\n\n      // Propagate to the linked documents\n      linkedDocs(doc, function(doc, sharedHist) {\n        if (!sharedHist && indexOf(rebased, doc.history) == -1) {\n          rebaseHist(doc.history, change);\n          rebased.push(doc.history);\n        }\n        makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change));\n      });\n    }\n  }\n\n  // Sub-views need their line numbers shifted when text is added\n  // above or below them in the parent document.\n  function shiftDoc(doc, distance) {\n    if (distance == 0) return;\n    doc.first += distance;\n    doc.sel = new Selection(map(doc.sel.ranges, function(range) {\n      return new Range(Pos(range.anchor.line + distance, range.anchor.ch),\n                       Pos(range.head.line + distance, range.head.ch));\n    }), doc.sel.primIndex);\n    if (doc.cm) {\n      regChange(doc.cm, doc.first, doc.first - distance, distance);\n      for (var d = doc.cm.display, l = d.viewFrom; l < d.viewTo; l++)\n        regLineChange(doc.cm, l, \"gutter\");\n    }\n  }\n\n  // More lower-level change function, handling only a single document\n  // (not linked ones).\n  function makeChangeSingleDoc(doc, change, selAfter, spans) {\n    if (doc.cm && !doc.cm.curOp)\n      return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans);\n\n    if (change.to.line < doc.first) {\n      shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));\n      return;\n    }\n    if (change.from.line > doc.lastLine()) return;\n\n    // Clip the change to the size of this doc\n    if (change.from.line < doc.first) {\n      var shift = change.text.length - 1 - (doc.first - change.from.line);\n      shiftDoc(doc, shift);\n      change = {from: Pos(doc.first, 0), to: Pos(change.to.line + shift, change.to.ch),\n                text: [lst(change.text)], origin: change.origin};\n    }\n    var last = doc.lastLine();\n    if (change.to.line > last) {\n      change = {from: change.from, to: Pos(last, getLine(doc, last).text.length),\n                text: [change.text[0]], origin: change.origin};\n    }\n\n    change.removed = getBetween(doc, change.from, change.to);\n\n    if (!selAfter) selAfter = computeSelAfterChange(doc, change);\n    if (doc.cm) makeChangeSingleDocInEditor(doc.cm, change, spans);\n    else updateDoc(doc, change, spans);\n    setSelectionNoUndo(doc, selAfter, sel_dontScroll);\n  }\n\n  // Handle the interaction of a change to a document with the editor\n  // that this document is part of.\n  function makeChangeSingleDocInEditor(cm, change, spans) {\n    var doc = cm.doc, display = cm.display, from = change.from, to = change.to;\n\n    var recomputeMaxLength = false, checkWidthStart = from.line;\n    if (!cm.options.lineWrapping) {\n      checkWidthStart = lineNo(visualLine(getLine(doc, from.line)));\n      doc.iter(checkWidthStart, to.line + 1, function(line) {\n        if (line == display.maxLine) {\n          recomputeMaxLength = true;\n          return true;\n        }\n      });\n    }\n\n    if (doc.sel.contains(change.from, change.to) > -1)\n      signalCursorActivity(cm);\n\n    updateDoc(doc, change, spans, estimateHeight(cm));\n\n    if (!cm.options.lineWrapping) {\n      doc.iter(checkWidthStart, from.line + change.text.length, function(line) {\n        var len = lineLength(line);\n        if (len > display.maxLineLength) {\n          display.maxLine = line;\n          display.maxLineLength = len;\n          display.maxLineChanged = true;\n          recomputeMaxLength = false;\n        }\n      });\n      if (recomputeMaxLength) cm.curOp.updateMaxLine = true;\n    }\n\n    // Adjust frontier, schedule worker\n    doc.frontier = Math.min(doc.frontier, from.line);\n    startWorker(cm, 400);\n\n    var lendiff = change.text.length - (to.line - from.line) - 1;\n    // Remember that these lines changed, for updating the display\n    if (from.line == to.line && change.text.length == 1 && !isWholeLineUpdate(cm.doc, change))\n      regLineChange(cm, from.line, \"text\");\n    else\n      regChange(cm, from.line, to.line + 1, lendiff);\n\n    var changesHandler = hasHandler(cm, \"changes\"), changeHandler = hasHandler(cm, \"change\");\n    if (changeHandler || changesHandler) {\n      var obj = {\n        from: from, to: to,\n        text: change.text,\n        removed: change.removed,\n        origin: change.origin\n      };\n      if (changeHandler) signalLater(cm, \"change\", cm, obj);\n      if (changesHandler) (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj);\n    }\n    cm.display.selForContextMenu = null;\n  }\n\n  function replaceRange(doc, code, from, to, origin) {\n    if (!to) to = from;\n    if (cmp(to, from) < 0) { var tmp = to; to = from; from = tmp; }\n    if (typeof code == \"string\") code = splitLines(code);\n    makeChange(doc, {from: from, to: to, text: code, origin: origin});\n  }\n\n  // SCROLLING THINGS INTO VIEW\n\n  // If an editor sits on the top or bottom of the window, partially\n  // scrolled out of view, this ensures that the cursor is visible.\n  function maybeScrollWindow(cm, coords) {\n    var display = cm.display, box = display.sizer.getBoundingClientRect(), doScroll = null;\n    if (coords.top + box.top < 0) doScroll = true;\n    else if (coords.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight)) doScroll = false;\n    if (doScroll != null && !phantom) {\n      var scrollNode = elt(\"div\", \"\\u200b\", null, \"position: absolute; top: \" +\n                           (coords.top - display.viewOffset - paddingTop(cm.display)) + \"px; height: \" +\n                           (coords.bottom - coords.top + scrollerCutOff) + \"px; left: \" +\n                           coords.left + \"px; width: 2px;\");\n      cm.display.lineSpace.appendChild(scrollNode);\n      scrollNode.scrollIntoView(doScroll);\n      cm.display.lineSpace.removeChild(scrollNode);\n    }\n  }\n\n  // Scroll a given position into view (immediately), verifying that\n  // it actually became visible (as line heights are accurately\n  // measured, the position of something may 'drift' during drawing).\n  function scrollPosIntoView(cm, pos, end, margin) {\n    if (margin == null) margin = 0;\n    for (var limit = 0; limit < 5; limit++) {\n      var changed = false, coords = cursorCoords(cm, pos);\n      var endCoords = !end || end == pos ? coords : cursorCoords(cm, end);\n      var scrollPos = calculateScrollPos(cm, Math.min(coords.left, endCoords.left),\n                                         Math.min(coords.top, endCoords.top) - margin,\n                                         Math.max(coords.left, endCoords.left),\n                                         Math.max(coords.bottom, endCoords.bottom) + margin);\n      var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;\n      if (scrollPos.scrollTop != null) {\n        setScrollTop(cm, scrollPos.scrollTop);\n        if (Math.abs(cm.doc.scrollTop - startTop) > 1) changed = true;\n      }\n      if (scrollPos.scrollLeft != null) {\n        setScrollLeft(cm, scrollPos.scrollLeft);\n        if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) changed = true;\n      }\n      if (!changed) return coords;\n    }\n  }\n\n  // Scroll a given set of coordinates into view (immediately).\n  function scrollIntoView(cm, x1, y1, x2, y2) {\n    var scrollPos = calculateScrollPos(cm, x1, y1, x2, y2);\n    if (scrollPos.scrollTop != null) setScrollTop(cm, scrollPos.scrollTop);\n    if (scrollPos.scrollLeft != null) setScrollLeft(cm, scrollPos.scrollLeft);\n  }\n\n  // Calculate a new scroll position needed to scroll the given\n  // rectangle into view. Returns an object with scrollTop and\n  // scrollLeft properties. When these are undefined, the\n  // vertical/horizontal position does not need to be adjusted.\n  function calculateScrollPos(cm, x1, y1, x2, y2) {\n    var display = cm.display, snapMargin = textHeight(cm.display);\n    if (y1 < 0) y1 = 0;\n    var screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop;\n    var screen = display.scroller.clientHeight - scrollerCutOff, result = {};\n    if (y2 - y1 > screen) y2 = y1 + screen;\n    var docBottom = cm.doc.height + paddingVert(display);\n    var atTop = y1 < snapMargin, atBottom = y2 > docBottom - snapMargin;\n    if (y1 < screentop) {\n      result.scrollTop = atTop ? 0 : y1;\n    } else if (y2 > screentop + screen) {\n      var newTop = Math.min(y1, (atBottom ? docBottom : y2) - screen);\n      if (newTop != screentop) result.scrollTop = newTop;\n    }\n\n    var screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft;\n    var screenw = display.scroller.clientWidth - scrollerCutOff - display.gutters.offsetWidth;\n    var tooWide = x2 - x1 > screenw;\n    if (tooWide) x2 = x1 + screenw;\n    if (x1 < 10)\n      result.scrollLeft = 0;\n    else if (x1 < screenleft)\n      result.scrollLeft = Math.max(0, x1 - (tooWide ? 0 : 10));\n    else if (x2 > screenw + screenleft - 3)\n      result.scrollLeft = x2 + (tooWide ? 0 : 10) - screenw;\n\n    return result;\n  }\n\n  // Store a relative adjustment to the scroll position in the current\n  // operation (to be applied when the operation finishes).\n  function addToScrollPos(cm, left, top) {\n    if (left != null || top != null) resolveScrollToPos(cm);\n    if (left != null)\n      cm.curOp.scrollLeft = (cm.curOp.scrollLeft == null ? cm.doc.scrollLeft : cm.curOp.scrollLeft) + left;\n    if (top != null)\n      cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top;\n  }\n\n  // Make sure that at the end of the operation the current cursor is\n  // shown.\n  function ensureCursorVisible(cm) {\n    resolveScrollToPos(cm);\n    var cur = cm.getCursor(), from = cur, to = cur;\n    if (!cm.options.lineWrapping) {\n      from = cur.ch ? Pos(cur.line, cur.ch - 1) : cur;\n      to = Pos(cur.line, cur.ch + 1);\n    }\n    cm.curOp.scrollToPos = {from: from, to: to, margin: cm.options.cursorScrollMargin, isCursor: true};\n  }\n\n  // When an operation has its scrollToPos property set, and another\n  // scroll action is applied before the end of the operation, this\n  // 'simulates' scrolling that position into view in a cheap way, so\n  // that the effect of intermediate scroll commands is not ignored.\n  function resolveScrollToPos(cm) {\n    var range = cm.curOp.scrollToPos;\n    if (range) {\n      cm.curOp.scrollToPos = null;\n      var from = estimateCoords(cm, range.from), to = estimateCoords(cm, range.to);\n      var sPos = calculateScrollPos(cm, Math.min(from.left, to.left),\n                                    Math.min(from.top, to.top) - range.margin,\n                                    Math.max(from.right, to.right),\n                                    Math.max(from.bottom, to.bottom) + range.margin);\n      cm.scrollTo(sPos.scrollLeft, sPos.scrollTop);\n    }\n  }\n\n  // API UTILITIES\n\n  // Indent the given line. The how parameter can be \"smart\",\n  // \"add\"/null, \"subtract\", or \"prev\". When aggressive is false\n  // (typically set to true for forced single-line indents), empty\n  // lines are not indented, and places where the mode returns Pass\n  // are left alone.\n  function indentLine(cm, n, how, aggressive) {\n    var doc = cm.doc, state;\n    if (how == null) how = \"add\";\n    if (how == \"smart\") {\n      // Fall back to \"prev\" when the mode doesn't have an indentation\n      // method.\n      if (!doc.mode.indent) how = \"prev\";\n      else state = getStateBefore(cm, n);\n    }\n\n    var tabSize = cm.options.tabSize;\n    var line = getLine(doc, n), curSpace = countColumn(line.text, null, tabSize);\n    if (line.stateAfter) line.stateAfter = null;\n    var curSpaceString = line.text.match(/^\\s*/)[0], indentation;\n    if (!aggressive && !/\\S/.test(line.text)) {\n      indentation = 0;\n      how = \"not\";\n    } else if (how == \"smart\") {\n      indentation = doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);\n      if (indentation == Pass || indentation > 150) {\n        if (!aggressive) return;\n        how = \"prev\";\n      }\n    }\n    if (how == \"prev\") {\n      if (n > doc.first) indentation = countColumn(getLine(doc, n-1).text, null, tabSize);\n      else indentation = 0;\n    } else if (how == \"add\") {\n      indentation = curSpace + cm.options.indentUnit;\n    } else if (how == \"subtract\") {\n      indentation = curSpace - cm.options.indentUnit;\n    } else if (typeof how == \"number\") {\n      indentation = curSpace + how;\n    }\n    indentation = Math.max(0, indentation);\n\n    var indentString = \"\", pos = 0;\n    if (cm.options.indentWithTabs)\n      for (var i = Math.floor(indentation / tabSize); i; --i) {pos += tabSize; indentString += \"\\t\";}\n    if (pos < indentation) indentString += spaceStr(indentation - pos);\n\n    if (indentString != curSpaceString) {\n      replaceRange(doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), \"+input\");\n    } else {\n      // Ensure that, if the cursor was in the whitespace at the start\n      // of the line, it is moved to the end of that space.\n      for (var i = 0; i < doc.sel.ranges.length; i++) {\n        var range = doc.sel.ranges[i];\n        if (range.head.line == n && range.head.ch < curSpaceString.length) {\n          var pos = Pos(n, curSpaceString.length);\n          replaceOneSelection(doc, i, new Range(pos, pos));\n          break;\n        }\n      }\n    }\n    line.stateAfter = null;\n  }\n\n  // Utility for applying a change to a line by handle or number,\n  // returning the number and optionally registering the line as\n  // changed.\n  function changeLine(doc, handle, changeType, op) {\n    var no = handle, line = handle;\n    if (typeof handle == \"number\") line = getLine(doc, clipLine(doc, handle));\n    else no = lineNo(handle);\n    if (no == null) return null;\n    if (op(line, no) && doc.cm) regLineChange(doc.cm, no, changeType);\n    return line;\n  }\n\n  // Helper for deleting text near the selection(s), used to implement\n  // backspace, delete, and similar functionality.\n  function deleteNearSelection(cm, compute) {\n    var ranges = cm.doc.sel.ranges, kill = [];\n    // Build up a set of ranges to kill first, merging overlapping\n    // ranges.\n    for (var i = 0; i < ranges.length; i++) {\n      var toKill = compute(ranges[i]);\n      while (kill.length && cmp(toKill.from, lst(kill).to) <= 0) {\n        var replaced = kill.pop();\n        if (cmp(replaced.from, toKill.from) < 0) {\n          toKill.from = replaced.from;\n          break;\n        }\n      }\n      kill.push(toKill);\n    }\n    // Next, remove those actual ranges.\n    runInOp(cm, function() {\n      for (var i = kill.length - 1; i >= 0; i--)\n        replaceRange(cm.doc, \"\", kill[i].from, kill[i].to, \"+delete\");\n      ensureCursorVisible(cm);\n    });\n  }\n\n  // Used for horizontal relative motion. Dir is -1 or 1 (left or\n  // right), unit can be \"char\", \"column\" (like char, but doesn't\n  // cross line boundaries), \"word\" (across next word), or \"group\" (to\n  // the start of next group of word or non-word-non-whitespace\n  // chars). The visually param controls whether, in right-to-left\n  // text, direction 1 means to move towards the next index in the\n  // string, or towards the character to the right of the current\n  // position. The resulting position will have a hitSide=true\n  // property if it reached the end of the document.\n  function findPosH(doc, pos, dir, unit, visually) {\n    var line = pos.line, ch = pos.ch, origDir = dir;\n    var lineObj = getLine(doc, line);\n    var possible = true;\n    function findNextLine() {\n      var l = line + dir;\n      if (l < doc.first || l >= doc.first + doc.size) return (possible = false);\n      line = l;\n      return lineObj = getLine(doc, l);\n    }\n    function moveOnce(boundToLine) {\n      var next = (visually ? moveVisually : moveLogically)(lineObj, ch, dir, true);\n      if (next == null) {\n        if (!boundToLine && findNextLine()) {\n          if (visually) ch = (dir < 0 ? lineRight : lineLeft)(lineObj);\n          else ch = dir < 0 ? lineObj.text.length : 0;\n        } else return (possible = false);\n      } else ch = next;\n      return true;\n    }\n\n    if (unit == \"char\") moveOnce();\n    else if (unit == \"column\") moveOnce(true);\n    else if (unit == \"word\" || unit == \"group\") {\n      var sawType = null, group = unit == \"group\";\n      var helper = doc.cm && doc.cm.getHelper(pos, \"wordChars\");\n      for (var first = true;; first = false) {\n        if (dir < 0 && !moveOnce(!first)) break;\n        var cur = lineObj.text.charAt(ch) || \"\\n\";\n        var type = isWordChar(cur, helper) ? \"w\"\n          : group && cur == \"\\n\" ? \"n\"\n          : !group || /\\s/.test(cur) ? null\n          : \"p\";\n        if (group && !first && !type) type = \"s\";\n        if (sawType && sawType != type) {\n          if (dir < 0) {dir = 1; moveOnce();}\n          break;\n        }\n\n        if (type) sawType = type;\n        if (dir > 0 && !moveOnce(!first)) break;\n      }\n    }\n    var result = skipAtomic(doc, Pos(line, ch), origDir, true);\n    if (!possible) result.hitSide = true;\n    return result;\n  }\n\n  // For relative vertical movement. Dir may be -1 or 1. Unit can be\n  // \"page\" or \"line\". The resulting position will have a hitSide=true\n  // property if it reached the end of the document.\n  function findPosV(cm, pos, dir, unit) {\n    var doc = cm.doc, x = pos.left, y;\n    if (unit == \"page\") {\n      var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);\n      y = pos.top + dir * (pageSize - (dir < 0 ? 1.5 : .5) * textHeight(cm.display));\n    } else if (unit == \"line\") {\n      y = dir > 0 ? pos.bottom + 3 : pos.top - 3;\n    }\n    for (;;) {\n      var target = coordsChar(cm, x, y);\n      if (!target.outside) break;\n      if (dir < 0 ? y <= 0 : y >= doc.height) { target.hitSide = true; break; }\n      y += dir * 5;\n    }\n    return target;\n  }\n\n  // EDITOR METHODS\n\n  // The publicly visible API. Note that methodOp(f) means\n  // 'wrap f in an operation, performed on its `this` parameter'.\n\n  // This is not the complete set of editor methods. Most of the\n  // methods defined on the Doc type are also injected into\n  // CodeMirror.prototype, for backwards compatibility and\n  // convenience.\n\n  CodeMirror.prototype = {\n    constructor: CodeMirror,\n    focus: function(){window.focus(); focusInput(this); fastPoll(this);},\n\n    setOption: function(option, value) {\n      var options = this.options, old = options[option];\n      if (options[option] == value && option != \"mode\") return;\n      options[option] = value;\n      if (optionHandlers.hasOwnProperty(option))\n        operation(this, optionHandlers[option])(this, value, old);\n    },\n\n    getOption: function(option) {return this.options[option];},\n    getDoc: function() {return this.doc;},\n\n    addKeyMap: function(map, bottom) {\n      this.state.keyMaps[bottom ? \"push\" : \"unshift\"](map);\n    },\n    removeKeyMap: function(map) {\n      var maps = this.state.keyMaps;\n      for (var i = 0; i < maps.length; ++i)\n        if (maps[i] == map || (typeof maps[i] != \"string\" && maps[i].name == map)) {\n          maps.splice(i, 1);\n          return true;\n        }\n    },\n\n    addOverlay: methodOp(function(spec, options) {\n      var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);\n      if (mode.startState) throw new Error(\"Overlays may not be stateful.\");\n      this.state.overlays.push({mode: mode, modeSpec: spec, opaque: options && options.opaque});\n      this.state.modeGen++;\n      regChange(this);\n    }),\n    removeOverlay: methodOp(function(spec) {\n      var overlays = this.state.overlays;\n      for (var i = 0; i < overlays.length; ++i) {\n        var cur = overlays[i].modeSpec;\n        if (cur == spec || typeof spec == \"string\" && cur.name == spec) {\n          overlays.splice(i, 1);\n          this.state.modeGen++;\n          regChange(this);\n          return;\n        }\n      }\n    }),\n\n    indentLine: methodOp(function(n, dir, aggressive) {\n      if (typeof dir != \"string\" && typeof dir != \"number\") {\n        if (dir == null) dir = this.options.smartIndent ? \"smart\" : \"prev\";\n        else dir = dir ? \"add\" : \"subtract\";\n      }\n      if (isLine(this.doc, n)) indentLine(this, n, dir, aggressive);\n    }),\n    indentSelection: methodOp(function(how) {\n      var ranges = this.doc.sel.ranges, end = -1;\n      for (var i = 0; i < ranges.length; i++) {\n        var range = ranges[i];\n        if (!range.empty()) {\n          var from = range.from(), to = range.to();\n          var start = Math.max(end, from.line);\n          end = Math.min(this.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;\n          for (var j = start; j < end; ++j)\n            indentLine(this, j, how);\n          var newRanges = this.doc.sel.ranges;\n          if (from.ch == 0 && ranges.length == newRanges.length && newRanges[i].from().ch > 0)\n            replaceOneSelection(this.doc, i, new Range(from, newRanges[i].to()), sel_dontScroll);\n        } else if (range.head.line > end) {\n          indentLine(this, range.head.line, how, true);\n          end = range.head.line;\n          if (i == this.doc.sel.primIndex) ensureCursorVisible(this);\n        }\n      }\n    }),\n\n    // Fetch the parser token for a given character. Useful for hacks\n    // that want to inspect the mode state (say, for completion).\n    getTokenAt: function(pos, precise) {\n      var doc = this.doc;\n      pos = clipPos(doc, pos);\n      var state = getStateBefore(this, pos.line, precise), mode = this.doc.mode;\n      var line = getLine(doc, pos.line);\n      var stream = new StringStream(line.text, this.options.tabSize);\n      while (stream.pos < pos.ch && !stream.eol()) {\n        stream.start = stream.pos;\n        var style = readToken(mode, stream, state);\n      }\n      return {start: stream.start,\n              end: stream.pos,\n              string: stream.current(),\n              type: style || null,\n              state: state};\n    },\n\n    getTokenTypeAt: function(pos) {\n      pos = clipPos(this.doc, pos);\n      var styles = getLineStyles(this, getLine(this.doc, pos.line));\n      var before = 0, after = (styles.length - 1) / 2, ch = pos.ch;\n      var type;\n      if (ch == 0) type = styles[2];\n      else for (;;) {\n        var mid = (before + after) >> 1;\n        if ((mid ? styles[mid * 2 - 1] : 0) >= ch) after = mid;\n        else if (styles[mid * 2 + 1] < ch) before = mid + 1;\n        else { type = styles[mid * 2 + 2]; break; }\n      }\n      var cut = type ? type.indexOf(\"cm-overlay \") : -1;\n      return cut < 0 ? type : cut == 0 ? null : type.slice(0, cut - 1);\n    },\n\n    getModeAt: function(pos) {\n      var mode = this.doc.mode;\n      if (!mode.innerMode) return mode;\n      return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode;\n    },\n\n    getHelper: function(pos, type) {\n      return this.getHelpers(pos, type)[0];\n    },\n\n    getHelpers: function(pos, type) {\n      var found = [];\n      if (!helpers.hasOwnProperty(type)) return helpers;\n      var help = helpers[type], mode = this.getModeAt(pos);\n      if (typeof mode[type] == \"string\") {\n        if (help[mode[type]]) found.push(help[mode[type]]);\n      } else if (mode[type]) {\n        for (var i = 0; i < mode[type].length; i++) {\n          var val = help[mode[type][i]];\n          if (val) found.push(val);\n        }\n      } else if (mode.helperType && help[mode.helperType]) {\n        found.push(help[mode.helperType]);\n      } else if (help[mode.name]) {\n        found.push(help[mode.name]);\n      }\n      for (var i = 0; i < help._global.length; i++) {\n        var cur = help._global[i];\n        if (cur.pred(mode, this) && indexOf(found, cur.val) == -1)\n          found.push(cur.val);\n      }\n      return found;\n    },\n\n    getStateAfter: function(line, precise) {\n      var doc = this.doc;\n      line = clipLine(doc, line == null ? doc.first + doc.size - 1: line);\n      return getStateBefore(this, line + 1, precise);\n    },\n\n    cursorCoords: function(start, mode) {\n      var pos, range = this.doc.sel.primary();\n      if (start == null) pos = range.head;\n      else if (typeof start == \"object\") pos = clipPos(this.doc, start);\n      else pos = start ? range.from() : range.to();\n      return cursorCoords(this, pos, mode || \"page\");\n    },\n\n    charCoords: function(pos, mode) {\n      return charCoords(this, clipPos(this.doc, pos), mode || \"page\");\n    },\n\n    coordsChar: function(coords, mode) {\n      coords = fromCoordSystem(this, coords, mode || \"page\");\n      return coordsChar(this, coords.left, coords.top);\n    },\n\n    lineAtHeight: function(height, mode) {\n      height = fromCoordSystem(this, {top: height, left: 0}, mode || \"page\").top;\n      return lineAtHeight(this.doc, height + this.display.viewOffset);\n    },\n    heightAtLine: function(line, mode) {\n      var end = false, last = this.doc.first + this.doc.size - 1;\n      if (line < this.doc.first) line = this.doc.first;\n      else if (line > last) { line = last; end = true; }\n      var lineObj = getLine(this.doc, line);\n      return intoCoordSystem(this, lineObj, {top: 0, left: 0}, mode || \"page\").top +\n        (end ? this.doc.height - heightAtLine(lineObj) : 0);\n    },\n\n    defaultTextHeight: function() { return textHeight(this.display); },\n    defaultCharWidth: function() { return charWidth(this.display); },\n\n    setGutterMarker: methodOp(function(line, gutterID, value) {\n      return changeLine(this.doc, line, \"gutter\", function(line) {\n        var markers = line.gutterMarkers || (line.gutterMarkers = {});\n        markers[gutterID] = value;\n        if (!value && isEmpty(markers)) line.gutterMarkers = null;\n        return true;\n      });\n    }),\n\n    clearGutter: methodOp(function(gutterID) {\n      var cm = this, doc = cm.doc, i = doc.first;\n      doc.iter(function(line) {\n        if (line.gutterMarkers && line.gutterMarkers[gutterID]) {\n          line.gutterMarkers[gutterID] = null;\n          regLineChange(cm, i, \"gutter\");\n          if (isEmpty(line.gutterMarkers)) line.gutterMarkers = null;\n        }\n        ++i;\n      });\n    }),\n\n    addLineWidget: methodOp(function(handle, node, options) {\n      return addLineWidget(this, handle, node, options);\n    }),\n\n    removeLineWidget: function(widget) { widget.clear(); },\n\n    lineInfo: function(line) {\n      if (typeof line == \"number\") {\n        if (!isLine(this.doc, line)) return null;\n        var n = line;\n        line = getLine(this.doc, line);\n        if (!line) return null;\n      } else {\n        var n = lineNo(line);\n        if (n == null) return null;\n      }\n      return {line: n, handle: line, text: line.text, gutterMarkers: line.gutterMarkers,\n              textClass: line.textClass, bgClass: line.bgClass, wrapClass: line.wrapClass,\n              widgets: line.widgets};\n    },\n\n    getViewport: function() { return {from: this.display.viewFrom, to: this.display.viewTo};},\n\n    addWidget: function(pos, node, scroll, vert, horiz) {\n      var display = this.display;\n      pos = cursorCoords(this, clipPos(this.doc, pos));\n      var top = pos.bottom, left = pos.left;\n      node.style.position = \"absolute\";\n      display.sizer.appendChild(node);\n      if (vert == \"over\") {\n        top = pos.top;\n      } else if (vert == \"above\" || vert == \"near\") {\n        var vspace = Math.max(display.wrapper.clientHeight, this.doc.height),\n        hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);\n        // Default to positioning above (if specified and possible); otherwise default to positioning below\n        if ((vert == 'above' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight)\n          top = pos.top - node.offsetHeight;\n        else if (pos.bottom + node.offsetHeight <= vspace)\n          top = pos.bottom;\n        if (left + node.offsetWidth > hspace)\n          left = hspace - node.offsetWidth;\n      }\n      node.style.top = top + \"px\";\n      node.style.left = node.style.right = \"\";\n      if (horiz == \"right\") {\n        left = display.sizer.clientWidth - node.offsetWidth;\n        node.style.right = \"0px\";\n      } else {\n        if (horiz == \"left\") left = 0;\n        else if (horiz == \"middle\") left = (display.sizer.clientWidth - node.offsetWidth) / 2;\n        node.style.left = left + \"px\";\n      }\n      if (scroll)\n        scrollIntoView(this, left, top, left + node.offsetWidth, top + node.offsetHeight);\n    },\n\n    triggerOnKeyDown: methodOp(onKeyDown),\n    triggerOnKeyPress: methodOp(onKeyPress),\n    triggerOnKeyUp: onKeyUp,\n\n    execCommand: function(cmd) {\n      if (commands.hasOwnProperty(cmd))\n        return commands[cmd](this);\n    },\n\n    findPosH: function(from, amount, unit, visually) {\n      var dir = 1;\n      if (amount < 0) { dir = -1; amount = -amount; }\n      for (var i = 0, cur = clipPos(this.doc, from); i < amount; ++i) {\n        cur = findPosH(this.doc, cur, dir, unit, visually);\n        if (cur.hitSide) break;\n      }\n      return cur;\n    },\n\n    moveH: methodOp(function(dir, unit) {\n      var cm = this;\n      cm.extendSelectionsBy(function(range) {\n        if (cm.display.shift || cm.doc.extend || range.empty())\n          return findPosH(cm.doc, range.head, dir, unit, cm.options.rtlMoveVisually);\n        else\n          return dir < 0 ? range.from() : range.to();\n      }, sel_move);\n    }),\n\n    deleteH: methodOp(function(dir, unit) {\n      var sel = this.doc.sel, doc = this.doc;\n      if (sel.somethingSelected())\n        doc.replaceSelection(\"\", null, \"+delete\");\n      else\n        deleteNearSelection(this, function(range) {\n          var other = findPosH(doc, range.head, dir, unit, false);\n          return dir < 0 ? {from: other, to: range.head} : {from: range.head, to: other};\n        });\n    }),\n\n    findPosV: function(from, amount, unit, goalColumn) {\n      var dir = 1, x = goalColumn;\n      if (amount < 0) { dir = -1; amount = -amount; }\n      for (var i = 0, cur = clipPos(this.doc, from); i < amount; ++i) {\n        var coords = cursorCoords(this, cur, \"div\");\n        if (x == null) x = coords.left;\n        else coords.left = x;\n        cur = findPosV(this, coords, dir, unit);\n        if (cur.hitSide) break;\n      }\n      return cur;\n    },\n\n    moveV: methodOp(function(dir, unit) {\n      var cm = this, doc = this.doc, goals = [];\n      var collapse = !cm.display.shift && !doc.extend && doc.sel.somethingSelected();\n      doc.extendSelectionsBy(function(range) {\n        if (collapse)\n          return dir < 0 ? range.from() : range.to();\n        var headPos = cursorCoords(cm, range.head, \"div\");\n        if (range.goalColumn != null) headPos.left = range.goalColumn;\n        goals.push(headPos.left);\n        var pos = findPosV(cm, headPos, dir, unit);\n        if (unit == \"page\" && range == doc.sel.primary())\n          addToScrollPos(cm, null, charCoords(cm, pos, \"div\").top - headPos.top);\n        return pos;\n      }, sel_move);\n      if (goals.length) for (var i = 0; i < doc.sel.ranges.length; i++)\n        doc.sel.ranges[i].goalColumn = goals[i];\n    }),\n\n    // Find the word at the given position (as returned by coordsChar).\n    findWordAt: function(pos) {\n      var doc = this.doc, line = getLine(doc, pos.line).text;\n      var start = pos.ch, end = pos.ch;\n      if (line) {\n        var helper = this.getHelper(pos, \"wordChars\");\n        if ((pos.xRel < 0 || end == line.length) && start) --start; else ++end;\n        var startChar = line.charAt(start);\n        var check = isWordChar(startChar, helper)\n          ? function(ch) { return isWordChar(ch, helper); }\n          : /\\s/.test(startChar) ? function(ch) {return /\\s/.test(ch);}\n          : function(ch) {return !/\\s/.test(ch) && !isWordChar(ch);};\n        while (start > 0 && check(line.charAt(start - 1))) --start;\n        while (end < line.length && check(line.charAt(end))) ++end;\n      }\n      return new Range(Pos(pos.line, start), Pos(pos.line, end));\n    },\n\n    toggleOverwrite: function(value) {\n      if (value != null && value == this.state.overwrite) return;\n      if (this.state.overwrite = !this.state.overwrite)\n        addClass(this.display.cursorDiv, \"CodeMirror-overwrite\");\n      else\n        rmClass(this.display.cursorDiv, \"CodeMirror-overwrite\");\n\n      signal(this, \"overwriteToggle\", this, this.state.overwrite);\n    },\n    hasFocus: function() { return activeElt() == this.display.input; },\n\n    scrollTo: methodOp(function(x, y) {\n      if (x != null || y != null) resolveScrollToPos(this);\n      if (x != null) this.curOp.scrollLeft = x;\n      if (y != null) this.curOp.scrollTop = y;\n    }),\n    getScrollInfo: function() {\n      var scroller = this.display.scroller, co = scrollerCutOff;\n      return {left: scroller.scrollLeft, top: scroller.scrollTop,\n              height: scroller.scrollHeight - co, width: scroller.scrollWidth - co,\n              clientHeight: scroller.clientHeight - co, clientWidth: scroller.clientWidth - co};\n    },\n\n    scrollIntoView: methodOp(function(range, margin) {\n      if (range == null) {\n        range = {from: this.doc.sel.primary().head, to: null};\n        if (margin == null) margin = this.options.cursorScrollMargin;\n      } else if (typeof range == \"number\") {\n        range = {from: Pos(range, 0), to: null};\n      } else if (range.from == null) {\n        range = {from: range, to: null};\n      }\n      if (!range.to) range.to = range.from;\n      range.margin = margin || 0;\n\n      if (range.from.line != null) {\n        resolveScrollToPos(this);\n        this.curOp.scrollToPos = range;\n      } else {\n        var sPos = calculateScrollPos(this, Math.min(range.from.left, range.to.left),\n                                      Math.min(range.from.top, range.to.top) - range.margin,\n                                      Math.max(range.from.right, range.to.right),\n                                      Math.max(range.from.bottom, range.to.bottom) + range.margin);\n        this.scrollTo(sPos.scrollLeft, sPos.scrollTop);\n      }\n    }),\n\n    setSize: methodOp(function(width, height) {\n      var cm = this;\n      function interpret(val) {\n        return typeof val == \"number\" || /^\\d+$/.test(String(val)) ? val + \"px\" : val;\n      }\n      if (width != null) cm.display.wrapper.style.width = interpret(width);\n      if (height != null) cm.display.wrapper.style.height = interpret(height);\n      if (cm.options.lineWrapping) clearLineMeasurementCache(this);\n      var lineNo = cm.display.viewFrom;\n      cm.doc.iter(lineNo, cm.display.viewTo, function(line) {\n        if (line.widgets) for (var i = 0; i < line.widgets.length; i++)\n          if (line.widgets[i].noHScroll) { regLineChange(cm, lineNo, \"widget\"); break; }\n        ++lineNo;\n      });\n      cm.curOp.forceUpdate = true;\n      signal(cm, \"refresh\", this);\n    }),\n\n    operation: function(f){return runInOp(this, f);},\n\n    refresh: methodOp(function() {\n      var oldHeight = this.display.cachedTextHeight;\n      regChange(this);\n      this.curOp.forceUpdate = true;\n      clearCaches(this);\n      this.scrollTo(this.doc.scrollLeft, this.doc.scrollTop);\n      updateGutterSpace(this);\n      if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) > .5)\n        estimateLineHeights(this);\n      signal(this, \"refresh\", this);\n    }),\n\n    swapDoc: methodOp(function(doc) {\n      var old = this.doc;\n      old.cm = null;\n      attachDoc(this, doc);\n      clearCaches(this);\n      resetInput(this);\n      this.scrollTo(doc.scrollLeft, doc.scrollTop);\n      this.curOp.forceScroll = true;\n      signalLater(this, \"swapDoc\", this, old);\n      return old;\n    }),\n\n    getInputField: function(){return this.display.input;},\n    getWrapperElement: function(){return this.display.wrapper;},\n    getScrollerElement: function(){return this.display.scroller;},\n    getGutterElement: function(){return this.display.gutters;}\n  };\n  eventMixin(CodeMirror);\n\n  // OPTION DEFAULTS\n\n  // The default configuration options.\n  var defaults = CodeMirror.defaults = {};\n  // Functions to run when options are changed.\n  var optionHandlers = CodeMirror.optionHandlers = {};\n\n  function option(name, deflt, handle, notOnInit) {\n    CodeMirror.defaults[name] = deflt;\n    if (handle) optionHandlers[name] =\n      notOnInit ? function(cm, val, old) {if (old != Init) handle(cm, val, old);} : handle;\n  }\n\n  // Passed to option handlers when there is no old value.\n  var Init = CodeMirror.Init = {toString: function(){return \"CodeMirror.Init\";}};\n\n  // These two are, on init, called from the constructor because they\n  // have to be initialized before the editor can start at all.\n  option(\"value\", \"\", function(cm, val) {\n    cm.setValue(val);\n  }, true);\n  option(\"mode\", null, function(cm, val) {\n    cm.doc.modeOption = val;\n    loadMode(cm);\n  }, true);\n\n  option(\"indentUnit\", 2, loadMode, true);\n  option(\"indentWithTabs\", false);\n  option(\"smartIndent\", true);\n  option(\"tabSize\", 4, function(cm) {\n    resetModeState(cm);\n    clearCaches(cm);\n    regChange(cm);\n  }, true);\n  option(\"specialChars\", /[\\t\\u0000-\\u0019\\u00ad\\u200b-\\u200f\\u2028\\u2029\\ufeff]/g, function(cm, val) {\n    cm.options.specialChars = new RegExp(val.source + (val.test(\"\\t\") ? \"\" : \"|\\t\"), \"g\");\n    cm.refresh();\n  }, true);\n  option(\"specialCharPlaceholder\", defaultSpecialCharPlaceholder, function(cm) {cm.refresh();}, true);\n  option(\"electricChars\", true);\n  option(\"rtlMoveVisually\", !windows);\n  option(\"wholeLineUpdateBefore\", true);\n\n  option(\"theme\", \"default\", function(cm) {\n    themeChanged(cm);\n    guttersChanged(cm);\n  }, true);\n  option(\"keyMap\", \"default\", keyMapChanged);\n  option(\"extraKeys\", null);\n\n  option(\"lineWrapping\", false, wrappingChanged, true);\n  option(\"gutters\", [], function(cm) {\n    setGuttersForLineNumbers(cm.options);\n    guttersChanged(cm);\n  }, true);\n  option(\"fixedGutter\", true, function(cm, val) {\n    cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + \"px\" : \"0\";\n    cm.refresh();\n  }, true);\n  option(\"coverGutterNextToScrollbar\", false, updateScrollbars, true);\n  option(\"lineNumbers\", false, function(cm) {\n    setGuttersForLineNumbers(cm.options);\n    guttersChanged(cm);\n  }, true);\n  option(\"firstLineNumber\", 1, guttersChanged, true);\n  option(\"lineNumberFormatter\", function(integer) {return integer;}, guttersChanged, true);\n  option(\"showCursorWhenSelecting\", false, updateSelection, true);\n\n  option(\"resetSelectionOnContextMenu\", true);\n\n  option(\"readOnly\", false, function(cm, val) {\n    if (val == \"nocursor\") {\n      onBlur(cm);\n      cm.display.input.blur();\n      cm.display.disabled = true;\n    } else {\n      cm.display.disabled = false;\n      if (!val) resetInput(cm);\n    }\n  });\n  option(\"disableInput\", false, function(cm, val) {if (!val) resetInput(cm);}, true);\n  option(\"dragDrop\", true);\n\n  option(\"cursorBlinkRate\", 530);\n  option(\"cursorScrollMargin\", 0);\n  option(\"cursorHeight\", 1, updateSelection, true);\n  option(\"singleCursorHeightPerLine\", true, updateSelection, true);\n  option(\"workTime\", 100);\n  option(\"workDelay\", 100);\n  option(\"flattenSpans\", true, resetModeState, true);\n  option(\"addModeClass\", false, resetModeState, true);\n  option(\"pollInterval\", 100);\n  option(\"undoDepth\", 200, function(cm, val){cm.doc.history.undoDepth = val;});\n  option(\"historyEventDelay\", 1250);\n  option(\"viewportMargin\", 10, function(cm){cm.refresh();}, true);\n  option(\"maxHighlightLength\", 10000, resetModeState, true);\n  option(\"moveInputWithCursor\", true, function(cm, val) {\n    if (!val) cm.display.inputDiv.style.top = cm.display.inputDiv.style.left = 0;\n  });\n\n  option(\"tabindex\", null, function(cm, val) {\n    cm.display.input.tabIndex = val || \"\";\n  });\n  option(\"autofocus\", null);\n\n  // MODE DEFINITION AND QUERYING\n\n  // Known modes, by name and by MIME\n  var modes = CodeMirror.modes = {}, mimeModes = CodeMirror.mimeModes = {};\n\n  // Extra arguments are stored as the mode's dependencies, which is\n  // used by (legacy) mechanisms like loadmode.js to automatically\n  // load a mode. (Preferred mechanism is the require/define calls.)\n  CodeMirror.defineMode = function(name, mode) {\n    if (!CodeMirror.defaults.mode && name != \"null\") CodeMirror.defaults.mode = name;\n    if (arguments.length > 2)\n      mode.dependencies = Array.prototype.slice.call(arguments, 2);\n    modes[name] = mode;\n  };\n\n  CodeMirror.defineMIME = function(mime, spec) {\n    mimeModes[mime] = spec;\n  };\n\n  // Given a MIME type, a {name, ...options} config object, or a name\n  // string, return a mode config object.\n  CodeMirror.resolveMode = function(spec) {\n    if (typeof spec == \"string\" && mimeModes.hasOwnProperty(spec)) {\n      spec = mimeModes[spec];\n    } else if (spec && typeof spec.name == \"string\" && mimeModes.hasOwnProperty(spec.name)) {\n      var found = mimeModes[spec.name];\n      if (typeof found == \"string\") found = {name: found};\n      spec = createObj(found, spec);\n      spec.name = found.name;\n    } else if (typeof spec == \"string\" && /^[\\w\\-]+\\/[\\w\\-]+\\+xml$/.test(spec)) {\n      return CodeMirror.resolveMode(\"application/xml\");\n    }\n    if (typeof spec == \"string\") return {name: spec};\n    else return spec || {name: \"null\"};\n  };\n\n  // Given a mode spec (anything that resolveMode accepts), find and\n  // initialize an actual mode object.\n  CodeMirror.getMode = function(options, spec) {\n    var spec = CodeMirror.resolveMode(spec);\n    var mfactory = modes[spec.name];\n    if (!mfactory) return CodeMirror.getMode(options, \"text/plain\");\n    var modeObj = mfactory(options, spec);\n    if (modeExtensions.hasOwnProperty(spec.name)) {\n      var exts = modeExtensions[spec.name];\n      for (var prop in exts) {\n        if (!exts.hasOwnProperty(prop)) continue;\n        if (modeObj.hasOwnProperty(prop)) modeObj[\"_\" + prop] = modeObj[prop];\n        modeObj[prop] = exts[prop];\n      }\n    }\n    modeObj.name = spec.name;\n    if (spec.helperType) modeObj.helperType = spec.helperType;\n    if (spec.modeProps) for (var prop in spec.modeProps)\n      modeObj[prop] = spec.modeProps[prop];\n\n    return modeObj;\n  };\n\n  // Minimal default mode.\n  CodeMirror.defineMode(\"null\", function() {\n    return {token: function(stream) {stream.skipToEnd();}};\n  });\n  CodeMirror.defineMIME(\"text/plain\", \"null\");\n\n  // This can be used to attach properties to mode objects from\n  // outside the actual mode definition.\n  var modeExtensions = CodeMirror.modeExtensions = {};\n  CodeMirror.extendMode = function(mode, properties) {\n    var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : (modeExtensions[mode] = {});\n    copyObj(properties, exts);\n  };\n\n  // EXTENSIONS\n\n  CodeMirror.defineExtension = function(name, func) {\n    CodeMirror.prototype[name] = func;\n  };\n  CodeMirror.defineDocExtension = function(name, func) {\n    Doc.prototype[name] = func;\n  };\n  CodeMirror.defineOption = option;\n\n  var initHooks = [];\n  CodeMirror.defineInitHook = function(f) {initHooks.push(f);};\n\n  var helpers = CodeMirror.helpers = {};\n  CodeMirror.registerHelper = function(type, name, value) {\n    if (!helpers.hasOwnProperty(type)) helpers[type] = CodeMirror[type] = {_global: []};\n    helpers[type][name] = value;\n  };\n  CodeMirror.registerGlobalHelper = function(type, name, predicate, value) {\n    CodeMirror.registerHelper(type, name, value);\n    helpers[type]._global.push({pred: predicate, val: value});\n  };\n\n  // MODE STATE HANDLING\n\n  // Utility functions for working with state. Exported because nested\n  // modes need to do this for their inner modes.\n\n  var copyState = CodeMirror.copyState = function(mode, state) {\n    if (state === true) return state;\n    if (mode.copyState) return mode.copyState(state);\n    var nstate = {};\n    for (var n in state) {\n      var val = state[n];\n      if (val instanceof Array) val = val.concat([]);\n      nstate[n] = val;\n    }\n    return nstate;\n  };\n\n  var startState = CodeMirror.startState = function(mode, a1, a2) {\n    return mode.startState ? mode.startState(a1, a2) : true;\n  };\n\n  // Given a mode and a state (for that mode), find the inner mode and\n  // state at the position that the state refers to.\n  CodeMirror.innerMode = function(mode, state) {\n    while (mode.innerMode) {\n      var info = mode.innerMode(state);\n      if (!info || info.mode == mode) break;\n      state = info.state;\n      mode = info.mode;\n    }\n    return info || {mode: mode, state: state};\n  };\n\n  // STANDARD COMMANDS\n\n  // Commands are parameter-less actions that can be performed on an\n  // editor, mostly used for keybindings.\n  var commands = CodeMirror.commands = {\n    selectAll: function(cm) {cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll);},\n    singleSelection: function(cm) {\n      cm.setSelection(cm.getCursor(\"anchor\"), cm.getCursor(\"head\"), sel_dontScroll);\n    },\n    killLine: function(cm) {\n      deleteNearSelection(cm, function(range) {\n        if (range.empty()) {\n          var len = getLine(cm.doc, range.head.line).text.length;\n          if (range.head.ch == len && range.head.line < cm.lastLine())\n            return {from: range.head, to: Pos(range.head.line + 1, 0)};\n          else\n            return {from: range.head, to: Pos(range.head.line, len)};\n        } else {\n          return {from: range.from(), to: range.to()};\n        }\n      });\n    },\n    deleteLine: function(cm) {\n      deleteNearSelection(cm, function(range) {\n        return {from: Pos(range.from().line, 0),\n                to: clipPos(cm.doc, Pos(range.to().line + 1, 0))};\n      });\n    },\n    delLineLeft: function(cm) {\n      deleteNearSelection(cm, function(range) {\n        return {from: Pos(range.from().line, 0), to: range.from()};\n      });\n    },\n    delWrappedLineLeft: function(cm) {\n      deleteNearSelection(cm, function(range) {\n        var top = cm.charCoords(range.head, \"div\").top + 5;\n        var leftPos = cm.coordsChar({left: 0, top: top}, \"div\");\n        return {from: leftPos, to: range.from()};\n      });\n    },\n    delWrappedLineRight: function(cm) {\n      deleteNearSelection(cm, function(range) {\n        var top = cm.charCoords(range.head, \"div\").top + 5;\n        var rightPos = cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, \"div\");\n        return {from: range.from(), to: rightPos };\n      });\n    },\n    undo: function(cm) {cm.undo();},\n    redo: function(cm) {cm.redo();},\n    undoSelection: function(cm) {cm.undoSelection();},\n    redoSelection: function(cm) {cm.redoSelection();},\n    goDocStart: function(cm) {cm.extendSelection(Pos(cm.firstLine(), 0));},\n    goDocEnd: function(cm) {cm.extendSelection(Pos(cm.lastLine()));},\n    goLineStart: function(cm) {\n      cm.extendSelectionsBy(function(range) { return lineStart(cm, range.head.line); },\n                            {origin: \"+move\", bias: 1});\n    },\n    goLineStartSmart: function(cm) {\n      cm.extendSelectionsBy(function(range) {\n        return lineStartSmart(cm, range.head);\n      }, {origin: \"+move\", bias: 1});\n    },\n    goLineEnd: function(cm) {\n      cm.extendSelectionsBy(function(range) { return lineEnd(cm, range.head.line); },\n                            {origin: \"+move\", bias: -1});\n    },\n    goLineRight: function(cm) {\n      cm.extendSelectionsBy(function(range) {\n        var top = cm.charCoords(range.head, \"div\").top + 5;\n        return cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, \"div\");\n      }, sel_move);\n    },\n    goLineLeft: function(cm) {\n      cm.extendSelectionsBy(function(range) {\n        var top = cm.charCoords(range.head, \"div\").top + 5;\n        return cm.coordsChar({left: 0, top: top}, \"div\");\n      }, sel_move);\n    },\n    goLineLeftSmart: function(cm) {\n      cm.extendSelectionsBy(function(range) {\n        var top = cm.charCoords(range.head, \"div\").top + 5;\n        var pos = cm.coordsChar({left: 0, top: top}, \"div\");\n        if (pos.ch < cm.getLine(pos.line).search(/\\S/)) return lineStartSmart(cm, range.head);\n        return pos;\n      }, sel_move);\n    },\n    goLineUp: function(cm) {cm.moveV(-1, \"line\");},\n    goLineDown: function(cm) {cm.moveV(1, \"line\");},\n    goPageUp: function(cm) {cm.moveV(-1, \"page\");},\n    goPageDown: function(cm) {cm.moveV(1, \"page\");},\n    goCharLeft: function(cm) {cm.moveH(-1, \"char\");},\n    goCharRight: function(cm) {cm.moveH(1, \"char\");},\n    goColumnLeft: function(cm) {cm.moveH(-1, \"column\");},\n    goColumnRight: function(cm) {cm.moveH(1, \"column\");},\n    goWordLeft: function(cm) {cm.moveH(-1, \"word\");},\n    goGroupRight: function(cm) {cm.moveH(1, \"group\");},\n    goGroupLeft: function(cm) {cm.moveH(-1, \"group\");},\n    goWordRight: function(cm) {cm.moveH(1, \"word\");},\n    delCharBefore: function(cm) {cm.deleteH(-1, \"char\");},\n    delCharAfter: function(cm) {cm.deleteH(1, \"char\");},\n    delWordBefore: function(cm) {cm.deleteH(-1, \"word\");},\n    delWordAfter: function(cm) {cm.deleteH(1, \"word\");},\n    delGroupBefore: function(cm) {cm.deleteH(-1, \"group\");},\n    delGroupAfter: function(cm) {cm.deleteH(1, \"group\");},\n    indentAuto: function(cm) {cm.indentSelection(\"smart\");},\n    indentMore: function(cm) {cm.indentSelection(\"add\");},\n    indentLess: function(cm) {cm.indentSelection(\"subtract\");},\n    insertTab: function(cm) {cm.replaceSelection(\"\\t\");},\n    insertSoftTab: function(cm) {\n      var spaces = [], ranges = cm.listSelections(), tabSize = cm.options.tabSize;\n      for (var i = 0; i < ranges.length; i++) {\n        var pos = ranges[i].from();\n        var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);\n        spaces.push(new Array(tabSize - col % tabSize + 1).join(\" \"));\n      }\n      cm.replaceSelections(spaces);\n    },\n    defaultTab: function(cm) {\n      if (cm.somethingSelected()) cm.indentSelection(\"add\");\n      else cm.execCommand(\"insertTab\");\n    },\n    transposeChars: function(cm) {\n      runInOp(cm, function() {\n        var ranges = cm.listSelections(), newSel = [];\n        for (var i = 0; i < ranges.length; i++) {\n          var cur = ranges[i].head, line = getLine(cm.doc, cur.line).text;\n          if (line) {\n            if (cur.ch == line.length) cur = new Pos(cur.line, cur.ch - 1);\n            if (cur.ch > 0) {\n              cur = new Pos(cur.line, cur.ch + 1);\n              cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2),\n                              Pos(cur.line, cur.ch - 2), cur, \"+transpose\");\n            } else if (cur.line > cm.doc.first) {\n              var prev = getLine(cm.doc, cur.line - 1).text;\n              if (prev)\n                cm.replaceRange(line.charAt(0) + \"\\n\" + prev.charAt(prev.length - 1),\n                                Pos(cur.line - 1, prev.length - 1), Pos(cur.line, 1), \"+transpose\");\n            }\n          }\n          newSel.push(new Range(cur, cur));\n        }\n        cm.setSelections(newSel);\n      });\n    },\n    newlineAndIndent: function(cm) {\n      runInOp(cm, function() {\n        var len = cm.listSelections().length;\n        for (var i = 0; i < len; i++) {\n          var range = cm.listSelections()[i];\n          cm.replaceRange(\"\\n\", range.anchor, range.head, \"+input\");\n          cm.indentLine(range.from().line + 1, null, true);\n          ensureCursorVisible(cm);\n        }\n      });\n    },\n    toggleOverwrite: function(cm) {cm.toggleOverwrite();}\n  };\n\n  // STANDARD KEYMAPS\n\n  var keyMap = CodeMirror.keyMap = {};\n  keyMap.basic = {\n    \"Left\": \"goCharLeft\", \"Right\": \"goCharRight\", \"Up\": \"goLineUp\", \"Down\": \"goLineDown\",\n    \"End\": \"goLineEnd\", \"Home\": \"goLineStartSmart\", \"PageUp\": \"goPageUp\", \"PageDown\": \"goPageDown\",\n    \"Delete\": \"delCharAfter\", \"Backspace\": \"delCharBefore\", \"Shift-Backspace\": \"delCharBefore\",\n    \"Tab\": \"defaultTab\", \"Shift-Tab\": \"indentAuto\",\n    \"Enter\": \"newlineAndIndent\", \"Insert\": \"toggleOverwrite\",\n    \"Esc\": \"singleSelection\"\n  };\n  // Note that the save and find-related commands aren't defined by\n  // default. User code or addons can define them. Unknown commands\n  // are simply ignored.\n  keyMap.pcDefault = {\n    \"Ctrl-A\": \"selectAll\", \"Ctrl-D\": \"deleteLine\", \"Ctrl-Z\": \"undo\", \"Shift-Ctrl-Z\": \"redo\", \"Ctrl-Y\": \"redo\",\n    \"Ctrl-Home\": \"goDocStart\", \"Ctrl-End\": \"goDocEnd\", \"Ctrl-Up\": \"goLineUp\", \"Ctrl-Down\": \"goLineDown\",\n    \"Ctrl-Left\": \"goGroupLeft\", \"Ctrl-Right\": \"goGroupRight\", \"Alt-Left\": \"goLineStart\", \"Alt-Right\": \"goLineEnd\",\n    \"Ctrl-Backspace\": \"delGroupBefore\", \"Ctrl-Delete\": \"delGroupAfter\", \"Ctrl-S\": \"save\", \"Ctrl-F\": \"find\",\n    \"Ctrl-G\": \"findNext\", \"Shift-Ctrl-G\": \"findPrev\", \"Shift-Ctrl-F\": \"replace\", \"Shift-Ctrl-R\": \"replaceAll\",\n    \"Ctrl-[\": \"indentLess\", \"Ctrl-]\": \"indentMore\",\n    \"Ctrl-U\": \"undoSelection\", \"Shift-Ctrl-U\": \"redoSelection\", \"Alt-U\": \"redoSelection\",\n    fallthrough: \"basic\"\n  };\n  keyMap.macDefault = {\n    \"Cmd-A\": \"selectAll\", \"Cmd-D\": \"deleteLine\", \"Cmd-Z\": \"undo\", \"Shift-Cmd-Z\": \"redo\", \"Cmd-Y\": \"redo\",\n    \"Cmd-Home\": \"goDocStart\", \"Cmd-Up\": \"goDocStart\", \"Cmd-End\": \"goDocEnd\", \"Cmd-Down\": \"goDocEnd\", \"Alt-Left\": \"goGroupLeft\",\n    \"Alt-Right\": \"goGroupRight\", \"Cmd-Left\": \"goLineLeft\", \"Cmd-Right\": \"goLineRight\", \"Alt-Backspace\": \"delGroupBefore\",\n    \"Ctrl-Alt-Backspace\": \"delGroupAfter\", \"Alt-Delete\": \"delGroupAfter\", \"Cmd-S\": \"save\", \"Cmd-F\": \"find\",\n    \"Cmd-G\": \"findNext\", \"Shift-Cmd-G\": \"findPrev\", \"Cmd-Alt-F\": \"replace\", \"Shift-Cmd-Alt-F\": \"replaceAll\",\n    \"Cmd-[\": \"indentLess\", \"Cmd-]\": \"indentMore\", \"Cmd-Backspace\": \"delWrappedLineLeft\", \"Cmd-Delete\": \"delWrappedLineRight\",\n    \"Cmd-U\": \"undoSelection\", \"Shift-Cmd-U\": \"redoSelection\", \"Ctrl-Up\": \"goDocStart\", \"Ctrl-Down\": \"goDocEnd\",\n    fallthrough: [\"basic\", \"emacsy\"]\n  };\n  // Very basic readline/emacs-style bindings, which are standard on Mac.\n  keyMap.emacsy = {\n    \"Ctrl-F\": \"goCharRight\", \"Ctrl-B\": \"goCharLeft\", \"Ctrl-P\": \"goLineUp\", \"Ctrl-N\": \"goLineDown\",\n    \"Alt-F\": \"goWordRight\", \"Alt-B\": \"goWordLeft\", \"Ctrl-A\": \"goLineStart\", \"Ctrl-E\": \"goLineEnd\",\n    \"Ctrl-V\": \"goPageDown\", \"Shift-Ctrl-V\": \"goPageUp\", \"Ctrl-D\": \"delCharAfter\", \"Ctrl-H\": \"delCharBefore\",\n    \"Alt-D\": \"delWordAfter\", \"Alt-Backspace\": \"delWordBefore\", \"Ctrl-K\": \"killLine\", \"Ctrl-T\": \"transposeChars\"\n  };\n  keyMap[\"default\"] = mac ? keyMap.macDefault : keyMap.pcDefault;\n\n  // KEYMAP DISPATCH\n\n  function getKeyMap(val) {\n    if (typeof val == \"string\") return keyMap[val];\n    else return val;\n  }\n\n  // Given an array of keymaps and a key name, call handle on any\n  // bindings found, until that returns a truthy value, at which point\n  // we consider the key handled. Implements things like binding a key\n  // to false stopping further handling and keymap fallthrough.\n  var lookupKey = CodeMirror.lookupKey = function(name, maps, handle) {\n    function lookup(map) {\n      map = getKeyMap(map);\n      var found = map[name];\n      if (found === false) return \"stop\";\n      if (found != null && handle(found)) return true;\n      if (map.nofallthrough) return \"stop\";\n\n      var fallthrough = map.fallthrough;\n      if (fallthrough == null) return false;\n      if (Object.prototype.toString.call(fallthrough) != \"[object Array]\")\n        return lookup(fallthrough);\n      for (var i = 0; i < fallthrough.length; ++i) {\n        var done = lookup(fallthrough[i]);\n        if (done) return done;\n      }\n      return false;\n    }\n\n    for (var i = 0; i < maps.length; ++i) {\n      var done = lookup(maps[i]);\n      if (done) return done != \"stop\";\n    }\n  };\n\n  // Modifier key presses don't count as 'real' key presses for the\n  // purpose of keymap fallthrough.\n  var isModifierKey = CodeMirror.isModifierKey = function(event) {\n    var name = keyNames[event.keyCode];\n    return name == \"Ctrl\" || name == \"Alt\" || name == \"Shift\" || name == \"Mod\";\n  };\n\n  // Look up the name of a key as indicated by an event object.\n  var keyName = CodeMirror.keyName = function(event, noShift) {\n    if (presto && event.keyCode == 34 && event[\"char\"]) return false;\n    var name = keyNames[event.keyCode];\n    if (name == null || event.altGraphKey) return false;\n    if (event.altKey) name = \"Alt-\" + name;\n    if (flipCtrlCmd ? event.metaKey : event.ctrlKey) name = \"Ctrl-\" + name;\n    if (flipCtrlCmd ? event.ctrlKey : event.metaKey) name = \"Cmd-\" + name;\n    if (!noShift && event.shiftKey) name = \"Shift-\" + name;\n    return name;\n  };\n\n  // FROMTEXTAREA\n\n  CodeMirror.fromTextArea = function(textarea, options) {\n    if (!options) options = {};\n    options.value = textarea.value;\n    if (!options.tabindex && textarea.tabindex)\n      options.tabindex = textarea.tabindex;\n    if (!options.placeholder && textarea.placeholder)\n      options.placeholder = textarea.placeholder;\n    // Set autofocus to true if this textarea is focused, or if it has\n    // autofocus and no other element is focused.\n    if (options.autofocus == null) {\n      var hasFocus = activeElt();\n      options.autofocus = hasFocus == textarea ||\n        textarea.getAttribute(\"autofocus\") != null && hasFocus == document.body;\n    }\n\n    function save() {textarea.value = cm.getValue();}\n    if (textarea.form) {\n      on(textarea.form, \"submit\", save);\n      // Deplorable hack to make the submit method do the right thing.\n      if (!options.leaveSubmitMethodAlone) {\n        var form = textarea.form, realSubmit = form.submit;\n        try {\n          var wrappedSubmit = form.submit = function() {\n            save();\n            form.submit = realSubmit;\n            form.submit();\n            form.submit = wrappedSubmit;\n          };\n        } catch(e) {}\n      }\n    }\n\n    textarea.style.display = \"none\";\n    var cm = CodeMirror(function(node) {\n      textarea.parentNode.insertBefore(node, textarea.nextSibling);\n    }, options);\n    cm.save = save;\n    cm.getTextArea = function() { return textarea; };\n    cm.toTextArea = function() {\n      cm.toTextArea = isNaN; // Prevent this from being ran twice\n      save();\n      textarea.parentNode.removeChild(cm.getWrapperElement());\n      textarea.style.display = \"\";\n      if (textarea.form) {\n        off(textarea.form, \"submit\", save);\n        if (typeof textarea.form.submit == \"function\")\n          textarea.form.submit = realSubmit;\n      }\n    };\n    return cm;\n  };\n\n  // STRING STREAM\n\n  // Fed to the mode parsers, provides helper functions to make\n  // parsers more succinct.\n\n  var StringStream = CodeMirror.StringStream = function(string, tabSize) {\n    this.pos = this.start = 0;\n    this.string = string;\n    this.tabSize = tabSize || 8;\n    this.lastColumnPos = this.lastColumnValue = 0;\n    this.lineStart = 0;\n  };\n\n  StringStream.prototype = {\n    eol: function() {return this.pos >= this.string.length;},\n    sol: function() {return this.pos == this.lineStart;},\n    peek: function() {return this.string.charAt(this.pos) || undefined;},\n    next: function() {\n      if (this.pos < this.string.length)\n        return this.string.charAt(this.pos++);\n    },\n    eat: function(match) {\n      var ch = this.string.charAt(this.pos);\n      if (typeof match == \"string\") var ok = ch == match;\n      else var ok = ch && (match.test ? match.test(ch) : match(ch));\n      if (ok) {++this.pos; return ch;}\n    },\n    eatWhile: function(match) {\n      var start = this.pos;\n      while (this.eat(match)){}\n      return this.pos > start;\n    },\n    eatSpace: function() {\n      var start = this.pos;\n      while (/[\\s\\u00a0]/.test(this.string.charAt(this.pos))) ++this.pos;\n      return this.pos > start;\n    },\n    skipToEnd: function() {this.pos = this.string.length;},\n    skipTo: function(ch) {\n      var found = this.string.indexOf(ch, this.pos);\n      if (found > -1) {this.pos = found; return true;}\n    },\n    backUp: function(n) {this.pos -= n;},\n    column: function() {\n      if (this.lastColumnPos < this.start) {\n        this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);\n        this.lastColumnPos = this.start;\n      }\n      return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);\n    },\n    indentation: function() {\n      return countColumn(this.string, null, this.tabSize) -\n        (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);\n    },\n    match: function(pattern, consume, caseInsensitive) {\n      if (typeof pattern == \"string\") {\n        var cased = function(str) {return caseInsensitive ? str.toLowerCase() : str;};\n        var substr = this.string.substr(this.pos, pattern.length);\n        if (cased(substr) == cased(pattern)) {\n          if (consume !== false) this.pos += pattern.length;\n          return true;\n        }\n      } else {\n        var match = this.string.slice(this.pos).match(pattern);\n        if (match && match.index > 0) return null;\n        if (match && consume !== false) this.pos += match[0].length;\n        return match;\n      }\n    },\n    current: function(){return this.string.slice(this.start, this.pos);},\n    hideFirstChars: function(n, inner) {\n      this.lineStart += n;\n      try { return inner(); }\n      finally { this.lineStart -= n; }\n    }\n  };\n\n  // TEXTMARKERS\n\n  // Created with markText and setBookmark methods. A TextMarker is a\n  // handle that can be used to clear or find a marked position in the\n  // document. Line objects hold arrays (markedSpans) containing\n  // {from, to, marker} object pointing to such marker objects, and\n  // indicating that such a marker is present on that line. Multiple\n  // lines may point to the same marker when it spans across lines.\n  // The spans will have null for their from/to properties when the\n  // marker continues beyond the start/end of the line. Markers have\n  // links back to the lines they currently touch.\n\n  var TextMarker = CodeMirror.TextMarker = function(doc, type) {\n    this.lines = [];\n    this.type = type;\n    this.doc = doc;\n  };\n  eventMixin(TextMarker);\n\n  // Clear the marker.\n  TextMarker.prototype.clear = function() {\n    if (this.explicitlyCleared) return;\n    var cm = this.doc.cm, withOp = cm && !cm.curOp;\n    if (withOp) startOperation(cm);\n    if (hasHandler(this, \"clear\")) {\n      var found = this.find();\n      if (found) signalLater(this, \"clear\", found.from, found.to);\n    }\n    var min = null, max = null;\n    for (var i = 0; i < this.lines.length; ++i) {\n      var line = this.lines[i];\n      var span = getMarkedSpanFor(line.markedSpans, this);\n      if (cm && !this.collapsed) regLineChange(cm, lineNo(line), \"text\");\n      else if (cm) {\n        if (span.to != null) max = lineNo(line);\n        if (span.from != null) min = lineNo(line);\n      }\n      line.markedSpans = removeMarkedSpan(line.markedSpans, span);\n      if (span.from == null && this.collapsed && !lineIsHidden(this.doc, line) && cm)\n        updateLineHeight(line, textHeight(cm.display));\n    }\n    if (cm && this.collapsed && !cm.options.lineWrapping) for (var i = 0; i < this.lines.length; ++i) {\n      var visual = visualLine(this.lines[i]), len = lineLength(visual);\n      if (len > cm.display.maxLineLength) {\n        cm.display.maxLine = visual;\n        cm.display.maxLineLength = len;\n        cm.display.maxLineChanged = true;\n      }\n    }\n\n    if (min != null && cm && this.collapsed) regChange(cm, min, max + 1);\n    this.lines.length = 0;\n    this.explicitlyCleared = true;\n    if (this.atomic && this.doc.cantEdit) {\n      this.doc.cantEdit = false;\n      if (cm) reCheckSelection(cm.doc);\n    }\n    if (cm) signalLater(cm, \"markerCleared\", cm, this);\n    if (withOp) endOperation(cm);\n    if (this.parent) this.parent.clear();\n  };\n\n  // Find the position of the marker in the document. Returns a {from,\n  // to} object by default. Side can be passed to get a specific side\n  // -- 0 (both), -1 (left), or 1 (right). When lineObj is true, the\n  // Pos objects returned contain a line object, rather than a line\n  // number (used to prevent looking up the same line twice).\n  TextMarker.prototype.find = function(side, lineObj) {\n    if (side == null && this.type == \"bookmark\") side = 1;\n    var from, to;\n    for (var i = 0; i < this.lines.length; ++i) {\n      var line = this.lines[i];\n      var span = getMarkedSpanFor(line.markedSpans, this);\n      if (span.from != null) {\n        from = Pos(lineObj ? line : lineNo(line), span.from);\n        if (side == -1) return from;\n      }\n      if (span.to != null) {\n        to = Pos(lineObj ? line : lineNo(line), span.to);\n        if (side == 1) return to;\n      }\n    }\n    return from && {from: from, to: to};\n  };\n\n  // Signals that the marker's widget changed, and surrounding layout\n  // should be recomputed.\n  TextMarker.prototype.changed = function() {\n    var pos = this.find(-1, true), widget = this, cm = this.doc.cm;\n    if (!pos || !cm) return;\n    runInOp(cm, function() {\n      var line = pos.line, lineN = lineNo(pos.line);\n      var view = findViewForLine(cm, lineN);\n      if (view) {\n        clearLineMeasurementCacheFor(view);\n        cm.curOp.selectionChanged = cm.curOp.forceUpdate = true;\n      }\n      cm.curOp.updateMaxLine = true;\n      if (!lineIsHidden(widget.doc, line) && widget.height != null) {\n        var oldHeight = widget.height;\n        widget.height = null;\n        var dHeight = widgetHeight(widget) - oldHeight;\n        if (dHeight)\n          updateLineHeight(line, line.height + dHeight);\n      }\n    });\n  };\n\n  TextMarker.prototype.attachLine = function(line) {\n    if (!this.lines.length && this.doc.cm) {\n      var op = this.doc.cm.curOp;\n      if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1)\n        (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this);\n    }\n    this.lines.push(line);\n  };\n  TextMarker.prototype.detachLine = function(line) {\n    this.lines.splice(indexOf(this.lines, line), 1);\n    if (!this.lines.length && this.doc.cm) {\n      var op = this.doc.cm.curOp;\n      (op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);\n    }\n  };\n\n  // Collapsed markers have unique ids, in order to be able to order\n  // them, which is needed for uniquely determining an outer marker\n  // when they overlap (they may nest, but not partially overlap).\n  var nextMarkerId = 0;\n\n  // Create a marker, wire it up to the right lines, and\n  function markText(doc, from, to, options, type) {\n    // Shared markers (across linked documents) are handled separately\n    // (markTextShared will call out to this again, once per\n    // document).\n    if (options && options.shared) return markTextShared(doc, from, to, options, type);\n    // Ensure we are in an operation.\n    if (doc.cm && !doc.cm.curOp) return operation(doc.cm, markText)(doc, from, to, options, type);\n\n    var marker = new TextMarker(doc, type), diff = cmp(from, to);\n    if (options) copyObj(options, marker, false);\n    // Don't connect empty markers unless clearWhenEmpty is false\n    if (diff > 0 || diff == 0 && marker.clearWhenEmpty !== false)\n      return marker;\n    if (marker.replacedWith) {\n      // Showing up as a widget implies collapsed (widget replaces text)\n      marker.collapsed = true;\n      marker.widgetNode = elt(\"span\", [marker.replacedWith], \"CodeMirror-widget\");\n      if (!options.handleMouseEvents) marker.widgetNode.ignoreEvents = true;\n      if (options.insertLeft) marker.widgetNode.insertLeft = true;\n    }\n    if (marker.collapsed) {\n      if (conflictingCollapsedRange(doc, from.line, from, to, marker) ||\n          from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker))\n        throw new Error(\"Inserting collapsed marker partially overlapping an existing one\");\n      sawCollapsedSpans = true;\n    }\n\n    if (marker.addToHistory)\n      addChangeToHistory(doc, {from: from, to: to, origin: \"markText\"}, doc.sel, NaN);\n\n    var curLine = from.line, cm = doc.cm, updateMaxLine;\n    doc.iter(curLine, to.line + 1, function(line) {\n      if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine)\n        updateMaxLine = true;\n      if (marker.collapsed && curLine != from.line) updateLineHeight(line, 0);\n      addMarkedSpan(line, new MarkedSpan(marker,\n                                         curLine == from.line ? from.ch : null,\n                                         curLine == to.line ? to.ch : null));\n      ++curLine;\n    });\n    // lineIsHidden depends on the presence of the spans, so needs a second pass\n    if (marker.collapsed) doc.iter(from.line, to.line + 1, function(line) {\n      if (lineIsHidden(doc, line)) updateLineHeight(line, 0);\n    });\n\n    if (marker.clearOnEnter) on(marker, \"beforeCursorEnter\", function() { marker.clear(); });\n\n    if (marker.readOnly) {\n      sawReadOnlySpans = true;\n      if (doc.history.done.length || doc.history.undone.length)\n        doc.clearHistory();\n    }\n    if (marker.collapsed) {\n      marker.id = ++nextMarkerId;\n      marker.atomic = true;\n    }\n    if (cm) {\n      // Sync editor state\n      if (updateMaxLine) cm.curOp.updateMaxLine = true;\n      if (marker.collapsed)\n        regChange(cm, from.line, to.line + 1);\n      else if (marker.className || marker.title || marker.startStyle || marker.endStyle)\n        for (var i = from.line; i <= to.line; i++) regLineChange(cm, i, \"text\");\n      if (marker.atomic) reCheckSelection(cm.doc);\n      signalLater(cm, \"markerAdded\", cm, marker);\n    }\n    return marker;\n  }\n\n  // SHARED TEXTMARKERS\n\n  // A shared marker spans multiple linked documents. It is\n  // implemented as a meta-marker-object controlling multiple normal\n  // markers.\n  var SharedTextMarker = CodeMirror.SharedTextMarker = function(markers, primary) {\n    this.markers = markers;\n    this.primary = primary;\n    for (var i = 0; i < markers.length; ++i)\n      markers[i].parent = this;\n  };\n  eventMixin(SharedTextMarker);\n\n  SharedTextMarker.prototype.clear = function() {\n    if (this.explicitlyCleared) return;\n    this.explicitlyCleared = true;\n    for (var i = 0; i < this.markers.length; ++i)\n      this.markers[i].clear();\n    signalLater(this, \"clear\");\n  };\n  SharedTextMarker.prototype.find = function(side, lineObj) {\n    return this.primary.find(side, lineObj);\n  };\n\n  function markTextShared(doc, from, to, options, type) {\n    options = copyObj(options);\n    options.shared = false;\n    var markers = [markText(doc, from, to, options, type)], primary = markers[0];\n    var widget = options.widgetNode;\n    linkedDocs(doc, function(doc) {\n      if (widget) options.widgetNode = widget.cloneNode(true);\n      markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type));\n      for (var i = 0; i < doc.linked.length; ++i)\n        if (doc.linked[i].isParent) return;\n      primary = lst(markers);\n    });\n    return new SharedTextMarker(markers, primary);\n  }\n\n  function findSharedMarkers(doc) {\n    return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())),\n                         function(m) { return m.parent; });\n  }\n\n  function copySharedMarkers(doc, markers) {\n    for (var i = 0; i < markers.length; i++) {\n      var marker = markers[i], pos = marker.find();\n      var mFrom = doc.clipPos(pos.from), mTo = doc.clipPos(pos.to);\n      if (cmp(mFrom, mTo)) {\n        var subMark = markText(doc, mFrom, mTo, marker.primary, marker.primary.type);\n        marker.markers.push(subMark);\n        subMark.parent = marker;\n      }\n    }\n  }\n\n  function detachSharedMarkers(markers) {\n    for (var i = 0; i < markers.length; i++) {\n      var marker = markers[i], linked = [marker.primary.doc];;\n      linkedDocs(marker.primary.doc, function(d) { linked.push(d); });\n      for (var j = 0; j < marker.markers.length; j++) {\n        var subMarker = marker.markers[j];\n        if (indexOf(linked, subMarker.doc) == -1) {\n          subMarker.parent = null;\n          marker.markers.splice(j--, 1);\n        }\n      }\n    }\n  }\n\n  // TEXTMARKER SPANS\n\n  function MarkedSpan(marker, from, to) {\n    this.marker = marker;\n    this.from = from; this.to = to;\n  }\n\n  // Search an array of spans for a span matching the given marker.\n  function getMarkedSpanFor(spans, marker) {\n    if (spans) for (var i = 0; i < spans.length; ++i) {\n      var span = spans[i];\n      if (span.marker == marker) return span;\n    }\n  }\n  // Remove a span from an array, returning undefined if no spans are\n  // left (we don't store arrays for lines without spans).\n  function removeMarkedSpan(spans, span) {\n    for (var r, i = 0; i < spans.length; ++i)\n      if (spans[i] != span) (r || (r = [])).push(spans[i]);\n    return r;\n  }\n  // Add a span to a line.\n  function addMarkedSpan(line, span) {\n    line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];\n    span.marker.attachLine(line);\n  }\n\n  // Used for the algorithm that adjusts markers for a change in the\n  // document. These functions cut an array of spans at a given\n  // character position, returning an array of remaining chunks (or\n  // undefined if nothing remains).\n  function markedSpansBefore(old, startCh, isInsert) {\n    if (old) for (var i = 0, nw; i < old.length; ++i) {\n      var span = old[i], marker = span.marker;\n      var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);\n      if (startsBefore || span.from == startCh && marker.type == \"bookmark\" && (!isInsert || !span.marker.insertLeft)) {\n        var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh);\n        (nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to));\n      }\n    }\n    return nw;\n  }\n  function markedSpansAfter(old, endCh, isInsert) {\n    if (old) for (var i = 0, nw; i < old.length; ++i) {\n      var span = old[i], marker = span.marker;\n      var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);\n      if (endsAfter || span.from == endCh && marker.type == \"bookmark\" && (!isInsert || span.marker.insertLeft)) {\n        var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh);\n        (nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh,\n                                              span.to == null ? null : span.to - endCh));\n      }\n    }\n    return nw;\n  }\n\n  // Given a change object, compute the new set of marker spans that\n  // cover the line in which the change took place. Removes spans\n  // entirely within the change, reconnects spans belonging to the\n  // same marker that appear on both sides of the change, and cuts off\n  // spans partially within the change. Returns an array of span\n  // arrays with one element for each line in (after) the change.\n  function stretchSpansOverChange(doc, change) {\n    var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;\n    var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;\n    if (!oldFirst && !oldLast) return null;\n\n    var startCh = change.from.ch, endCh = change.to.ch, isInsert = cmp(change.from, change.to) == 0;\n    // Get the spans that 'stick out' on both sides\n    var first = markedSpansBefore(oldFirst, startCh, isInsert);\n    var last = markedSpansAfter(oldLast, endCh, isInsert);\n\n    // Next, merge those two ends\n    var sameLine = change.text.length == 1, offset = lst(change.text).length + (sameLine ? startCh : 0);\n    if (first) {\n      // Fix up .to properties of first\n      for (var i = 0; i < first.length; ++i) {\n        var span = first[i];\n        if (span.to == null) {\n          var found = getMarkedSpanFor(last, span.marker);\n          if (!found) span.to = startCh;\n          else if (sameLine) span.to = found.to == null ? null : found.to + offset;\n        }\n      }\n    }\n    if (last) {\n      // Fix up .from in last (or move them into first in case of sameLine)\n      for (var i = 0; i < last.length; ++i) {\n        var span = last[i];\n        if (span.to != null) span.to += offset;\n        if (span.from == null) {\n          var found = getMarkedSpanFor(first, span.marker);\n          if (!found) {\n            span.from = offset;\n            if (sameLine) (first || (first = [])).push(span);\n          }\n        } else {\n          span.from += offset;\n          if (sameLine) (first || (first = [])).push(span);\n        }\n      }\n    }\n    // Make sure we didn't create any zero-length spans\n    if (first) first = clearEmptySpans(first);\n    if (last && last != first) last = clearEmptySpans(last);\n\n    var newMarkers = [first];\n    if (!sameLine) {\n      // Fill gap with whole-line-spans\n      var gap = change.text.length - 2, gapMarkers;\n      if (gap > 0 && first)\n        for (var i = 0; i < first.length; ++i)\n          if (first[i].to == null)\n            (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i].marker, null, null));\n      for (var i = 0; i < gap; ++i)\n        newMarkers.push(gapMarkers);\n      newMarkers.push(last);\n    }\n    return newMarkers;\n  }\n\n  // Remove spans that are empty and don't have a clearWhenEmpty\n  // option of false.\n  function clearEmptySpans(spans) {\n    for (var i = 0; i < spans.length; ++i) {\n      var span = spans[i];\n      if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false)\n        spans.splice(i--, 1);\n    }\n    if (!spans.length) return null;\n    return spans;\n  }\n\n  // Used for un/re-doing changes from the history. Combines the\n  // result of computing the existing spans with the set of spans that\n  // existed in the history (so that deleting around a span and then\n  // undoing brings back the span).\n  function mergeOldSpans(doc, change) {\n    var old = getOldSpans(doc, change);\n    var stretched = stretchSpansOverChange(doc, change);\n    if (!old) return stretched;\n    if (!stretched) return old;\n\n    for (var i = 0; i < old.length; ++i) {\n      var oldCur = old[i], stretchCur = stretched[i];\n      if (oldCur && stretchCur) {\n        spans: for (var j = 0; j < stretchCur.length; ++j) {\n          var span = stretchCur[j];\n          for (var k = 0; k < oldCur.length; ++k)\n            if (oldCur[k].marker == span.marker) continue spans;\n          oldCur.push(span);\n        }\n      } else if (stretchCur) {\n        old[i] = stretchCur;\n      }\n    }\n    return old;\n  }\n\n  // Used to 'clip' out readOnly ranges when making a change.\n  function removeReadOnlyRanges(doc, from, to) {\n    var markers = null;\n    doc.iter(from.line, to.line + 1, function(line) {\n      if (line.markedSpans) for (var i = 0; i < line.markedSpans.length; ++i) {\n        var mark = line.markedSpans[i].marker;\n        if (mark.readOnly && (!markers || indexOf(markers, mark) == -1))\n          (markers || (markers = [])).push(mark);\n      }\n    });\n    if (!markers) return null;\n    var parts = [{from: from, to: to}];\n    for (var i = 0; i < markers.length; ++i) {\n      var mk = markers[i], m = mk.find(0);\n      for (var j = 0; j < parts.length; ++j) {\n        var p = parts[j];\n        if (cmp(p.to, m.from) < 0 || cmp(p.from, m.to) > 0) continue;\n        var newParts = [j, 1], dfrom = cmp(p.from, m.from), dto = cmp(p.to, m.to);\n        if (dfrom < 0 || !mk.inclusiveLeft && !dfrom)\n          newParts.push({from: p.from, to: m.from});\n        if (dto > 0 || !mk.inclusiveRight && !dto)\n          newParts.push({from: m.to, to: p.to});\n        parts.splice.apply(parts, newParts);\n        j += newParts.length - 1;\n      }\n    }\n    return parts;\n  }\n\n  // Connect or disconnect spans from a line.\n  function detachMarkedSpans(line) {\n    var spans = line.markedSpans;\n    if (!spans) return;\n    for (var i = 0; i < spans.length; ++i)\n      spans[i].marker.detachLine(line);\n    line.markedSpans = null;\n  }\n  function attachMarkedSpans(line, spans) {\n    if (!spans) return;\n    for (var i = 0; i < spans.length; ++i)\n      spans[i].marker.attachLine(line);\n    line.markedSpans = spans;\n  }\n\n  // Helpers used when computing which overlapping collapsed span\n  // counts as the larger one.\n  function extraLeft(marker) { return marker.inclusiveLeft ? -1 : 0; }\n  function extraRight(marker) { return marker.inclusiveRight ? 1 : 0; }\n\n  // Returns a number indicating which of two overlapping collapsed\n  // spans is larger (and thus includes the other). Falls back to\n  // comparing ids when the spans cover exactly the same range.\n  function compareCollapsedMarkers(a, b) {\n    var lenDiff = a.lines.length - b.lines.length;\n    if (lenDiff != 0) return lenDiff;\n    var aPos = a.find(), bPos = b.find();\n    var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);\n    if (fromCmp) return -fromCmp;\n    var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);\n    if (toCmp) return toCmp;\n    return b.id - a.id;\n  }\n\n  // Find out whether a line ends or starts in a collapsed span. If\n  // so, return the marker for that span.\n  function collapsedSpanAtSide(line, start) {\n    var sps = sawCollapsedSpans && line.markedSpans, found;\n    if (sps) for (var sp, i = 0; i < sps.length; ++i) {\n      sp = sps[i];\n      if (sp.marker.collapsed && (start ? sp.from : sp.to) == null &&\n          (!found || compareCollapsedMarkers(found, sp.marker) < 0))\n        found = sp.marker;\n    }\n    return found;\n  }\n  function collapsedSpanAtStart(line) { return collapsedSpanAtSide(line, true); }\n  function collapsedSpanAtEnd(line) { return collapsedSpanAtSide(line, false); }\n\n  // Test whether there exists a collapsed span that partially\n  // overlaps (covers the start or end, but not both) of a new span.\n  // Such overlap is not allowed.\n  function conflictingCollapsedRange(doc, lineNo, from, to, marker) {\n    var line = getLine(doc, lineNo);\n    var sps = sawCollapsedSpans && line.markedSpans;\n    if (sps) for (var i = 0; i < sps.length; ++i) {\n      var sp = sps[i];\n      if (!sp.marker.collapsed) continue;\n      var found = sp.marker.find(0);\n      var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);\n      var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);\n      if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) continue;\n      if (fromCmp <= 0 && (cmp(found.to, from) > 0 || (sp.marker.inclusiveRight && marker.inclusiveLeft)) ||\n          fromCmp >= 0 && (cmp(found.from, to) < 0 || (sp.marker.inclusiveLeft && marker.inclusiveRight)))\n        return true;\n    }\n  }\n\n  // A visual line is a line as drawn on the screen. Folding, for\n  // example, can cause multiple logical lines to appear on the same\n  // visual line. This finds the start of the visual line that the\n  // given line is part of (usually that is the line itself).\n  function visualLine(line) {\n    var merged;\n    while (merged = collapsedSpanAtStart(line))\n      line = merged.find(-1, true).line;\n    return line;\n  }\n\n  // Returns an array of logical lines that continue the visual line\n  // started by the argument, or undefined if there are no such lines.\n  function visualLineContinued(line) {\n    var merged, lines;\n    while (merged = collapsedSpanAtEnd(line)) {\n      line = merged.find(1, true).line;\n      (lines || (lines = [])).push(line);\n    }\n    return lines;\n  }\n\n  // Get the line number of the start of the visual line that the\n  // given line number is part of.\n  function visualLineNo(doc, lineN) {\n    var line = getLine(doc, lineN), vis = visualLine(line);\n    if (line == vis) return lineN;\n    return lineNo(vis);\n  }\n  // Get the line number of the start of the next visual line after\n  // the given line.\n  function visualLineEndNo(doc, lineN) {\n    if (lineN > doc.lastLine()) return lineN;\n    var line = getLine(doc, lineN), merged;\n    if (!lineIsHidden(doc, line)) return lineN;\n    while (merged = collapsedSpanAtEnd(line))\n      line = merged.find(1, true).line;\n    return lineNo(line) + 1;\n  }\n\n  // Compute whether a line is hidden. Lines count as hidden when they\n  // are part of a visual line that starts with another line, or when\n  // they are entirely covered by collapsed, non-widget span.\n  function lineIsHidden(doc, line) {\n    var sps = sawCollapsedSpans && line.markedSpans;\n    if (sps) for (var sp, i = 0; i < sps.length; ++i) {\n      sp = sps[i];\n      if (!sp.marker.collapsed) continue;\n      if (sp.from == null) return true;\n      if (sp.marker.widgetNode) continue;\n      if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp))\n        return true;\n    }\n  }\n  function lineIsHiddenInner(doc, line, span) {\n    if (span.to == null) {\n      var end = span.marker.find(1, true);\n      return lineIsHiddenInner(doc, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker));\n    }\n    if (span.marker.inclusiveRight && span.to == line.text.length)\n      return true;\n    for (var sp, i = 0; i < line.markedSpans.length; ++i) {\n      sp = line.markedSpans[i];\n      if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to &&\n          (sp.to == null || sp.to != span.from) &&\n          (sp.marker.inclusiveLeft || span.marker.inclusiveRight) &&\n          lineIsHiddenInner(doc, line, sp)) return true;\n    }\n  }\n\n  // LINE WIDGETS\n\n  // Line widgets are block elements displayed above or below a line.\n\n  var LineWidget = CodeMirror.LineWidget = function(cm, node, options) {\n    if (options) for (var opt in options) if (options.hasOwnProperty(opt))\n      this[opt] = options[opt];\n    this.cm = cm;\n    this.node = node;\n  };\n  eventMixin(LineWidget);\n\n  function adjustScrollWhenAboveVisible(cm, line, diff) {\n    if (heightAtLine(line) < ((cm.curOp && cm.curOp.scrollTop) || cm.doc.scrollTop))\n      addToScrollPos(cm, null, diff);\n  }\n\n  LineWidget.prototype.clear = function() {\n    var cm = this.cm, ws = this.line.widgets, line = this.line, no = lineNo(line);\n    if (no == null || !ws) return;\n    for (var i = 0; i < ws.length; ++i) if (ws[i] == this) ws.splice(i--, 1);\n    if (!ws.length) line.widgets = null;\n    var height = widgetHeight(this);\n    runInOp(cm, function() {\n      adjustScrollWhenAboveVisible(cm, line, -height);\n      regLineChange(cm, no, \"widget\");\n      updateLineHeight(line, Math.max(0, line.height - height));\n    });\n  };\n  LineWidget.prototype.changed = function() {\n    var oldH = this.height, cm = this.cm, line = this.line;\n    this.height = null;\n    var diff = widgetHeight(this) - oldH;\n    if (!diff) return;\n    runInOp(cm, function() {\n      cm.curOp.forceUpdate = true;\n      adjustScrollWhenAboveVisible(cm, line, diff);\n      updateLineHeight(line, line.height + diff);\n    });\n  };\n\n  function widgetHeight(widget) {\n    if (widget.height != null) return widget.height;\n    if (!contains(document.body, widget.node)) {\n      var parentStyle = \"position: relative;\";\n      if (widget.coverGutter)\n        parentStyle += \"margin-left: -\" + widget.cm.getGutterElement().offsetWidth + \"px;\";\n      removeChildrenAndAdd(widget.cm.display.measure, elt(\"div\", [widget.node], null, parentStyle));\n    }\n    return widget.height = widget.node.offsetHeight;\n  }\n\n  function addLineWidget(cm, handle, node, options) {\n    var widget = new LineWidget(cm, node, options);\n    if (widget.noHScroll) cm.display.alignWidgets = true;\n    changeLine(cm.doc, handle, \"widget\", function(line) {\n      var widgets = line.widgets || (line.widgets = []);\n      if (widget.insertAt == null) widgets.push(widget);\n      else widgets.splice(Math.min(widgets.length - 1, Math.max(0, widget.insertAt)), 0, widget);\n      widget.line = line;\n      if (!lineIsHidden(cm.doc, line)) {\n        var aboveVisible = heightAtLine(line) < cm.doc.scrollTop;\n        updateLineHeight(line, line.height + widgetHeight(widget));\n        if (aboveVisible) addToScrollPos(cm, null, widget.height);\n        cm.curOp.forceUpdate = true;\n      }\n      return true;\n    });\n    return widget;\n  }\n\n  // LINE DATA STRUCTURE\n\n  // Line objects. These hold state related to a line, including\n  // highlighting info (the styles array).\n  var Line = CodeMirror.Line = function(text, markedSpans, estimateHeight) {\n    this.text = text;\n    attachMarkedSpans(this, markedSpans);\n    this.height = estimateHeight ? estimateHeight(this) : 1;\n  };\n  eventMixin(Line);\n  Line.prototype.lineNo = function() { return lineNo(this); };\n\n  // Change the content (text, markers) of a line. Automatically\n  // invalidates cached information and tries to re-estimate the\n  // line's height.\n  function updateLine(line, text, markedSpans, estimateHeight) {\n    line.text = text;\n    if (line.stateAfter) line.stateAfter = null;\n    if (line.styles) line.styles = null;\n    if (line.order != null) line.order = null;\n    detachMarkedSpans(line);\n    attachMarkedSpans(line, markedSpans);\n    var estHeight = estimateHeight ? estimateHeight(line) : 1;\n    if (estHeight != line.height) updateLineHeight(line, estHeight);\n  }\n\n  // Detach a line from the document tree and its markers.\n  function cleanUpLine(line) {\n    line.parent = null;\n    detachMarkedSpans(line);\n  }\n\n  function extractLineClasses(type, output) {\n    if (type) for (;;) {\n      var lineClass = type.match(/(?:^|\\s+)line-(background-)?(\\S+)/);\n      if (!lineClass) break;\n      type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length);\n      var prop = lineClass[1] ? \"bgClass\" : \"textClass\";\n      if (output[prop] == null)\n        output[prop] = lineClass[2];\n      else if (!(new RegExp(\"(?:^|\\s)\" + lineClass[2] + \"(?:$|\\s)\")).test(output[prop]))\n        output[prop] += \" \" + lineClass[2];\n    }\n    return type;\n  }\n\n  function callBlankLine(mode, state) {\n    if (mode.blankLine) return mode.blankLine(state);\n    if (!mode.innerMode) return;\n    var inner = CodeMirror.innerMode(mode, state);\n    if (inner.mode.blankLine) return inner.mode.blankLine(inner.state);\n  }\n\n  function readToken(mode, stream, state) {\n    for (var i = 0; i < 10; i++) {\n      var style = mode.token(stream, state);\n      if (stream.pos > stream.start) return style;\n    }\n    throw new Error(\"Mode \" + mode.name + \" failed to advance stream.\");\n  }\n\n  // Run the given mode's parser over a line, calling f for each token.\n  function runMode(cm, text, mode, state, f, lineClasses, forceToEnd) {\n    var flattenSpans = mode.flattenSpans;\n    if (flattenSpans == null) flattenSpans = cm.options.flattenSpans;\n    var curStart = 0, curStyle = null;\n    var stream = new StringStream(text, cm.options.tabSize), style;\n    if (text == \"\") extractLineClasses(callBlankLine(mode, state), lineClasses);\n    while (!stream.eol()) {\n      if (stream.pos > cm.options.maxHighlightLength) {\n        flattenSpans = false;\n        if (forceToEnd) processLine(cm, text, state, stream.pos);\n        stream.pos = text.length;\n        style = null;\n      } else {\n        style = extractLineClasses(readToken(mode, stream, state), lineClasses);\n      }\n      if (cm.options.addModeClass) {\n        var mName = CodeMirror.innerMode(mode, state).mode.name;\n        if (mName) style = \"m-\" + (style ? mName + \" \" + style : mName);\n      }\n      if (!flattenSpans || curStyle != style) {\n        if (curStart < stream.start) f(stream.start, curStyle);\n        curStart = stream.start; curStyle = style;\n      }\n      stream.start = stream.pos;\n    }\n    while (curStart < stream.pos) {\n      // Webkit seems to refuse to render text nodes longer than 57444 characters\n      var pos = Math.min(stream.pos, curStart + 50000);\n      f(pos, curStyle);\n      curStart = pos;\n    }\n  }\n\n  // Compute a style array (an array starting with a mode generation\n  // -- for invalidation -- followed by pairs of end positions and\n  // style strings), which is used to highlight the tokens on the\n  // line.\n  function highlightLine(cm, line, state, forceToEnd) {\n    // A styles array always starts with a number identifying the\n    // mode/overlays that it is based on (for easy invalidation).\n    var st = [cm.state.modeGen], lineClasses = {};\n    // Compute the base array of styles\n    runMode(cm, line.text, cm.doc.mode, state, function(end, style) {\n      st.push(end, style);\n    }, lineClasses, forceToEnd);\n\n    // Run overlays, adjust style array.\n    for (var o = 0; o < cm.state.overlays.length; ++o) {\n      var overlay = cm.state.overlays[o], i = 1, at = 0;\n      runMode(cm, line.text, overlay.mode, true, function(end, style) {\n        var start = i;\n        // Ensure there's a token end at the current position, and that i points at it\n        while (at < end) {\n          var i_end = st[i];\n          if (i_end > end)\n            st.splice(i, 1, end, st[i+1], i_end);\n          i += 2;\n          at = Math.min(end, i_end);\n        }\n        if (!style) return;\n        if (overlay.opaque) {\n          st.splice(start, i - start, end, \"cm-overlay \" + style);\n          i = start + 2;\n        } else {\n          for (; start < i; start += 2) {\n            var cur = st[start+1];\n            st[start+1] = (cur ? cur + \" \" : \"\") + \"cm-overlay \" + style;\n          }\n        }\n      }, lineClasses);\n    }\n\n    return {styles: st, classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null};\n  }\n\n  function getLineStyles(cm, line) {\n    if (!line.styles || line.styles[0] != cm.state.modeGen) {\n      var result = highlightLine(cm, line, line.stateAfter = getStateBefore(cm, lineNo(line)));\n      line.styles = result.styles;\n      if (result.classes) line.styleClasses = result.classes;\n      else if (line.styleClasses) line.styleClasses = null;\n    }\n    return line.styles;\n  }\n\n  // Lightweight form of highlight -- proceed over this line and\n  // update state, but don't save a style array. Used for lines that\n  // aren't currently visible.\n  function processLine(cm, text, state, startAt) {\n    var mode = cm.doc.mode;\n    var stream = new StringStream(text, cm.options.tabSize);\n    stream.start = stream.pos = startAt || 0;\n    if (text == \"\") callBlankLine(mode, state);\n    while (!stream.eol() && stream.pos <= cm.options.maxHighlightLength) {\n      readToken(mode, stream, state);\n      stream.start = stream.pos;\n    }\n  }\n\n  // Convert a style as returned by a mode (either null, or a string\n  // containing one or more styles) to a CSS style. This is cached,\n  // and also looks for line-wide styles.\n  var styleToClassCache = {}, styleToClassCacheWithMode = {};\n  function interpretTokenStyle(style, options) {\n    if (!style || /^\\s*$/.test(style)) return null;\n    var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;\n    return cache[style] ||\n      (cache[style] = style.replace(/\\S+/g, \"cm-$&\"));\n  }\n\n  // Render the DOM representation of the text of a line. Also builds\n  // up a 'line map', which points at the DOM nodes that represent\n  // specific stretches of text, and is used by the measuring code.\n  // The returned object contains the DOM node, this map, and\n  // information about line-wide styles that were set by the mode.\n  function buildLineContent(cm, lineView) {\n    // The padding-right forces the element to have a 'border', which\n    // is needed on Webkit to be able to get line-level bounding\n    // rectangles for it (in measureChar).\n    var content = elt(\"span\", null, null, webkit ? \"padding-right: .1px\" : null);\n    var builder = {pre: elt(\"pre\", [content]), content: content, col: 0, pos: 0, cm: cm};\n    lineView.measure = {};\n\n    // Iterate over the logical lines that make up this visual line.\n    for (var i = 0; i <= (lineView.rest ? lineView.rest.length : 0); i++) {\n      var line = i ? lineView.rest[i - 1] : lineView.line, order;\n      builder.pos = 0;\n      builder.addToken = buildToken;\n      // Optionally wire in some hacks into the token-rendering\n      // algorithm, to deal with browser quirks.\n      if ((ie || webkit) && cm.getOption(\"lineWrapping\"))\n        builder.addToken = buildTokenSplitSpaces(builder.addToken);\n      if (hasBadBidiRects(cm.display.measure) && (order = getOrder(line)))\n        builder.addToken = buildTokenBadBidi(builder.addToken, order);\n      builder.map = [];\n      insertLineContent(line, builder, getLineStyles(cm, line));\n      if (line.styleClasses) {\n        if (line.styleClasses.bgClass)\n          builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || \"\");\n        if (line.styleClasses.textClass)\n          builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || \"\");\n      }\n\n      // Ensure at least a single node is present, for measuring.\n      if (builder.map.length == 0)\n        builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure)));\n\n      // Store the map and a cache object for the current logical line\n      if (i == 0) {\n        lineView.measure.map = builder.map;\n        lineView.measure.cache = {};\n      } else {\n        (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map);\n        (lineView.measure.caches || (lineView.measure.caches = [])).push({});\n      }\n    }\n\n    signal(cm, \"renderLine\", cm, lineView.line, builder.pre);\n    if (builder.pre.className)\n      builder.textClass = joinClasses(builder.pre.className, builder.textClass || \"\");\n    return builder;\n  }\n\n  function defaultSpecialCharPlaceholder(ch) {\n    var token = elt(\"span\", \"\\u2022\", \"cm-invalidchar\");\n    token.title = \"\\\\u\" + ch.charCodeAt(0).toString(16);\n    return token;\n  }\n\n  // Build up the DOM representation for a single token, and add it to\n  // the line map. Takes care to render special characters separately.\n  function buildToken(builder, text, style, startStyle, endStyle, title) {\n    if (!text) return;\n    var special = builder.cm.options.specialChars, mustWrap = false;\n    if (!special.test(text)) {\n      builder.col += text.length;\n      var content = document.createTextNode(text);\n      builder.map.push(builder.pos, builder.pos + text.length, content);\n      if (ie && ie_version < 9) mustWrap = true;\n      builder.pos += text.length;\n    } else {\n      var content = document.createDocumentFragment(), pos = 0;\n      while (true) {\n        special.lastIndex = pos;\n        var m = special.exec(text);\n        var skipped = m ? m.index - pos : text.length - pos;\n        if (skipped) {\n          var txt = document.createTextNode(text.slice(pos, pos + skipped));\n          if (ie && ie_version < 9) content.appendChild(elt(\"span\", [txt]));\n          else content.appendChild(txt);\n          builder.map.push(builder.pos, builder.pos + skipped, txt);\n          builder.col += skipped;\n          builder.pos += skipped;\n        }\n        if (!m) break;\n        pos += skipped + 1;\n        if (m[0] == \"\\t\") {\n          var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;\n          var txt = content.appendChild(elt(\"span\", spaceStr(tabWidth), \"cm-tab\"));\n          builder.col += tabWidth;\n        } else {\n          var txt = builder.cm.options.specialCharPlaceholder(m[0]);\n          if (ie && ie_version < 9) content.appendChild(elt(\"span\", [txt]));\n          else content.appendChild(txt);\n          builder.col += 1;\n        }\n        builder.map.push(builder.pos, builder.pos + 1, txt);\n        builder.pos++;\n      }\n    }\n    if (style || startStyle || endStyle || mustWrap) {\n      var fullStyle = style || \"\";\n      if (startStyle) fullStyle += startStyle;\n      if (endStyle) fullStyle += endStyle;\n      var token = elt(\"span\", [content], fullStyle);\n      if (title) token.title = title;\n      return builder.content.appendChild(token);\n    }\n    builder.content.appendChild(content);\n  }\n\n  function buildTokenSplitSpaces(inner) {\n    function split(old) {\n      var out = \" \";\n      for (var i = 0; i < old.length - 2; ++i) out += i % 2 ? \" \" : \"\\u00a0\";\n      out += \" \";\n      return out;\n    }\n    return function(builder, text, style, startStyle, endStyle, title) {\n      inner(builder, text.replace(/ {3,}/g, split), style, startStyle, endStyle, title);\n    };\n  }\n\n  // Work around nonsense dimensions being reported for stretches of\n  // right-to-left text.\n  function buildTokenBadBidi(inner, order) {\n    return function(builder, text, style, startStyle, endStyle, title) {\n      style = style ? style + \" cm-force-border\" : \"cm-force-border\";\n      var start = builder.pos, end = start + text.length;\n      for (;;) {\n        // Find the part that overlaps with the start of this text\n        for (var i = 0; i < order.length; i++) {\n          var part = order[i];\n          if (part.to > start && part.from <= start) break;\n        }\n        if (part.to >= end) return inner(builder, text, style, startStyle, endStyle, title);\n        inner(builder, text.slice(0, part.to - start), style, startStyle, null, title);\n        startStyle = null;\n        text = text.slice(part.to - start);\n        start = part.to;\n      }\n    };\n  }\n\n  function buildCollapsedSpan(builder, size, marker, ignoreWidget) {\n    var widget = !ignoreWidget && marker.widgetNode;\n    if (widget) {\n      builder.map.push(builder.pos, builder.pos + size, widget);\n      builder.content.appendChild(widget);\n    }\n    builder.pos += size;\n  }\n\n  // Outputs a number of spans to make up a line, taking highlighting\n  // and marked text into account.\n  function insertLineContent(line, builder, styles) {\n    var spans = line.markedSpans, allText = line.text, at = 0;\n    if (!spans) {\n      for (var i = 1; i < styles.length; i+=2)\n        builder.addToken(builder, allText.slice(at, at = styles[i]), interpretTokenStyle(styles[i+1], builder.cm.options));\n      return;\n    }\n\n    var len = allText.length, pos = 0, i = 1, text = \"\", style;\n    var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, title, collapsed;\n    for (;;) {\n      if (nextChange == pos) { // Update current marker set\n        spanStyle = spanEndStyle = spanStartStyle = title = \"\";\n        collapsed = null; nextChange = Infinity;\n        var foundBookmarks = [];\n        for (var j = 0; j < spans.length; ++j) {\n          var sp = spans[j], m = sp.marker;\n          if (sp.from <= pos && (sp.to == null || sp.to > pos)) {\n            if (sp.to != null && nextChange > sp.to) { nextChange = sp.to; spanEndStyle = \"\"; }\n            if (m.className) spanStyle += \" \" + m.className;\n            if (m.startStyle && sp.from == pos) spanStartStyle += \" \" + m.startStyle;\n            if (m.endStyle && sp.to == nextChange) spanEndStyle += \" \" + m.endStyle;\n            if (m.title && !title) title = m.title;\n            if (m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0))\n              collapsed = sp;\n          } else if (sp.from > pos && nextChange > sp.from) {\n            nextChange = sp.from;\n          }\n          if (m.type == \"bookmark\" && sp.from == pos && m.widgetNode) foundBookmarks.push(m);\n        }\n        if (collapsed && (collapsed.from || 0) == pos) {\n          buildCollapsedSpan(builder, (collapsed.to == null ? len + 1 : collapsed.to) - pos,\n                             collapsed.marker, collapsed.from == null);\n          if (collapsed.to == null) return;\n        }\n        if (!collapsed && foundBookmarks.length) for (var j = 0; j < foundBookmarks.length; ++j)\n          buildCollapsedSpan(builder, 0, foundBookmarks[j]);\n      }\n      if (pos >= len) break;\n\n      var upto = Math.min(len, nextChange);\n      while (true) {\n        if (text) {\n          var end = pos + text.length;\n          if (!collapsed) {\n            var tokenText = end > upto ? text.slice(0, upto - pos) : text;\n            builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle,\n                             spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : \"\", title);\n          }\n          if (end >= upto) {text = text.slice(upto - pos); pos = upto; break;}\n          pos = end;\n          spanStartStyle = \"\";\n        }\n        text = allText.slice(at, at = styles[i++]);\n        style = interpretTokenStyle(styles[i++], builder.cm.options);\n      }\n    }\n  }\n\n  // DOCUMENT DATA STRUCTURE\n\n  // By default, updates that start and end at the beginning of a line\n  // are treated specially, in order to make the association of line\n  // widgets and marker elements with the text behave more intuitive.\n  function isWholeLineUpdate(doc, change) {\n    return change.from.ch == 0 && change.to.ch == 0 && lst(change.text) == \"\" &&\n      (!doc.cm || doc.cm.options.wholeLineUpdateBefore);\n  }\n\n  // Perform a change on the document data structure.\n  function updateDoc(doc, change, markedSpans, estimateHeight) {\n    function spansFor(n) {return markedSpans ? markedSpans[n] : null;}\n    function update(line, text, spans) {\n      updateLine(line, text, spans, estimateHeight);\n      signalLater(line, \"change\", line, change);\n    }\n\n    var from = change.from, to = change.to, text = change.text;\n    var firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line);\n    var lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line;\n\n    // Adjust the line structure\n    if (isWholeLineUpdate(doc, change)) {\n      // This is a whole-line replace. Treated specially to make\n      // sure line objects move the way they are supposed to.\n      for (var i = 0, added = []; i < text.length - 1; ++i)\n        added.push(new Line(text[i], spansFor(i), estimateHeight));\n      update(lastLine, lastLine.text, lastSpans);\n      if (nlines) doc.remove(from.line, nlines);\n      if (added.length) doc.insert(from.line, added);\n    } else if (firstLine == lastLine) {\n      if (text.length == 1) {\n        update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);\n      } else {\n        for (var added = [], i = 1; i < text.length - 1; ++i)\n          added.push(new Line(text[i], spansFor(i), estimateHeight));\n        added.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight));\n        update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));\n        doc.insert(from.line + 1, added);\n      }\n    } else if (text.length == 1) {\n      update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));\n      doc.remove(from.line + 1, nlines);\n    } else {\n      update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));\n      update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);\n      for (var i = 1, added = []; i < text.length - 1; ++i)\n        added.push(new Line(text[i], spansFor(i), estimateHeight));\n      if (nlines > 1) doc.remove(from.line + 1, nlines - 1);\n      doc.insert(from.line + 1, added);\n    }\n\n    signalLater(doc, \"change\", doc, change);\n  }\n\n  // The document is represented as a BTree consisting of leaves, with\n  // chunk of lines in them, and branches, with up to ten leaves or\n  // other branch nodes below them. The top node is always a branch\n  // node, and is the document object itself (meaning it has\n  // additional methods and properties).\n  //\n  // All nodes have parent links. The tree is used both to go from\n  // line numbers to line objects, and to go from objects to numbers.\n  // It also indexes by height, and is used to convert between height\n  // and line object, and to find the total height of the document.\n  //\n  // See also http://marijnhaverbeke.nl/blog/codemirror-line-tree.html\n\n  function LeafChunk(lines) {\n    this.lines = lines;\n    this.parent = null;\n    for (var i = 0, height = 0; i < lines.length; ++i) {\n      lines[i].parent = this;\n      height += lines[i].height;\n    }\n    this.height = height;\n  }\n\n  LeafChunk.prototype = {\n    chunkSize: function() { return this.lines.length; },\n    // Remove the n lines at offset 'at'.\n    removeInner: function(at, n) {\n      for (var i = at, e = at + n; i < e; ++i) {\n        var line = this.lines[i];\n        this.height -= line.height;\n        cleanUpLine(line);\n        signalLater(line, \"delete\");\n      }\n      this.lines.splice(at, n);\n    },\n    // Helper used to collapse a small branch into a single leaf.\n    collapse: function(lines) {\n      lines.push.apply(lines, this.lines);\n    },\n    // Insert the given array of lines at offset 'at', count them as\n    // having the given height.\n    insertInner: function(at, lines, height) {\n      this.height += height;\n      this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));\n      for (var i = 0; i < lines.length; ++i) lines[i].parent = this;\n    },\n    // Used to iterate over a part of the tree.\n    iterN: function(at, n, op) {\n      for (var e = at + n; at < e; ++at)\n        if (op(this.lines[at])) return true;\n    }\n  };\n\n  function BranchChunk(children) {\n    this.children = children;\n    var size = 0, height = 0;\n    for (var i = 0; i < children.length; ++i) {\n      var ch = children[i];\n      size += ch.chunkSize(); height += ch.height;\n      ch.parent = this;\n    }\n    this.size = size;\n    this.height = height;\n    this.parent = null;\n  }\n\n  BranchChunk.prototype = {\n    chunkSize: function() { return this.size; },\n    removeInner: function(at, n) {\n      this.size -= n;\n      for (var i = 0; i < this.children.length; ++i) {\n        var child = this.children[i], sz = child.chunkSize();\n        if (at < sz) {\n          var rm = Math.min(n, sz - at), oldHeight = child.height;\n          child.removeInner(at, rm);\n          this.height -= oldHeight - child.height;\n          if (sz == rm) { this.children.splice(i--, 1); child.parent = null; }\n          if ((n -= rm) == 0) break;\n          at = 0;\n        } else at -= sz;\n      }\n      // If the result is smaller than 25 lines, ensure that it is a\n      // single leaf node.\n      if (this.size - n < 25 &&\n          (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {\n        var lines = [];\n        this.collapse(lines);\n        this.children = [new LeafChunk(lines)];\n        this.children[0].parent = this;\n      }\n    },\n    collapse: function(lines) {\n      for (var i = 0; i < this.children.length; ++i) this.children[i].collapse(lines);\n    },\n    insertInner: function(at, lines, height) {\n      this.size += lines.length;\n      this.height += height;\n      for (var i = 0; i < this.children.length; ++i) {\n        var child = this.children[i], sz = child.chunkSize();\n        if (at <= sz) {\n          child.insertInner(at, lines, height);\n          if (child.lines && child.lines.length > 50) {\n            while (child.lines.length > 50) {\n              var spilled = child.lines.splice(child.lines.length - 25, 25);\n              var newleaf = new LeafChunk(spilled);\n              child.height -= newleaf.height;\n              this.children.splice(i + 1, 0, newleaf);\n              newleaf.parent = this;\n            }\n            this.maybeSpill();\n          }\n          break;\n        }\n        at -= sz;\n      }\n    },\n    // When a node has grown, check whether it should be split.\n    maybeSpill: function() {\n      if (this.children.length <= 10) return;\n      var me = this;\n      do {\n        var spilled = me.children.splice(me.children.length - 5, 5);\n        var sibling = new BranchChunk(spilled);\n        if (!me.parent) { // Become the parent node\n          var copy = new BranchChunk(me.children);\n          copy.parent = me;\n          me.children = [copy, sibling];\n          me = copy;\n        } else {\n          me.size -= sibling.size;\n          me.height -= sibling.height;\n          var myIndex = indexOf(me.parent.children, me);\n          me.parent.children.splice(myIndex + 1, 0, sibling);\n        }\n        sibling.parent = me.parent;\n      } while (me.children.length > 10);\n      me.parent.maybeSpill();\n    },\n    iterN: function(at, n, op) {\n      for (var i = 0; i < this.children.length; ++i) {\n        var child = this.children[i], sz = child.chunkSize();\n        if (at < sz) {\n          var used = Math.min(n, sz - at);\n          if (child.iterN(at, used, op)) return true;\n          if ((n -= used) == 0) break;\n          at = 0;\n        } else at -= sz;\n      }\n    }\n  };\n\n  var nextDocId = 0;\n  var Doc = CodeMirror.Doc = function(text, mode, firstLine) {\n    if (!(this instanceof Doc)) return new Doc(text, mode, firstLine);\n    if (firstLine == null) firstLine = 0;\n\n    BranchChunk.call(this, [new LeafChunk([new Line(\"\", null)])]);\n    this.first = firstLine;\n    this.scrollTop = this.scrollLeft = 0;\n    this.cantEdit = false;\n    this.cleanGeneration = 1;\n    this.frontier = firstLine;\n    var start = Pos(firstLine, 0);\n    this.sel = simpleSelection(start);\n    this.history = new History(null);\n    this.id = ++nextDocId;\n    this.modeOption = mode;\n\n    if (typeof text == \"string\") text = splitLines(text);\n    updateDoc(this, {from: start, to: start, text: text});\n    setSelection(this, simpleSelection(start), sel_dontScroll);\n  };\n\n  Doc.prototype = createObj(BranchChunk.prototype, {\n    constructor: Doc,\n    // Iterate over the document. Supports two forms -- with only one\n    // argument, it calls that for each line in the document. With\n    // three, it iterates over the range given by the first two (with\n    // the second being non-inclusive).\n    iter: function(from, to, op) {\n      if (op) this.iterN(from - this.first, to - from, op);\n      else this.iterN(this.first, this.first + this.size, from);\n    },\n\n    // Non-public interface for adding and removing lines.\n    insert: function(at, lines) {\n      var height = 0;\n      for (var i = 0; i < lines.length; ++i) height += lines[i].height;\n      this.insertInner(at - this.first, lines, height);\n    },\n    remove: function(at, n) { this.removeInner(at - this.first, n); },\n\n    // From here, the methods are part of the public interface. Most\n    // are also available from CodeMirror (editor) instances.\n\n    getValue: function(lineSep) {\n      var lines = getLines(this, this.first, this.first + this.size);\n      if (lineSep === false) return lines;\n      return lines.join(lineSep || \"\\n\");\n    },\n    setValue: docMethodOp(function(code) {\n      var top = Pos(this.first, 0), last = this.first + this.size - 1;\n      makeChange(this, {from: top, to: Pos(last, getLine(this, last).text.length),\n                        text: splitLines(code), origin: \"setValue\"}, true);\n      setSelection(this, simpleSelection(top));\n    }),\n    replaceRange: function(code, from, to, origin) {\n      from = clipPos(this, from);\n      to = to ? clipPos(this, to) : from;\n      replaceRange(this, code, from, to, origin);\n    },\n    getRange: function(from, to, lineSep) {\n      var lines = getBetween(this, clipPos(this, from), clipPos(this, to));\n      if (lineSep === false) return lines;\n      return lines.join(lineSep || \"\\n\");\n    },\n\n    getLine: function(line) {var l = this.getLineHandle(line); return l && l.text;},\n\n    getLineHandle: function(line) {if (isLine(this, line)) return getLine(this, line);},\n    getLineNumber: function(line) {return lineNo(line);},\n\n    getLineHandleVisualStart: function(line) {\n      if (typeof line == \"number\") line = getLine(this, line);\n      return visualLine(line);\n    },\n\n    lineCount: function() {return this.size;},\n    firstLine: function() {return this.first;},\n    lastLine: function() {return this.first + this.size - 1;},\n\n    clipPos: function(pos) {return clipPos(this, pos);},\n\n    getCursor: function(start) {\n      var range = this.sel.primary(), pos;\n      if (start == null || start == \"head\") pos = range.head;\n      else if (start == \"anchor\") pos = range.anchor;\n      else if (start == \"end\" || start == \"to\" || start === false) pos = range.to();\n      else pos = range.from();\n      return pos;\n    },\n    listSelections: function() { return this.sel.ranges; },\n    somethingSelected: function() {return this.sel.somethingSelected();},\n\n    setCursor: docMethodOp(function(line, ch, options) {\n      setSimpleSelection(this, clipPos(this, typeof line == \"number\" ? Pos(line, ch || 0) : line), null, options);\n    }),\n    setSelection: docMethodOp(function(anchor, head, options) {\n      setSimpleSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), options);\n    }),\n    extendSelection: docMethodOp(function(head, other, options) {\n      extendSelection(this, clipPos(this, head), other && clipPos(this, other), options);\n    }),\n    extendSelections: docMethodOp(function(heads, options) {\n      extendSelections(this, clipPosArray(this, heads, options));\n    }),\n    extendSelectionsBy: docMethodOp(function(f, options) {\n      extendSelections(this, map(this.sel.ranges, f), options);\n    }),\n    setSelections: docMethodOp(function(ranges, primary, options) {\n      if (!ranges.length) return;\n      for (var i = 0, out = []; i < ranges.length; i++)\n        out[i] = new Range(clipPos(this, ranges[i].anchor),\n                           clipPos(this, ranges[i].head));\n      if (primary == null) primary = Math.min(ranges.length - 1, this.sel.primIndex);\n      setSelection(this, normalizeSelection(out, primary), options);\n    }),\n    addSelection: docMethodOp(function(anchor, head, options) {\n      var ranges = this.sel.ranges.slice(0);\n      ranges.push(new Range(clipPos(this, anchor), clipPos(this, head || anchor)));\n      setSelection(this, normalizeSelection(ranges, ranges.length - 1), options);\n    }),\n\n    getSelection: function(lineSep) {\n      var ranges = this.sel.ranges, lines;\n      for (var i = 0; i < ranges.length; i++) {\n        var sel = getBetween(this, ranges[i].from(), ranges[i].to());\n        lines = lines ? lines.concat(sel) : sel;\n      }\n      if (lineSep === false) return lines;\n      else return lines.join(lineSep || \"\\n\");\n    },\n    getSelections: function(lineSep) {\n      var parts = [], ranges = this.sel.ranges;\n      for (var i = 0; i < ranges.length; i++) {\n        var sel = getBetween(this, ranges[i].from(), ranges[i].to());\n        if (lineSep !== false) sel = sel.join(lineSep || \"\\n\");\n        parts[i] = sel;\n      }\n      return parts;\n    },\n    replaceSelection: function(code, collapse, origin) {\n      var dup = [];\n      for (var i = 0; i < this.sel.ranges.length; i++)\n        dup[i] = code;\n      this.replaceSelections(dup, collapse, origin || \"+input\");\n    },\n    replaceSelections: docMethodOp(function(code, collapse, origin) {\n      var changes = [], sel = this.sel;\n      for (var i = 0; i < sel.ranges.length; i++) {\n        var range = sel.ranges[i];\n        changes[i] = {from: range.from(), to: range.to(), text: splitLines(code[i]), origin: origin};\n      }\n      var newSel = collapse && collapse != \"end\" && computeReplacedSel(this, changes, collapse);\n      for (var i = changes.length - 1; i >= 0; i--)\n        makeChange(this, changes[i]);\n      if (newSel) setSelectionReplaceHistory(this, newSel);\n      else if (this.cm) ensureCursorVisible(this.cm);\n    }),\n    undo: docMethodOp(function() {makeChangeFromHistory(this, \"undo\");}),\n    redo: docMethodOp(function() {makeChangeFromHistory(this, \"redo\");}),\n    undoSelection: docMethodOp(function() {makeChangeFromHistory(this, \"undo\", true);}),\n    redoSelection: docMethodOp(function() {makeChangeFromHistory(this, \"redo\", true);}),\n\n    setExtending: function(val) {this.extend = val;},\n    getExtending: function() {return this.extend;},\n\n    historySize: function() {\n      var hist = this.history, done = 0, undone = 0;\n      for (var i = 0; i < hist.done.length; i++) if (!hist.done[i].ranges) ++done;\n      for (var i = 0; i < hist.undone.length; i++) if (!hist.undone[i].ranges) ++undone;\n      return {undo: done, redo: undone};\n    },\n    clearHistory: function() {this.history = new History(this.history.maxGeneration);},\n\n    markClean: function() {\n      this.cleanGeneration = this.changeGeneration(true);\n    },\n    changeGeneration: function(forceSplit) {\n      if (forceSplit)\n        this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null;\n      return this.history.generation;\n    },\n    isClean: function (gen) {\n      return this.history.generation == (gen || this.cleanGeneration);\n    },\n\n    getHistory: function() {\n      return {done: copyHistoryArray(this.history.done),\n              undone: copyHistoryArray(this.history.undone)};\n    },\n    setHistory: function(histData) {\n      var hist = this.history = new History(this.history.maxGeneration);\n      hist.done = copyHistoryArray(histData.done.slice(0), null, true);\n      hist.undone = copyHistoryArray(histData.undone.slice(0), null, true);\n    },\n\n    addLineClass: docMethodOp(function(handle, where, cls) {\n      return changeLine(this, handle, \"class\", function(line) {\n        var prop = where == \"text\" ? \"textClass\" : where == \"background\" ? \"bgClass\" : \"wrapClass\";\n        if (!line[prop]) line[prop] = cls;\n        else if (new RegExp(\"(?:^|\\\\s)\" + cls + \"(?:$|\\\\s)\").test(line[prop])) return false;\n        else line[prop] += \" \" + cls;\n        return true;\n      });\n    }),\n    removeLineClass: docMethodOp(function(handle, where, cls) {\n      return changeLine(this, handle, \"class\", function(line) {\n        var prop = where == \"text\" ? \"textClass\" : where == \"background\" ? \"bgClass\" : \"wrapClass\";\n        var cur = line[prop];\n        if (!cur) return false;\n        else if (cls == null) line[prop] = null;\n        else {\n          var found = cur.match(new RegExp(\"(?:^|\\\\s+)\" + cls + \"(?:$|\\\\s+)\"));\n          if (!found) return false;\n          var end = found.index + found[0].length;\n          line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? \"\" : \" \") + cur.slice(end) || null;\n        }\n        return true;\n      });\n    }),\n\n    markText: function(from, to, options) {\n      return markText(this, clipPos(this, from), clipPos(this, to), options, \"range\");\n    },\n    setBookmark: function(pos, options) {\n      var realOpts = {replacedWith: options && (options.nodeType == null ? options.widget : options),\n                      insertLeft: options && options.insertLeft,\n                      clearWhenEmpty: false, shared: options && options.shared};\n      pos = clipPos(this, pos);\n      return markText(this, pos, pos, realOpts, \"bookmark\");\n    },\n    findMarksAt: function(pos) {\n      pos = clipPos(this, pos);\n      var markers = [], spans = getLine(this, pos.line).markedSpans;\n      if (spans) for (var i = 0; i < spans.length; ++i) {\n        var span = spans[i];\n        if ((span.from == null || span.from <= pos.ch) &&\n            (span.to == null || span.to >= pos.ch))\n          markers.push(span.marker.parent || span.marker);\n      }\n      return markers;\n    },\n    findMarks: function(from, to, filter) {\n      from = clipPos(this, from); to = clipPos(this, to);\n      var found = [], lineNo = from.line;\n      this.iter(from.line, to.line + 1, function(line) {\n        var spans = line.markedSpans;\n        if (spans) for (var i = 0; i < spans.length; i++) {\n          var span = spans[i];\n          if (!(lineNo == from.line && from.ch > span.to ||\n                span.from == null && lineNo != from.line||\n                lineNo == to.line && span.from > to.ch) &&\n              (!filter || filter(span.marker)))\n            found.push(span.marker.parent || span.marker);\n        }\n        ++lineNo;\n      });\n      return found;\n    },\n    getAllMarks: function() {\n      var markers = [];\n      this.iter(function(line) {\n        var sps = line.markedSpans;\n        if (sps) for (var i = 0; i < sps.length; ++i)\n          if (sps[i].from != null) markers.push(sps[i].marker);\n      });\n      return markers;\n    },\n\n    posFromIndex: function(off) {\n      var ch, lineNo = this.first;\n      this.iter(function(line) {\n        var sz = line.text.length + 1;\n        if (sz > off) { ch = off; return true; }\n        off -= sz;\n        ++lineNo;\n      });\n      return clipPos(this, Pos(lineNo, ch));\n    },\n    indexFromPos: function (coords) {\n      coords = clipPos(this, coords);\n      var index = coords.ch;\n      if (coords.line < this.first || coords.ch < 0) return 0;\n      this.iter(this.first, coords.line, function (line) {\n        index += line.text.length + 1;\n      });\n      return index;\n    },\n\n    copy: function(copyHistory) {\n      var doc = new Doc(getLines(this, this.first, this.first + this.size), this.modeOption, this.first);\n      doc.scrollTop = this.scrollTop; doc.scrollLeft = this.scrollLeft;\n      doc.sel = this.sel;\n      doc.extend = false;\n      if (copyHistory) {\n        doc.history.undoDepth = this.history.undoDepth;\n        doc.setHistory(this.getHistory());\n      }\n      return doc;\n    },\n\n    linkedDoc: function(options) {\n      if (!options) options = {};\n      var from = this.first, to = this.first + this.size;\n      if (options.from != null && options.from > from) from = options.from;\n      if (options.to != null && options.to < to) to = options.to;\n      var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from);\n      if (options.sharedHist) copy.history = this.history;\n      (this.linked || (this.linked = [])).push({doc: copy, sharedHist: options.sharedHist});\n      copy.linked = [{doc: this, isParent: true, sharedHist: options.sharedHist}];\n      copySharedMarkers(copy, findSharedMarkers(this));\n      return copy;\n    },\n    unlinkDoc: function(other) {\n      if (other instanceof CodeMirror) other = other.doc;\n      if (this.linked) for (var i = 0; i < this.linked.length; ++i) {\n        var link = this.linked[i];\n        if (link.doc != other) continue;\n        this.linked.splice(i, 1);\n        other.unlinkDoc(this);\n        detachSharedMarkers(findSharedMarkers(this));\n        break;\n      }\n      // If the histories were shared, split them again\n      if (other.history == this.history) {\n        var splitIds = [other.id];\n        linkedDocs(other, function(doc) {splitIds.push(doc.id);}, true);\n        other.history = new History(null);\n        other.history.done = copyHistoryArray(this.history.done, splitIds);\n        other.history.undone = copyHistoryArray(this.history.undone, splitIds);\n      }\n    },\n    iterLinkedDocs: function(f) {linkedDocs(this, f);},\n\n    getMode: function() {return this.mode;},\n    getEditor: function() {return this.cm;}\n  });\n\n  // Public alias.\n  Doc.prototype.eachLine = Doc.prototype.iter;\n\n  // Set up methods on CodeMirror's prototype to redirect to the editor's document.\n  var dontDelegate = \"iter insert remove copy getEditor\".split(\" \");\n  for (var prop in Doc.prototype) if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0)\n    CodeMirror.prototype[prop] = (function(method) {\n      return function() {return method.apply(this.doc, arguments);};\n    })(Doc.prototype[prop]);\n\n  eventMixin(Doc);\n\n  // Call f for all linked documents.\n  function linkedDocs(doc, f, sharedHistOnly) {\n    function propagate(doc, skip, sharedHist) {\n      if (doc.linked) for (var i = 0; i < doc.linked.length; ++i) {\n        var rel = doc.linked[i];\n        if (rel.doc == skip) continue;\n        var shared = sharedHist && rel.sharedHist;\n        if (sharedHistOnly && !shared) continue;\n        f(rel.doc, shared);\n        propagate(rel.doc, doc, shared);\n      }\n    }\n    propagate(doc, null, true);\n  }\n\n  // Attach a document to an editor.\n  function attachDoc(cm, doc) {\n    if (doc.cm) throw new Error(\"This document is already in use.\");\n    cm.doc = doc;\n    doc.cm = cm;\n    estimateLineHeights(cm);\n    loadMode(cm);\n    if (!cm.options.lineWrapping) findMaxLine(cm);\n    cm.options.mode = doc.modeOption;\n    regChange(cm);\n  }\n\n  // LINE UTILITIES\n\n  // Find the line object corresponding to the given line number.\n  function getLine(doc, n) {\n    n -= doc.first;\n    if (n < 0 || n >= doc.size) throw new Error(\"There is no line \" + (n + doc.first) + \" in the document.\");\n    for (var chunk = doc; !chunk.lines;) {\n      for (var i = 0;; ++i) {\n        var child = chunk.children[i], sz = child.chunkSize();\n        if (n < sz) { chunk = child; break; }\n        n -= sz;\n      }\n    }\n    return chunk.lines[n];\n  }\n\n  // Get the part of a document between two positions, as an array of\n  // strings.\n  function getBetween(doc, start, end) {\n    var out = [], n = start.line;\n    doc.iter(start.line, end.line + 1, function(line) {\n      var text = line.text;\n      if (n == end.line) text = text.slice(0, end.ch);\n      if (n == start.line) text = text.slice(start.ch);\n      out.push(text);\n      ++n;\n    });\n    return out;\n  }\n  // Get the lines between from and to, as array of strings.\n  function getLines(doc, from, to) {\n    var out = [];\n    doc.iter(from, to, function(line) { out.push(line.text); });\n    return out;\n  }\n\n  // Update the height of a line, propagating the height change\n  // upwards to parent nodes.\n  function updateLineHeight(line, height) {\n    var diff = height - line.height;\n    if (diff) for (var n = line; n; n = n.parent) n.height += diff;\n  }\n\n  // Given a line object, find its line number by walking up through\n  // its parent links.\n  function lineNo(line) {\n    if (line.parent == null) return null;\n    var cur = line.parent, no = indexOf(cur.lines, line);\n    for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {\n      for (var i = 0;; ++i) {\n        if (chunk.children[i] == cur) break;\n        no += chunk.children[i].chunkSize();\n      }\n    }\n    return no + cur.first;\n  }\n\n  // Find the line at the given vertical position, using the height\n  // information in the document tree.\n  function lineAtHeight(chunk, h) {\n    var n = chunk.first;\n    outer: do {\n      for (var i = 0; i < chunk.children.length; ++i) {\n        var child = chunk.children[i], ch = child.height;\n        if (h < ch) { chunk = child; continue outer; }\n        h -= ch;\n        n += child.chunkSize();\n      }\n      return n;\n    } while (!chunk.lines);\n    for (var i = 0; i < chunk.lines.length; ++i) {\n      var line = chunk.lines[i], lh = line.height;\n      if (h < lh) break;\n      h -= lh;\n    }\n    return n + i;\n  }\n\n\n  // Find the height above the given line.\n  function heightAtLine(lineObj) {\n    lineObj = visualLine(lineObj);\n\n    var h = 0, chunk = lineObj.parent;\n    for (var i = 0; i < chunk.lines.length; ++i) {\n      var line = chunk.lines[i];\n      if (line == lineObj) break;\n      else h += line.height;\n    }\n    for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {\n      for (var i = 0; i < p.children.length; ++i) {\n        var cur = p.children[i];\n        if (cur == chunk) break;\n        else h += cur.height;\n      }\n    }\n    return h;\n  }\n\n  // Get the bidi ordering for the given line (and cache it). Returns\n  // false for lines that are fully left-to-right, and an array of\n  // BidiSpan objects otherwise.\n  function getOrder(line) {\n    var order = line.order;\n    if (order == null) order = line.order = bidiOrdering(line.text);\n    return order;\n  }\n\n  // HISTORY\n\n  function History(startGen) {\n    // Arrays of change events and selections. Doing something adds an\n    // event to done and clears undo. Undoing moves events from done\n    // to undone, redoing moves them in the other direction.\n    this.done = []; this.undone = [];\n    this.undoDepth = Infinity;\n    // Used to track when changes can be merged into a single undo\n    // event\n    this.lastModTime = this.lastSelTime = 0;\n    this.lastOp = this.lastSelOp = null;\n    this.lastOrigin = this.lastSelOrigin = null;\n    // Used by the isClean() method\n    this.generation = this.maxGeneration = startGen || 1;\n  }\n\n  // Create a history change event from an updateDoc-style change\n  // object.\n  function historyChangeFromChange(doc, change) {\n    var histChange = {from: copyPos(change.from), to: changeEnd(change), text: getBetween(doc, change.from, change.to)};\n    attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);\n    linkedDocs(doc, function(doc) {attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);}, true);\n    return histChange;\n  }\n\n  // Pop all selection events off the end of a history array. Stop at\n  // a change event.\n  function clearSelectionEvents(array) {\n    while (array.length) {\n      var last = lst(array);\n      if (last.ranges) array.pop();\n      else break;\n    }\n  }\n\n  // Find the top change event in the history. Pop off selection\n  // events that are in the way.\n  function lastChangeEvent(hist, force) {\n    if (force) {\n      clearSelectionEvents(hist.done);\n      return lst(hist.done);\n    } else if (hist.done.length && !lst(hist.done).ranges) {\n      return lst(hist.done);\n    } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {\n      hist.done.pop();\n      return lst(hist.done);\n    }\n  }\n\n  // Register a change in the history. Merges changes that are within\n  // a single operation, ore are close together with an origin that\n  // allows merging (starting with \"+\") into a single event.\n  function addChangeToHistory(doc, change, selAfter, opId) {\n    var hist = doc.history;\n    hist.undone.length = 0;\n    var time = +new Date, cur;\n\n    if ((hist.lastOp == opId ||\n         hist.lastOrigin == change.origin && change.origin &&\n         ((change.origin.charAt(0) == \"+\" && doc.cm && hist.lastModTime > time - doc.cm.options.historyEventDelay) ||\n          change.origin.charAt(0) == \"*\")) &&\n        (cur = lastChangeEvent(hist, hist.lastOp == opId))) {\n      // Merge this change into the last event\n      var last = lst(cur.changes);\n      if (cmp(change.from, change.to) == 0 && cmp(change.from, last.to) == 0) {\n        // Optimized case for simple insertion -- don't want to add\n        // new changesets for every character typed\n        last.to = changeEnd(change);\n      } else {\n        // Add new sub-event\n        cur.changes.push(historyChangeFromChange(doc, change));\n      }\n    } else {\n      // Can not be merged, start a new event.\n      var before = lst(hist.done);\n      if (!before || !before.ranges)\n        pushSelectionToHistory(doc.sel, hist.done);\n      cur = {changes: [historyChangeFromChange(doc, change)],\n             generation: hist.generation};\n      hist.done.push(cur);\n      while (hist.done.length > hist.undoDepth) {\n        hist.done.shift();\n        if (!hist.done[0].ranges) hist.done.shift();\n      }\n    }\n    hist.done.push(selAfter);\n    hist.generation = ++hist.maxGeneration;\n    hist.lastModTime = hist.lastSelTime = time;\n    hist.lastOp = hist.lastSelOp = opId;\n    hist.lastOrigin = hist.lastSelOrigin = change.origin;\n\n    if (!last) signal(doc, \"historyAdded\");\n  }\n\n  function selectionEventCanBeMerged(doc, origin, prev, sel) {\n    var ch = origin.charAt(0);\n    return ch == \"*\" ||\n      ch == \"+\" &&\n      prev.ranges.length == sel.ranges.length &&\n      prev.somethingSelected() == sel.somethingSelected() &&\n      new Date - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500);\n  }\n\n  // Called whenever the selection changes, sets the new selection as\n  // the pending selection in the history, and pushes the old pending\n  // selection into the 'done' array when it was significantly\n  // different (in number of selected ranges, emptiness, or time).\n  function addSelectionToHistory(doc, sel, opId, options) {\n    var hist = doc.history, origin = options && options.origin;\n\n    // A new event is started when the previous origin does not match\n    // the current, or the origins don't allow matching. Origins\n    // starting with * are always merged, those starting with + are\n    // merged when similar and close together in time.\n    if (opId == hist.lastSelOp ||\n        (origin && hist.lastSelOrigin == origin &&\n         (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin ||\n          selectionEventCanBeMerged(doc, origin, lst(hist.done), sel))))\n      hist.done[hist.done.length - 1] = sel;\n    else\n      pushSelectionToHistory(sel, hist.done);\n\n    hist.lastSelTime = +new Date;\n    hist.lastSelOrigin = origin;\n    hist.lastSelOp = opId;\n    if (options && options.clearRedo !== false)\n      clearSelectionEvents(hist.undone);\n  }\n\n  function pushSelectionToHistory(sel, dest) {\n    var top = lst(dest);\n    if (!(top && top.ranges && top.equals(sel)))\n      dest.push(sel);\n  }\n\n  // Used to store marked span information in the history.\n  function attachLocalSpans(doc, change, from, to) {\n    var existing = change[\"spans_\" + doc.id], n = 0;\n    doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function(line) {\n      if (line.markedSpans)\n        (existing || (existing = change[\"spans_\" + doc.id] = {}))[n] = line.markedSpans;\n      ++n;\n    });\n  }\n\n  // When un/re-doing restores text containing marked spans, those\n  // that have been explicitly cleared should not be restored.\n  function removeClearedSpans(spans) {\n    if (!spans) return null;\n    for (var i = 0, out; i < spans.length; ++i) {\n      if (spans[i].marker.explicitlyCleared) { if (!out) out = spans.slice(0, i); }\n      else if (out) out.push(spans[i]);\n    }\n    return !out ? spans : out.length ? out : null;\n  }\n\n  // Retrieve and filter the old marked spans stored in a change event.\n  function getOldSpans(doc, change) {\n    var found = change[\"spans_\" + doc.id];\n    if (!found) return null;\n    for (var i = 0, nw = []; i < change.text.length; ++i)\n      nw.push(removeClearedSpans(found[i]));\n    return nw;\n  }\n\n  // Used both to provide a JSON-safe object in .getHistory, and, when\n  // detaching a document, to split the history in two\n  function copyHistoryArray(events, newGroup, instantiateSel) {\n    for (var i = 0, copy = []; i < events.length; ++i) {\n      var event = events[i];\n      if (event.ranges) {\n        copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event);\n        continue;\n      }\n      var changes = event.changes, newChanges = [];\n      copy.push({changes: newChanges});\n      for (var j = 0; j < changes.length; ++j) {\n        var change = changes[j], m;\n        newChanges.push({from: change.from, to: change.to, text: change.text});\n        if (newGroup) for (var prop in change) if (m = prop.match(/^spans_(\\d+)$/)) {\n          if (indexOf(newGroup, Number(m[1])) > -1) {\n            lst(newChanges)[prop] = change[prop];\n            delete change[prop];\n          }\n        }\n      }\n    }\n    return copy;\n  }\n\n  // Rebasing/resetting history to deal with externally-sourced changes\n\n  function rebaseHistSelSingle(pos, from, to, diff) {\n    if (to < pos.line) {\n      pos.line += diff;\n    } else if (from < pos.line) {\n      pos.line = from;\n      pos.ch = 0;\n    }\n  }\n\n  // Tries to rebase an array of history events given a change in the\n  // document. If the change touches the same lines as the event, the\n  // event, and everything 'behind' it, is discarded. If the change is\n  // before the event, the event's positions are updated. Uses a\n  // copy-on-write scheme for the positions, to avoid having to\n  // reallocate them all on every rebase, but also avoid problems with\n  // shared position objects being unsafely updated.\n  function rebaseHistArray(array, from, to, diff) {\n    for (var i = 0; i < array.length; ++i) {\n      var sub = array[i], ok = true;\n      if (sub.ranges) {\n        if (!sub.copied) { sub = array[i] = sub.deepCopy(); sub.copied = true; }\n        for (var j = 0; j < sub.ranges.length; j++) {\n          rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff);\n          rebaseHistSelSingle(sub.ranges[j].head, from, to, diff);\n        }\n        continue;\n      }\n      for (var j = 0; j < sub.changes.length; ++j) {\n        var cur = sub.changes[j];\n        if (to < cur.from.line) {\n          cur.from = Pos(cur.from.line + diff, cur.from.ch);\n          cur.to = Pos(cur.to.line + diff, cur.to.ch);\n        } else if (from <= cur.to.line) {\n          ok = false;\n          break;\n        }\n      }\n      if (!ok) {\n        array.splice(0, i + 1);\n        i = 0;\n      }\n    }\n  }\n\n  function rebaseHist(hist, change) {\n    var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1;\n    rebaseHistArray(hist.done, from, to, diff);\n    rebaseHistArray(hist.undone, from, to, diff);\n  }\n\n  // EVENT UTILITIES\n\n  // Due to the fact that we still support jurassic IE versions, some\n  // compatibility wrappers are needed.\n\n  var e_preventDefault = CodeMirror.e_preventDefault = function(e) {\n    if (e.preventDefault) e.preventDefault();\n    else e.returnValue = false;\n  };\n  var e_stopPropagation = CodeMirror.e_stopPropagation = function(e) {\n    if (e.stopPropagation) e.stopPropagation();\n    else e.cancelBubble = true;\n  };\n  function e_defaultPrevented(e) {\n    return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false;\n  }\n  var e_stop = CodeMirror.e_stop = function(e) {e_preventDefault(e); e_stopPropagation(e);};\n\n  function e_target(e) {return e.target || e.srcElement;}\n  function e_button(e) {\n    var b = e.which;\n    if (b == null) {\n      if (e.button & 1) b = 1;\n      else if (e.button & 2) b = 3;\n      else if (e.button & 4) b = 2;\n    }\n    if (mac && e.ctrlKey && b == 1) b = 3;\n    return b;\n  }\n\n  // EVENT HANDLING\n\n  // Lightweight event framework. on/off also work on DOM nodes,\n  // registering native DOM handlers.\n\n  var on = CodeMirror.on = function(emitter, type, f) {\n    if (emitter.addEventListener)\n      emitter.addEventListener(type, f, false);\n    else if (emitter.attachEvent)\n      emitter.attachEvent(\"on\" + type, f);\n    else {\n      var map = emitter._handlers || (emitter._handlers = {});\n      var arr = map[type] || (map[type] = []);\n      arr.push(f);\n    }\n  };\n\n  var off = CodeMirror.off = function(emitter, type, f) {\n    if (emitter.removeEventListener)\n      emitter.removeEventListener(type, f, false);\n    else if (emitter.detachEvent)\n      emitter.detachEvent(\"on\" + type, f);\n    else {\n      var arr = emitter._handlers && emitter._handlers[type];\n      if (!arr) return;\n      for (var i = 0; i < arr.length; ++i)\n        if (arr[i] == f) { arr.splice(i, 1); break; }\n    }\n  };\n\n  var signal = CodeMirror.signal = function(emitter, type /*, values...*/) {\n    var arr = emitter._handlers && emitter._handlers[type];\n    if (!arr) return;\n    var args = Array.prototype.slice.call(arguments, 2);\n    for (var i = 0; i < arr.length; ++i) arr[i].apply(null, args);\n  };\n\n  var orphanDelayedCallbacks = null;\n\n  // Often, we want to signal events at a point where we are in the\n  // middle of some work, but don't want the handler to start calling\n  // other methods on the editor, which might be in an inconsistent\n  // state or simply not expect any other events to happen.\n  // signalLater looks whether there are any handlers, and schedules\n  // them to be executed when the last operation ends, or, if no\n  // operation is active, when a timeout fires.\n  function signalLater(emitter, type /*, values...*/) {\n    var arr = emitter._handlers && emitter._handlers[type];\n    if (!arr) return;\n    var args = Array.prototype.slice.call(arguments, 2), list;\n    if (operationGroup) {\n      list = operationGroup.delayedCallbacks;\n    } else if (orphanDelayedCallbacks) {\n      list = orphanDelayedCallbacks;\n    } else {\n      list = orphanDelayedCallbacks = [];\n      setTimeout(fireOrphanDelayed, 0);\n    }\n    function bnd(f) {return function(){f.apply(null, args);};};\n    for (var i = 0; i < arr.length; ++i)\n      list.push(bnd(arr[i]));\n  }\n\n  function fireOrphanDelayed() {\n    var delayed = orphanDelayedCallbacks;\n    orphanDelayedCallbacks = null;\n    for (var i = 0; i < delayed.length; ++i) delayed[i]();\n  }\n\n  // The DOM events that CodeMirror handles can be overridden by\n  // registering a (non-DOM) handler on the editor for the event name,\n  // and preventDefault-ing the event in that handler.\n  function signalDOMEvent(cm, e, override) {\n    signal(cm, override || e.type, cm, e);\n    return e_defaultPrevented(e) || e.codemirrorIgnore;\n  }\n\n  function signalCursorActivity(cm) {\n    var arr = cm._handlers && cm._handlers.cursorActivity;\n    if (!arr) return;\n    var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []);\n    for (var i = 0; i < arr.length; ++i) if (indexOf(set, arr[i]) == -1)\n      set.push(arr[i]);\n  }\n\n  function hasHandler(emitter, type) {\n    var arr = emitter._handlers && emitter._handlers[type];\n    return arr && arr.length > 0;\n  }\n\n  // Add on and off methods to a constructor's prototype, to make\n  // registering events on such objects more convenient.\n  function eventMixin(ctor) {\n    ctor.prototype.on = function(type, f) {on(this, type, f);};\n    ctor.prototype.off = function(type, f) {off(this, type, f);};\n  }\n\n  // MISC UTILITIES\n\n  // Number of pixels added to scroller and sizer to hide scrollbar\n  var scrollerCutOff = 30;\n\n  // Returned or thrown by various protocols to signal 'I'm not\n  // handling this'.\n  var Pass = CodeMirror.Pass = {toString: function(){return \"CodeMirror.Pass\";}};\n\n  // Reused option objects for setSelection & friends\n  var sel_dontScroll = {scroll: false}, sel_mouse = {origin: \"*mouse\"}, sel_move = {origin: \"+move\"};\n\n  function Delayed() {this.id = null;}\n  Delayed.prototype.set = function(ms, f) {\n    clearTimeout(this.id);\n    this.id = setTimeout(f, ms);\n  };\n\n  // Counts the column offset in a string, taking tabs into account.\n  // Used mostly to find indentation.\n  var countColumn = CodeMirror.countColumn = function(string, end, tabSize, startIndex, startValue) {\n    if (end == null) {\n      end = string.search(/[^\\s\\u00a0]/);\n      if (end == -1) end = string.length;\n    }\n    for (var i = startIndex || 0, n = startValue || 0;;) {\n      var nextTab = string.indexOf(\"\\t\", i);\n      if (nextTab < 0 || nextTab >= end)\n        return n + (end - i);\n      n += nextTab - i;\n      n += tabSize - (n % tabSize);\n      i = nextTab + 1;\n    }\n  };\n\n  // The inverse of countColumn -- find the offset that corresponds to\n  // a particular column.\n  function findColumn(string, goal, tabSize) {\n    for (var pos = 0, col = 0;;) {\n      var nextTab = string.indexOf(\"\\t\", pos);\n      if (nextTab == -1) nextTab = string.length;\n      var skipped = nextTab - pos;\n      if (nextTab == string.length || col + skipped >= goal)\n        return pos + Math.min(skipped, goal - col);\n      col += nextTab - pos;\n      col += tabSize - (col % tabSize);\n      pos = nextTab + 1;\n      if (col >= goal) return pos;\n    }\n  }\n\n  var spaceStrs = [\"\"];\n  function spaceStr(n) {\n    while (spaceStrs.length <= n)\n      spaceStrs.push(lst(spaceStrs) + \" \");\n    return spaceStrs[n];\n  }\n\n  function lst(arr) { return arr[arr.length-1]; }\n\n  var selectInput = function(node) { node.select(); };\n  if (ios) // Mobile Safari apparently has a bug where select() is broken.\n    selectInput = function(node) { node.selectionStart = 0; node.selectionEnd = node.value.length; };\n  else if (ie) // Suppress mysterious IE10 errors\n    selectInput = function(node) { try { node.select(); } catch(_e) {} };\n\n  function indexOf(array, elt) {\n    for (var i = 0; i < array.length; ++i)\n      if (array[i] == elt) return i;\n    return -1;\n  }\n  if ([].indexOf) indexOf = function(array, elt) { return array.indexOf(elt); };\n  function map(array, f) {\n    var out = [];\n    for (var i = 0; i < array.length; i++) out[i] = f(array[i], i);\n    return out;\n  }\n  if ([].map) map = function(array, f) { return array.map(f); };\n\n  function createObj(base, props) {\n    var inst;\n    if (Object.create) {\n      inst = Object.create(base);\n    } else {\n      var ctor = function() {};\n      ctor.prototype = base;\n      inst = new ctor();\n    }\n    if (props) copyObj(props, inst);\n    return inst;\n  };\n\n  function copyObj(obj, target, overwrite) {\n    if (!target) target = {};\n    for (var prop in obj)\n      if (obj.hasOwnProperty(prop) && (overwrite !== false || !target.hasOwnProperty(prop)))\n        target[prop] = obj[prop];\n    return target;\n  }\n\n  function bind(f) {\n    var args = Array.prototype.slice.call(arguments, 1);\n    return function(){return f.apply(null, args);};\n  }\n\n  var nonASCIISingleCaseWordChar = /[\\u00df\\u0590-\\u05f4\\u0600-\\u06ff\\u3040-\\u309f\\u30a0-\\u30ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\uac00-\\ud7af]/;\n  var isWordCharBasic = CodeMirror.isWordChar = function(ch) {\n    return /\\w/.test(ch) || ch > \"\\x80\" &&\n      (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch));\n  };\n  function isWordChar(ch, helper) {\n    if (!helper) return isWordCharBasic(ch);\n    if (helper.source.indexOf(\"\\\\w\") > -1 && isWordCharBasic(ch)) return true;\n    return helper.test(ch);\n  }\n\n  function isEmpty(obj) {\n    for (var n in obj) if (obj.hasOwnProperty(n) && obj[n]) return false;\n    return true;\n  }\n\n  // Extending unicode characters. A series of a non-extending char +\n  // any number of extending chars is treated as a single unit as far\n  // as editing and measuring is concerned. This is not fully correct,\n  // since some scripts/fonts/browsers also treat other configurations\n  // of code points as a group.\n  var extendingChars = /[\\u0300-\\u036f\\u0483-\\u0489\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u065e\\u0670\\u06d6-\\u06dc\\u06de-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07eb-\\u07f3\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0900-\\u0902\\u093c\\u0941-\\u0948\\u094d\\u0951-\\u0955\\u0962\\u0963\\u0981\\u09bc\\u09be\\u09c1-\\u09c4\\u09cd\\u09d7\\u09e2\\u09e3\\u0a01\\u0a02\\u0a3c\\u0a41\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a70\\u0a71\\u0a75\\u0a81\\u0a82\\u0abc\\u0ac1-\\u0ac5\\u0ac7\\u0ac8\\u0acd\\u0ae2\\u0ae3\\u0b01\\u0b3c\\u0b3e\\u0b3f\\u0b41-\\u0b44\\u0b4d\\u0b56\\u0b57\\u0b62\\u0b63\\u0b82\\u0bbe\\u0bc0\\u0bcd\\u0bd7\\u0c3e-\\u0c40\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0cbc\\u0cbf\\u0cc2\\u0cc6\\u0ccc\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0d3e\\u0d41-\\u0d44\\u0d4d\\u0d57\\u0d62\\u0d63\\u0dca\\u0dcf\\u0dd2-\\u0dd4\\u0dd6\\u0ddf\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0eb1\\u0eb4-\\u0eb9\\u0ebb\\u0ebc\\u0ec8-\\u0ecd\\u0f18\\u0f19\\u0f35\\u0f37\\u0f39\\u0f71-\\u0f7e\\u0f80-\\u0f84\\u0f86\\u0f87\\u0f90-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102d-\\u1030\\u1032-\\u1037\\u1039\\u103a\\u103d\\u103e\\u1058\\u1059\\u105e-\\u1060\\u1071-\\u1074\\u1082\\u1085\\u1086\\u108d\\u109d\\u135f\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b7-\\u17bd\\u17c6\\u17c9-\\u17d3\\u17dd\\u180b-\\u180d\\u18a9\\u1920-\\u1922\\u1927\\u1928\\u1932\\u1939-\\u193b\\u1a17\\u1a18\\u1a56\\u1a58-\\u1a5e\\u1a60\\u1a62\\u1a65-\\u1a6c\\u1a73-\\u1a7c\\u1a7f\\u1b00-\\u1b03\\u1b34\\u1b36-\\u1b3a\\u1b3c\\u1b42\\u1b6b-\\u1b73\\u1b80\\u1b81\\u1ba2-\\u1ba5\\u1ba8\\u1ba9\\u1c2c-\\u1c33\\u1c36\\u1c37\\u1cd0-\\u1cd2\\u1cd4-\\u1ce0\\u1ce2-\\u1ce8\\u1ced\\u1dc0-\\u1de6\\u1dfd-\\u1dff\\u200c\\u200d\\u20d0-\\u20f0\\u2cef-\\u2cf1\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\ua66f-\\ua672\\ua67c\\ua67d\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua825\\ua826\\ua8c4\\ua8e0-\\ua8f1\\ua926-\\ua92d\\ua947-\\ua951\\ua980-\\ua982\\ua9b3\\ua9b6-\\ua9b9\\ua9bc\\uaa29-\\uaa2e\\uaa31\\uaa32\\uaa35\\uaa36\\uaa43\\uaa4c\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uabe5\\uabe8\\uabed\\udc00-\\udfff\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe26\\uff9e\\uff9f]/;\n  function isExtendingChar(ch) { return ch.charCodeAt(0) >= 768 && extendingChars.test(ch); }\n\n  // DOM UTILITIES\n\n  function elt(tag, content, className, style) {\n    var e = document.createElement(tag);\n    if (className) e.className = className;\n    if (style) e.style.cssText = style;\n    if (typeof content == \"string\") e.appendChild(document.createTextNode(content));\n    else if (content) for (var i = 0; i < content.length; ++i) e.appendChild(content[i]);\n    return e;\n  }\n\n  var range;\n  if (document.createRange) range = function(node, start, end) {\n    var r = document.createRange();\n    r.setEnd(node, end);\n    r.setStart(node, start);\n    return r;\n  };\n  else range = function(node, start, end) {\n    var r = document.body.createTextRange();\n    r.moveToElementText(node.parentNode);\n    r.collapse(true);\n    r.moveEnd(\"character\", end);\n    r.moveStart(\"character\", start);\n    return r;\n  };\n\n  function removeChildren(e) {\n    for (var count = e.childNodes.length; count > 0; --count)\n      e.removeChild(e.firstChild);\n    return e;\n  }\n\n  function removeChildrenAndAdd(parent, e) {\n    return removeChildren(parent).appendChild(e);\n  }\n\n  function contains(parent, child) {\n    if (parent.contains)\n      return parent.contains(child);\n    while (child = child.parentNode)\n      if (child == parent) return true;\n  }\n\n  function activeElt() { return document.activeElement; }\n  // Older versions of IE throws unspecified error when touching\n  // document.activeElement in some cases (during loading, in iframe)\n  if (ie && ie_version < 11) activeElt = function() {\n    try { return document.activeElement; }\n    catch(e) { return document.body; }\n  };\n\n  function classTest(cls) { return new RegExp(\"\\\\b\" + cls + \"\\\\b\\\\s*\"); }\n  function rmClass(node, cls) {\n    var test = classTest(cls);\n    if (test.test(node.className)) node.className = node.className.replace(test, \"\");\n  }\n  function addClass(node, cls) {\n    if (!classTest(cls).test(node.className)) node.className += \" \" + cls;\n  }\n  function joinClasses(a, b) {\n    var as = a.split(\" \");\n    for (var i = 0; i < as.length; i++)\n      if (as[i] && !classTest(as[i]).test(b)) b += \" \" + as[i];\n    return b;\n  }\n\n  // WINDOW-WIDE EVENTS\n\n  // These must be handled carefully, because naively registering a\n  // handler for each editor will cause the editors to never be\n  // garbage collected.\n\n  function forEachCodeMirror(f) {\n    if (!document.body.getElementsByClassName) return;\n    var byClass = document.body.getElementsByClassName(\"CodeMirror\");\n    for (var i = 0; i < byClass.length; i++) {\n      var cm = byClass[i].CodeMirror;\n      if (cm) f(cm);\n    }\n  }\n\n  var globalsRegistered = false;\n  function ensureGlobalHandlers() {\n    if (globalsRegistered) return;\n    registerGlobalHandlers();\n    globalsRegistered = true;\n  }\n  function registerGlobalHandlers() {\n    // When the window resizes, we need to refresh active editors.\n    var resizeTimer;\n    on(window, \"resize\", function() {\n      if (resizeTimer == null) resizeTimer = setTimeout(function() {\n        resizeTimer = null;\n        knownScrollbarWidth = null;\n        forEachCodeMirror(onResize);\n      }, 100);\n    });\n    // When the window loses focus, we want to show the editor as blurred\n    on(window, \"blur\", function() {\n      forEachCodeMirror(onBlur);\n    });\n  }\n\n  // FEATURE DETECTION\n\n  // Detect drag-and-drop\n  var dragAndDrop = function() {\n    // There is *some* kind of drag-and-drop support in IE6-8, but I\n    // couldn't get it to work yet.\n    if (ie && ie_version < 9) return false;\n    var div = elt('div');\n    return \"draggable\" in div || \"dragDrop\" in div;\n  }();\n\n  var knownScrollbarWidth;\n  function scrollbarWidth(measure) {\n    if (knownScrollbarWidth != null) return knownScrollbarWidth;\n    var test = elt(\"div\", null, null, \"width: 50px; height: 50px; overflow-x: scroll\");\n    removeChildrenAndAdd(measure, test);\n    if (test.offsetWidth)\n      knownScrollbarWidth = test.offsetHeight - test.clientHeight;\n    return knownScrollbarWidth || 0;\n  }\n\n  var zwspSupported;\n  function zeroWidthElement(measure) {\n    if (zwspSupported == null) {\n      var test = elt(\"span\", \"\\u200b\");\n      removeChildrenAndAdd(measure, elt(\"span\", [test, document.createTextNode(\"x\")]));\n      if (measure.firstChild.offsetHeight != 0)\n        zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !(ie && ie_version < 8);\n    }\n    if (zwspSupported) return elt(\"span\", \"\\u200b\");\n    else return elt(\"span\", \"\\u00a0\", null, \"display: inline-block; width: 1px; margin-right: -1px\");\n  }\n\n  // Feature-detect IE's crummy client rect reporting for bidi text\n  var badBidiRects;\n  function hasBadBidiRects(measure) {\n    if (badBidiRects != null) return badBidiRects;\n    var txt = removeChildrenAndAdd(measure, document.createTextNode(\"A\\u062eA\"));\n    var r0 = range(txt, 0, 1).getBoundingClientRect();\n    if (!r0 || r0.left == r0.right) return false; // Safari returns null in some cases (#2780)\n    var r1 = range(txt, 1, 2).getBoundingClientRect();\n    return badBidiRects = (r1.right - r0.right < 3);\n  }\n\n  // See if \"\".split is the broken IE version, if so, provide an\n  // alternative way to split lines.\n  var splitLines = CodeMirror.splitLines = \"\\n\\nb\".split(/\\n/).length != 3 ? function(string) {\n    var pos = 0, result = [], l = string.length;\n    while (pos <= l) {\n      var nl = string.indexOf(\"\\n\", pos);\n      if (nl == -1) nl = string.length;\n      var line = string.slice(pos, string.charAt(nl - 1) == \"\\r\" ? nl - 1 : nl);\n      var rt = line.indexOf(\"\\r\");\n      if (rt != -1) {\n        result.push(line.slice(0, rt));\n        pos += rt + 1;\n      } else {\n        result.push(line);\n        pos = nl + 1;\n      }\n    }\n    return result;\n  } : function(string){return string.split(/\\r\\n?|\\n/);};\n\n  var hasSelection = window.getSelection ? function(te) {\n    try { return te.selectionStart != te.selectionEnd; }\n    catch(e) { return false; }\n  } : function(te) {\n    try {var range = te.ownerDocument.selection.createRange();}\n    catch(e) {}\n    if (!range || range.parentElement() != te) return false;\n    return range.compareEndPoints(\"StartToEnd\", range) != 0;\n  };\n\n  var hasCopyEvent = (function() {\n    var e = elt(\"div\");\n    if (\"oncopy\" in e) return true;\n    e.setAttribute(\"oncopy\", \"return;\");\n    return typeof e.oncopy == \"function\";\n  })();\n\n  var badZoomedRects = null;\n  function hasBadZoomedRects(measure) {\n    if (badZoomedRects != null) return badZoomedRects;\n    var node = removeChildrenAndAdd(measure, elt(\"span\", \"x\"));\n    var normal = node.getBoundingClientRect();\n    var fromRange = range(node, 0, 1).getBoundingClientRect();\n    return badZoomedRects = Math.abs(normal.left - fromRange.left) > 1;\n  }\n\n  // KEY NAMES\n\n  var keyNames = {3: \"Enter\", 8: \"Backspace\", 9: \"Tab\", 13: \"Enter\", 16: \"Shift\", 17: \"Ctrl\", 18: \"Alt\",\n                  19: \"Pause\", 20: \"CapsLock\", 27: \"Esc\", 32: \"Space\", 33: \"PageUp\", 34: \"PageDown\", 35: \"End\",\n                  36: \"Home\", 37: \"Left\", 38: \"Up\", 39: \"Right\", 40: \"Down\", 44: \"PrintScrn\", 45: \"Insert\",\n                  46: \"Delete\", 59: \";\", 61: \"=\", 91: \"Mod\", 92: \"Mod\", 93: \"Mod\", 107: \"=\", 109: \"-\", 127: \"Delete\",\n                  173: \"-\", 186: \";\", 187: \"=\", 188: \",\", 189: \"-\", 190: \".\", 191: \"/\", 192: \"`\", 219: \"[\", 220: \"\\\\\",\n                  221: \"]\", 222: \"'\", 63232: \"Up\", 63233: \"Down\", 63234: \"Left\", 63235: \"Right\", 63272: \"Delete\",\n                  63273: \"Home\", 63275: \"End\", 63276: \"PageUp\", 63277: \"PageDown\", 63302: \"Insert\"};\n  CodeMirror.keyNames = keyNames;\n  (function() {\n    // Number keys\n    for (var i = 0; i < 10; i++) keyNames[i + 48] = keyNames[i + 96] = String(i);\n    // Alphabetic keys\n    for (var i = 65; i <= 90; i++) keyNames[i] = String.fromCharCode(i);\n    // Function keys\n    for (var i = 1; i <= 12; i++) keyNames[i + 111] = keyNames[i + 63235] = \"F\" + i;\n  })();\n\n  // BIDI HELPERS\n\n  function iterateBidiSections(order, from, to, f) {\n    if (!order) return f(from, to, \"ltr\");\n    var found = false;\n    for (var i = 0; i < order.length; ++i) {\n      var part = order[i];\n      if (part.from < to && part.to > from || from == to && part.to == from) {\n        f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? \"rtl\" : \"ltr\");\n        found = true;\n      }\n    }\n    if (!found) f(from, to, \"ltr\");\n  }\n\n  function bidiLeft(part) { return part.level % 2 ? part.to : part.from; }\n  function bidiRight(part) { return part.level % 2 ? part.from : part.to; }\n\n  function lineLeft(line) { var order = getOrder(line); return order ? bidiLeft(order[0]) : 0; }\n  function lineRight(line) {\n    var order = getOrder(line);\n    if (!order) return line.text.length;\n    return bidiRight(lst(order));\n  }\n\n  function lineStart(cm, lineN) {\n    var line = getLine(cm.doc, lineN);\n    var visual = visualLine(line);\n    if (visual != line) lineN = lineNo(visual);\n    var order = getOrder(visual);\n    var ch = !order ? 0 : order[0].level % 2 ? lineRight(visual) : lineLeft(visual);\n    return Pos(lineN, ch);\n  }\n  function lineEnd(cm, lineN) {\n    var merged, line = getLine(cm.doc, lineN);\n    while (merged = collapsedSpanAtEnd(line)) {\n      line = merged.find(1, true).line;\n      lineN = null;\n    }\n    var order = getOrder(line);\n    var ch = !order ? line.text.length : order[0].level % 2 ? lineLeft(line) : lineRight(line);\n    return Pos(lineN == null ? lineNo(line) : lineN, ch);\n  }\n  function lineStartSmart(cm, pos) {\n    var start = lineStart(cm, pos.line);\n    var line = getLine(cm.doc, start.line);\n    var order = getOrder(line);\n    if (!order || order[0].level == 0) {\n      var firstNonWS = Math.max(0, line.text.search(/\\S/));\n      var inWS = pos.line == start.line && pos.ch <= firstNonWS && pos.ch;\n      return Pos(start.line, inWS ? 0 : firstNonWS);\n    }\n    return start;\n  }\n\n  function compareBidiLevel(order, a, b) {\n    var linedir = order[0].level;\n    if (a == linedir) return true;\n    if (b == linedir) return false;\n    return a < b;\n  }\n  var bidiOther;\n  function getBidiPartAt(order, pos) {\n    bidiOther = null;\n    for (var i = 0, found; i < order.length; ++i) {\n      var cur = order[i];\n      if (cur.from < pos && cur.to > pos) return i;\n      if ((cur.from == pos || cur.to == pos)) {\n        if (found == null) {\n          found = i;\n        } else if (compareBidiLevel(order, cur.level, order[found].level)) {\n          if (cur.from != cur.to) bidiOther = found;\n          return i;\n        } else {\n          if (cur.from != cur.to) bidiOther = i;\n          return found;\n        }\n      }\n    }\n    return found;\n  }\n\n  function moveInLine(line, pos, dir, byUnit) {\n    if (!byUnit) return pos + dir;\n    do pos += dir;\n    while (pos > 0 && isExtendingChar(line.text.charAt(pos)));\n    return pos;\n  }\n\n  // This is needed in order to move 'visually' through bi-directional\n  // text -- i.e., pressing left should make the cursor go left, even\n  // when in RTL text. The tricky part is the 'jumps', where RTL and\n  // LTR text touch each other. This often requires the cursor offset\n  // to move more than one unit, in order to visually move one unit.\n  function moveVisually(line, start, dir, byUnit) {\n    var bidi = getOrder(line);\n    if (!bidi) return moveLogically(line, start, dir, byUnit);\n    var pos = getBidiPartAt(bidi, start), part = bidi[pos];\n    var target = moveInLine(line, start, part.level % 2 ? -dir : dir, byUnit);\n\n    for (;;) {\n      if (target > part.from && target < part.to) return target;\n      if (target == part.from || target == part.to) {\n        if (getBidiPartAt(bidi, target) == pos) return target;\n        part = bidi[pos += dir];\n        return (dir > 0) == part.level % 2 ? part.to : part.from;\n      } else {\n        part = bidi[pos += dir];\n        if (!part) return null;\n        if ((dir > 0) == part.level % 2)\n          target = moveInLine(line, part.to, -1, byUnit);\n        else\n          target = moveInLine(line, part.from, 1, byUnit);\n      }\n    }\n  }\n\n  function moveLogically(line, start, dir, byUnit) {\n    var target = start + dir;\n    if (byUnit) while (target > 0 && isExtendingChar(line.text.charAt(target))) target += dir;\n    return target < 0 || target > line.text.length ? null : target;\n  }\n\n  // Bidirectional ordering algorithm\n  // See http://unicode.org/reports/tr9/tr9-13.html for the algorithm\n  // that this (partially) implements.\n\n  // One-char codes used for character types:\n  // L (L):   Left-to-Right\n  // R (R):   Right-to-Left\n  // r (AL):  Right-to-Left Arabic\n  // 1 (EN):  European Number\n  // + (ES):  European Number Separator\n  // % (ET):  European Number Terminator\n  // n (AN):  Arabic Number\n  // , (CS):  Common Number Separator\n  // m (NSM): Non-Spacing Mark\n  // b (BN):  Boundary Neutral\n  // s (B):   Paragraph Separator\n  // t (S):   Segment Separator\n  // w (WS):  Whitespace\n  // N (ON):  Other Neutrals\n\n  // Returns null if characters are ordered as they appear\n  // (left-to-right), or an array of sections ({from, to, level}\n  // objects) in the order in which they occur visually.\n  var bidiOrdering = (function() {\n    // Character types for codepoints 0 to 0xff\n    var lowTypes = \"bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN\";\n    // Character types for codepoints 0x600 to 0x6ff\n    var arabicTypes = \"rrrrrrrrrrrr,rNNmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmrrrrrrrnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmNmmmm\";\n    function charType(code) {\n      if (code <= 0xf7) return lowTypes.charAt(code);\n      else if (0x590 <= code && code <= 0x5f4) return \"R\";\n      else if (0x600 <= code && code <= 0x6ed) return arabicTypes.charAt(code - 0x600);\n      else if (0x6ee <= code && code <= 0x8ac) return \"r\";\n      else if (0x2000 <= code && code <= 0x200b) return \"w\";\n      else if (code == 0x200c) return \"b\";\n      else return \"L\";\n    }\n\n    var bidiRE = /[\\u0590-\\u05f4\\u0600-\\u06ff\\u0700-\\u08ac]/;\n    var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;\n    // Browsers seem to always treat the boundaries of block elements as being L.\n    var outerType = \"L\";\n\n    function BidiSpan(level, from, to) {\n      this.level = level;\n      this.from = from; this.to = to;\n    }\n\n    return function(str) {\n      if (!bidiRE.test(str)) return false;\n      var len = str.length, types = [];\n      for (var i = 0, type; i < len; ++i)\n        types.push(type = charType(str.charCodeAt(i)));\n\n      // W1. Examine each non-spacing mark (NSM) in the level run, and\n      // change the type of the NSM to the type of the previous\n      // character. If the NSM is at the start of the level run, it will\n      // get the type of sor.\n      for (var i = 0, prev = outerType; i < len; ++i) {\n        var type = types[i];\n        if (type == \"m\") types[i] = prev;\n        else prev = type;\n      }\n\n      // W2. Search backwards from each instance of a European number\n      // until the first strong type (R, L, AL, or sor) is found. If an\n      // AL is found, change the type of the European number to Arabic\n      // number.\n      // W3. Change all ALs to R.\n      for (var i = 0, cur = outerType; i < len; ++i) {\n        var type = types[i];\n        if (type == \"1\" && cur == \"r\") types[i] = \"n\";\n        else if (isStrong.test(type)) { cur = type; if (type == \"r\") types[i] = \"R\"; }\n      }\n\n      // W4. A single European separator between two European numbers\n      // changes to a European number. A single common separator between\n      // two numbers of the same type changes to that type.\n      for (var i = 1, prev = types[0]; i < len - 1; ++i) {\n        var type = types[i];\n        if (type == \"+\" && prev == \"1\" && types[i+1] == \"1\") types[i] = \"1\";\n        else if (type == \",\" && prev == types[i+1] &&\n                 (prev == \"1\" || prev == \"n\")) types[i] = prev;\n        prev = type;\n      }\n\n      // W5. A sequence of European terminators adjacent to European\n      // numbers changes to all European numbers.\n      // W6. Otherwise, separators and terminators change to Other\n      // Neutral.\n      for (var i = 0; i < len; ++i) {\n        var type = types[i];\n        if (type == \",\") types[i] = \"N\";\n        else if (type == \"%\") {\n          for (var end = i + 1; end < len && types[end] == \"%\"; ++end) {}\n          var replace = (i && types[i-1] == \"!\") || (end < len && types[end] == \"1\") ? \"1\" : \"N\";\n          for (var j = i; j < end; ++j) types[j] = replace;\n          i = end - 1;\n        }\n      }\n\n      // W7. Search backwards from each instance of a European number\n      // until the first strong type (R, L, or sor) is found. If an L is\n      // found, then change the type of the European number to L.\n      for (var i = 0, cur = outerType; i < len; ++i) {\n        var type = types[i];\n        if (cur == \"L\" && type == \"1\") types[i] = \"L\";\n        else if (isStrong.test(type)) cur = type;\n      }\n\n      // N1. A sequence of neutrals takes the direction of the\n      // surrounding strong text if the text on both sides has the same\n      // direction. European and Arabic numbers act as if they were R in\n      // terms of their influence on neutrals. Start-of-level-run (sor)\n      // and end-of-level-run (eor) are used at level run boundaries.\n      // N2. Any remaining neutrals take the embedding direction.\n      for (var i = 0; i < len; ++i) {\n        if (isNeutral.test(types[i])) {\n          for (var end = i + 1; end < len && isNeutral.test(types[end]); ++end) {}\n          var before = (i ? types[i-1] : outerType) == \"L\";\n          var after = (end < len ? types[end] : outerType) == \"L\";\n          var replace = before || after ? \"L\" : \"R\";\n          for (var j = i; j < end; ++j) types[j] = replace;\n          i = end - 1;\n        }\n      }\n\n      // Here we depart from the documented algorithm, in order to avoid\n      // building up an actual levels array. Since there are only three\n      // levels (0, 1, 2) in an implementation that doesn't take\n      // explicit embedding into account, we can build up the order on\n      // the fly, without following the level-based algorithm.\n      var order = [], m;\n      for (var i = 0; i < len;) {\n        if (countsAsLeft.test(types[i])) {\n          var start = i;\n          for (++i; i < len && countsAsLeft.test(types[i]); ++i) {}\n          order.push(new BidiSpan(0, start, i));\n        } else {\n          var pos = i, at = order.length;\n          for (++i; i < len && types[i] != \"L\"; ++i) {}\n          for (var j = pos; j < i;) {\n            if (countsAsNum.test(types[j])) {\n              if (pos < j) order.splice(at, 0, new BidiSpan(1, pos, j));\n              var nstart = j;\n              for (++j; j < i && countsAsNum.test(types[j]); ++j) {}\n              order.splice(at, 0, new BidiSpan(2, nstart, j));\n              pos = j;\n            } else ++j;\n          }\n          if (pos < i) order.splice(at, 0, new BidiSpan(1, pos, i));\n        }\n      }\n      if (order[0].level == 1 && (m = str.match(/^\\s+/))) {\n        order[0].from = m[0].length;\n        order.unshift(new BidiSpan(0, 0, m[0].length));\n      }\n      if (lst(order).level == 1 && (m = str.match(/\\s+$/))) {\n        lst(order).to -= m[0].length;\n        order.push(new BidiSpan(0, len - m[0].length, len));\n      }\n      if (order[0].level != lst(order).level)\n        order.push(new BidiSpan(order[0].level, len, len));\n\n      return order;\n    };\n  })();\n\n  // THE END\n\n  CodeMirror.version = \"4.7.0\";\n\n  return CodeMirror;\n});\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n// TODO actually recognize syntax of TypeScript constructs\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.defineMode(\"javascript\", function(config, parserConfig) {\n  var indentUnit = config.indentUnit;\n  var statementIndent = parserConfig.statementIndent;\n  var jsonldMode = parserConfig.jsonld;\n  var jsonMode = parserConfig.json || jsonldMode;\n  var isTS = parserConfig.typescript;\n  var wordRE = parserConfig.wordCharacters || /[\\w$\\xa1-\\uffff]/;\n\n  // Tokenizer\n\n  var keywords = function(){\n    function kw(type) {return {type: type, style: \"keyword\"};}\n    var A = kw(\"keyword a\"), B = kw(\"keyword b\"), C = kw(\"keyword c\");\n    var operator = kw(\"operator\"), atom = {type: \"atom\", style: \"atom\"};\n\n    var jsKeywords = {\n      \"if\": kw(\"if\"), \"while\": A, \"with\": A, \"else\": B, \"do\": B, \"try\": B, \"finally\": B,\n      \"return\": C, \"break\": C, \"continue\": C, \"new\": C, \"delete\": C, \"throw\": C, \"debugger\": C,\n      \"var\": kw(\"var\"), \"const\": kw(\"var\"), \"let\": kw(\"var\"),\n      \"function\": kw(\"function\"), \"catch\": kw(\"catch\"),\n      \"for\": kw(\"for\"), \"switch\": kw(\"switch\"), \"case\": kw(\"case\"), \"default\": kw(\"default\"),\n      \"in\": operator, \"typeof\": operator, \"instanceof\": operator,\n      \"true\": atom, \"false\": atom, \"null\": atom, \"undefined\": atom, \"NaN\": atom, \"Infinity\": atom,\n      \"this\": kw(\"this\"), \"module\": kw(\"module\"), \"class\": kw(\"class\"), \"super\": kw(\"atom\"),\n      \"yield\": C, \"export\": kw(\"export\"), \"import\": kw(\"import\"), \"extends\": C\n    };\n\n    // Extend the 'normal' keywords with the TypeScript language extensions\n    if (isTS) {\n      var type = {type: \"variable\", style: \"variable-3\"};\n      var tsKeywords = {\n        // object-like things\n        \"interface\": kw(\"interface\"),\n        \"extends\": kw(\"extends\"),\n        \"constructor\": kw(\"constructor\"),\n\n        // scope modifiers\n        \"public\": kw(\"public\"),\n        \"private\": kw(\"private\"),\n        \"protected\": kw(\"protected\"),\n        \"static\": kw(\"static\"),\n\n        // types\n        \"string\": type, \"number\": type, \"bool\": type, \"any\": type\n      };\n\n      for (var attr in tsKeywords) {\n        jsKeywords[attr] = tsKeywords[attr];\n      }\n    }\n\n    return jsKeywords;\n  }();\n\n  var isOperatorChar = /[+\\-*&%=<>!?|~^]/;\n  var isJsonldKeyword = /^@(context|id|value|language|type|container|list|set|reverse|index|base|vocab|graph)\"/;\n\n  function readRegexp(stream) {\n    var escaped = false, next, inSet = false;\n    while ((next = stream.next()) != null) {\n      if (!escaped) {\n        if (next == \"/\" && !inSet) return;\n        if (next == \"[\") inSet = true;\n        else if (inSet && next == \"]\") inSet = false;\n      }\n      escaped = !escaped && next == \"\\\\\";\n    }\n  }\n\n  // Used as scratch variables to communicate multiple values without\n  // consing up tons of objects.\n  var type, content;\n  function ret(tp, style, cont) {\n    type = tp; content = cont;\n    return style;\n  }\n  function tokenBase(stream, state) {\n    var ch = stream.next();\n    if (ch == '\"' || ch == \"'\") {\n      state.tokenize = tokenString(ch);\n      return state.tokenize(stream, state);\n    } else if (ch == \".\" && stream.match(/^\\d+(?:[eE][+\\-]?\\d+)?/)) {\n      return ret(\"number\", \"number\");\n    } else if (ch == \".\" && stream.match(\"..\")) {\n      return ret(\"spread\", \"meta\");\n    } else if (/[\\[\\]{}\\(\\),;\\:\\.]/.test(ch)) {\n      return ret(ch);\n    } else if (ch == \"=\" && stream.eat(\">\")) {\n      return ret(\"=>\", \"operator\");\n    } else if (ch == \"0\" && stream.eat(/x/i)) {\n      stream.eatWhile(/[\\da-f]/i);\n      return ret(\"number\", \"number\");\n    } else if (/\\d/.test(ch)) {\n      stream.match(/^\\d*(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/);\n      return ret(\"number\", \"number\");\n    } else if (ch == \"/\") {\n      if (stream.eat(\"*\")) {\n        state.tokenize = tokenComment;\n        return tokenComment(stream, state);\n      } else if (stream.eat(\"/\")) {\n        stream.skipToEnd();\n        return ret(\"comment\", \"comment\");\n      } else if (state.lastType == \"operator\" || state.lastType == \"keyword c\" ||\n               state.lastType == \"sof\" || /^[\\[{}\\(,;:]$/.test(state.lastType)) {\n        readRegexp(stream);\n        stream.eatWhile(/[gimy]/); // 'y' is \"sticky\" option in Mozilla\n        return ret(\"regexp\", \"string-2\");\n      } else {\n        stream.eatWhile(isOperatorChar);\n        return ret(\"operator\", \"operator\", stream.current());\n      }\n    } else if (ch == \"`\") {\n      state.tokenize = tokenQuasi;\n      return tokenQuasi(stream, state);\n    } else if (ch == \"#\") {\n      stream.skipToEnd();\n      return ret(\"error\", \"error\");\n    } else if (isOperatorChar.test(ch)) {\n      stream.eatWhile(isOperatorChar);\n      return ret(\"operator\", \"operator\", stream.current());\n    } else if (wordRE.test(ch)) {\n      stream.eatWhile(wordRE);\n      var word = stream.current(), known = keywords.propertyIsEnumerable(word) && keywords[word];\n      return (known && state.lastType != \".\") ? ret(known.type, known.style, word) :\n                     ret(\"variable\", \"variable\", word);\n    }\n  }\n\n  function tokenString(quote) {\n    return function(stream, state) {\n      var escaped = false, next;\n      if (jsonldMode && stream.peek() == \"@\" && stream.match(isJsonldKeyword)){\n        state.tokenize = tokenBase;\n        return ret(\"jsonld-keyword\", \"meta\");\n      }\n      while ((next = stream.next()) != null) {\n        if (next == quote && !escaped) break;\n        escaped = !escaped && next == \"\\\\\";\n      }\n      if (!escaped) state.tokenize = tokenBase;\n      return ret(\"string\", \"string\");\n    };\n  }\n\n  function tokenComment(stream, state) {\n    var maybeEnd = false, ch;\n    while (ch = stream.next()) {\n      if (ch == \"/\" && maybeEnd) {\n        state.tokenize = tokenBase;\n        break;\n      }\n      maybeEnd = (ch == \"*\");\n    }\n    return ret(\"comment\", \"comment\");\n  }\n\n  function tokenQuasi(stream, state) {\n    var escaped = false, next;\n    while ((next = stream.next()) != null) {\n      if (!escaped && (next == \"`\" || next == \"$\" && stream.eat(\"{\"))) {\n        state.tokenize = tokenBase;\n        break;\n      }\n      escaped = !escaped && next == \"\\\\\";\n    }\n    return ret(\"quasi\", \"string-2\", stream.current());\n  }\n\n  var brackets = \"([{}])\";\n  // This is a crude lookahead trick to try and notice that we're\n  // parsing the argument patterns for a fat-arrow function before we\n  // actually hit the arrow token. It only works if the arrow is on\n  // the same line as the arguments and there's no strange noise\n  // (comments) in between. Fallback is to only notice when we hit the\n  // arrow, and not declare the arguments as locals for the arrow\n  // body.\n  function findFatArrow(stream, state) {\n    if (state.fatArrowAt) state.fatArrowAt = null;\n    var arrow = stream.string.indexOf(\"=>\", stream.start);\n    if (arrow < 0) return;\n\n    var depth = 0, sawSomething = false;\n    for (var pos = arrow - 1; pos >= 0; --pos) {\n      var ch = stream.string.charAt(pos);\n      var bracket = brackets.indexOf(ch);\n      if (bracket >= 0 && bracket < 3) {\n        if (!depth) { ++pos; break; }\n        if (--depth == 0) break;\n      } else if (bracket >= 3 && bracket < 6) {\n        ++depth;\n      } else if (wordRE.test(ch)) {\n        sawSomething = true;\n      } else if (sawSomething && !depth) {\n        ++pos;\n        break;\n      }\n    }\n    if (sawSomething && !depth) state.fatArrowAt = pos;\n  }\n\n  // Parser\n\n  var atomicTypes = {\"atom\": true, \"number\": true, \"variable\": true, \"string\": true, \"regexp\": true, \"this\": true, \"jsonld-keyword\": true};\n\n  function JSLexical(indented, column, type, align, prev, info) {\n    this.indented = indented;\n    this.column = column;\n    this.type = type;\n    this.prev = prev;\n    this.info = info;\n    if (align != null) this.align = align;\n  }\n\n  function inScope(state, varname) {\n    for (var v = state.localVars; v; v = v.next)\n      if (v.name == varname) return true;\n    for (var cx = state.context; cx; cx = cx.prev) {\n      for (var v = cx.vars; v; v = v.next)\n        if (v.name == varname) return true;\n    }\n  }\n\n  function parseJS(state, style, type, content, stream) {\n    var cc = state.cc;\n    // Communicate our context to the combinators.\n    // (Less wasteful than consing up a hundred closures on every call.)\n    cx.state = state; cx.stream = stream; cx.marked = null, cx.cc = cc; cx.style = style;\n\n    if (!state.lexical.hasOwnProperty(\"align\"))\n      state.lexical.align = true;\n\n    while(true) {\n      var combinator = cc.length ? cc.pop() : jsonMode ? expression : statement;\n      if (combinator(type, content)) {\n        while(cc.length && cc[cc.length - 1].lex)\n          cc.pop()();\n        if (cx.marked) return cx.marked;\n        if (type == \"variable\" && inScope(state, content)) return \"variable-2\";\n        return style;\n      }\n    }\n  }\n\n  // Combinator utils\n\n  var cx = {state: null, column: null, marked: null, cc: null};\n  function pass() {\n    for (var i = arguments.length - 1; i >= 0; i--) cx.cc.push(arguments[i]);\n  }\n  function cont() {\n    pass.apply(null, arguments);\n    return true;\n  }\n  function register(varname) {\n    function inList(list) {\n      for (var v = list; v; v = v.next)\n        if (v.name == varname) return true;\n      return false;\n    }\n    var state = cx.state;\n    if (state.context) {\n      cx.marked = \"def\";\n      if (inList(state.localVars)) return;\n      state.localVars = {name: varname, next: state.localVars};\n    } else {\n      if (inList(state.globalVars)) return;\n      if (parserConfig.globalVars)\n        state.globalVars = {name: varname, next: state.globalVars};\n    }\n  }\n\n  // Combinators\n\n  var defaultVars = {name: \"this\", next: {name: \"arguments\"}};\n  function pushcontext() {\n    cx.state.context = {prev: cx.state.context, vars: cx.state.localVars};\n    cx.state.localVars = defaultVars;\n  }\n  function popcontext() {\n    cx.state.localVars = cx.state.context.vars;\n    cx.state.context = cx.state.context.prev;\n  }\n  function pushlex(type, info) {\n    var result = function() {\n      var state = cx.state, indent = state.indented;\n      if (state.lexical.type == \"stat\") indent = state.lexical.indented;\n      else for (var outer = state.lexical; outer && outer.type == \")\" && outer.align; outer = outer.prev)\n        indent = outer.indented;\n      state.lexical = new JSLexical(indent, cx.stream.column(), type, null, state.lexical, info);\n    };\n    result.lex = true;\n    return result;\n  }\n  function poplex() {\n    var state = cx.state;\n    if (state.lexical.prev) {\n      if (state.lexical.type == \")\")\n        state.indented = state.lexical.indented;\n      state.lexical = state.lexical.prev;\n    }\n  }\n  poplex.lex = true;\n\n  function expect(wanted) {\n    function exp(type) {\n      if (type == wanted) return cont();\n      else if (wanted == \";\") return pass();\n      else return cont(exp);\n    };\n    return exp;\n  }\n\n  function statement(type, value) {\n    if (type == \"var\") return cont(pushlex(\"vardef\", value.length), vardef, expect(\";\"), poplex);\n    if (type == \"keyword a\") return cont(pushlex(\"form\"), expression, statement, poplex);\n    if (type == \"keyword b\") return cont(pushlex(\"form\"), statement, poplex);\n    if (type == \"{\") return cont(pushlex(\"}\"), block, poplex);\n    if (type == \";\") return cont();\n    if (type == \"if\") {\n      if (cx.state.lexical.info == \"else\" && cx.state.cc[cx.state.cc.length - 1] == poplex)\n        cx.state.cc.pop()();\n      return cont(pushlex(\"form\"), expression, statement, poplex, maybeelse);\n    }\n    if (type == \"function\") return cont(functiondef);\n    if (type == \"for\") return cont(pushlex(\"form\"), forspec, statement, poplex);\n    if (type == \"variable\") return cont(pushlex(\"stat\"), maybelabel);\n    if (type == \"switch\") return cont(pushlex(\"form\"), expression, pushlex(\"}\", \"switch\"), expect(\"{\"),\n                                      block, poplex, poplex);\n    if (type == \"case\") return cont(expression, expect(\":\"));\n    if (type == \"default\") return cont(expect(\":\"));\n    if (type == \"catch\") return cont(pushlex(\"form\"), pushcontext, expect(\"(\"), funarg, expect(\")\"),\n                                     statement, poplex, popcontext);\n    if (type == \"module\") return cont(pushlex(\"form\"), pushcontext, afterModule, popcontext, poplex);\n    if (type == \"class\") return cont(pushlex(\"form\"), className, poplex);\n    if (type == \"export\") return cont(pushlex(\"form\"), afterExport, poplex);\n    if (type == \"import\") return cont(pushlex(\"form\"), afterImport, poplex);\n    return pass(pushlex(\"stat\"), expression, expect(\";\"), poplex);\n  }\n  function expression(type) {\n    return expressionInner(type, false);\n  }\n  function expressionNoComma(type) {\n    return expressionInner(type, true);\n  }\n  function expressionInner(type, noComma) {\n    if (cx.state.fatArrowAt == cx.stream.start) {\n      var body = noComma ? arrowBodyNoComma : arrowBody;\n      if (type == \"(\") return cont(pushcontext, pushlex(\")\"), commasep(pattern, \")\"), poplex, expect(\"=>\"), body, popcontext);\n      else if (type == \"variable\") return pass(pushcontext, pattern, expect(\"=>\"), body, popcontext);\n    }\n\n    var maybeop = noComma ? maybeoperatorNoComma : maybeoperatorComma;\n    if (atomicTypes.hasOwnProperty(type)) return cont(maybeop);\n    if (type == \"function\") return cont(functiondef, maybeop);\n    if (type == \"keyword c\") return cont(noComma ? maybeexpressionNoComma : maybeexpression);\n    if (type == \"(\") return cont(pushlex(\")\"), maybeexpression, comprehension, expect(\")\"), poplex, maybeop);\n    if (type == \"operator\" || type == \"spread\") return cont(noComma ? expressionNoComma : expression);\n    if (type == \"[\") return cont(pushlex(\"]\"), arrayLiteral, poplex, maybeop);\n    if (type == \"{\") return contCommasep(objprop, \"}\", null, maybeop);\n    if (type == \"quasi\") { return pass(quasi, maybeop); }\n    return cont();\n  }\n  function maybeexpression(type) {\n    if (type.match(/[;\\}\\)\\],]/)) return pass();\n    return pass(expression);\n  }\n  function maybeexpressionNoComma(type) {\n    if (type.match(/[;\\}\\)\\],]/)) return pass();\n    return pass(expressionNoComma);\n  }\n\n  function maybeoperatorComma(type, value) {\n    if (type == \",\") return cont(expression);\n    return maybeoperatorNoComma(type, value, false);\n  }\n  function maybeoperatorNoComma(type, value, noComma) {\n    var me = noComma == false ? maybeoperatorComma : maybeoperatorNoComma;\n    var expr = noComma == false ? expression : expressionNoComma;\n    if (type == \"=>\") return cont(pushcontext, noComma ? arrowBodyNoComma : arrowBody, popcontext);\n    if (type == \"operator\") {\n      if (/\\+\\+|--/.test(value)) return cont(me);\n      if (value == \"?\") return cont(expression, expect(\":\"), expr);\n      return cont(expr);\n    }\n    if (type == \"quasi\") { return pass(quasi, me); }\n    if (type == \";\") return;\n    if (type == \"(\") return contCommasep(expressionNoComma, \")\", \"call\", me);\n    if (type == \".\") return cont(property, me);\n    if (type == \"[\") return cont(pushlex(\"]\"), maybeexpression, expect(\"]\"), poplex, me);\n  }\n  function quasi(type, value) {\n    if (type != \"quasi\") return pass();\n    if (value.slice(value.length - 2) != \"${\") return cont(quasi);\n    return cont(expression, continueQuasi);\n  }\n  function continueQuasi(type) {\n    if (type == \"}\") {\n      cx.marked = \"string-2\";\n      cx.state.tokenize = tokenQuasi;\n      return cont(quasi);\n    }\n  }\n  function arrowBody(type) {\n    findFatArrow(cx.stream, cx.state);\n    return pass(type == \"{\" ? statement : expression);\n  }\n  function arrowBodyNoComma(type) {\n    findFatArrow(cx.stream, cx.state);\n    return pass(type == \"{\" ? statement : expressionNoComma);\n  }\n  function maybelabel(type) {\n    if (type == \":\") return cont(poplex, statement);\n    return pass(maybeoperatorComma, expect(\";\"), poplex);\n  }\n  function property(type) {\n    if (type == \"variable\") {cx.marked = \"property\"; return cont();}\n  }\n  function objprop(type, value) {\n    if (type == \"variable\" || cx.style == \"keyword\") {\n      cx.marked = \"property\";\n      if (value == \"get\" || value == \"set\") return cont(getterSetter);\n      return cont(afterprop);\n    } else if (type == \"number\" || type == \"string\") {\n      cx.marked = jsonldMode ? \"property\" : (cx.style + \" property\");\n      return cont(afterprop);\n    } else if (type == \"jsonld-keyword\") {\n      return cont(afterprop);\n    } else if (type == \"[\") {\n      return cont(expression, expect(\"]\"), afterprop);\n    }\n  }\n  function getterSetter(type) {\n    if (type != \"variable\") return pass(afterprop);\n    cx.marked = \"property\";\n    return cont(functiondef);\n  }\n  function afterprop(type) {\n    if (type == \":\") return cont(expressionNoComma);\n    if (type == \"(\") return pass(functiondef);\n  }\n  function commasep(what, end) {\n    function proceed(type) {\n      if (type == \",\") {\n        var lex = cx.state.lexical;\n        if (lex.info == \"call\") lex.pos = (lex.pos || 0) + 1;\n        return cont(what, proceed);\n      }\n      if (type == end) return cont();\n      return cont(expect(end));\n    }\n    return function(type) {\n      if (type == end) return cont();\n      return pass(what, proceed);\n    };\n  }\n  function contCommasep(what, end, info) {\n    for (var i = 3; i < arguments.length; i++)\n      cx.cc.push(arguments[i]);\n    return cont(pushlex(end, info), commasep(what, end), poplex);\n  }\n  function block(type) {\n    if (type == \"}\") return cont();\n    return pass(statement, block);\n  }\n  function maybetype(type) {\n    if (isTS && type == \":\") return cont(typedef);\n  }\n  function typedef(type) {\n    if (type == \"variable\"){cx.marked = \"variable-3\"; return cont();}\n  }\n  function vardef() {\n    return pass(pattern, maybetype, maybeAssign, vardefCont);\n  }\n  function pattern(type, value) {\n    if (type == \"variable\") { register(value); return cont(); }\n    if (type == \"[\") return contCommasep(pattern, \"]\");\n    if (type == \"{\") return contCommasep(proppattern, \"}\");\n  }\n  function proppattern(type, value) {\n    if (type == \"variable\" && !cx.stream.match(/^\\s*:/, false)) {\n      register(value);\n      return cont(maybeAssign);\n    }\n    if (type == \"variable\") cx.marked = \"property\";\n    return cont(expect(\":\"), pattern, maybeAssign);\n  }\n  function maybeAssign(_type, value) {\n    if (value == \"=\") return cont(expressionNoComma);\n  }\n  function vardefCont(type) {\n    if (type == \",\") return cont(vardef);\n  }\n  function maybeelse(type, value) {\n    if (type == \"keyword b\" && value == \"else\") return cont(pushlex(\"form\", \"else\"), statement, poplex);\n  }\n  function forspec(type) {\n    if (type == \"(\") return cont(pushlex(\")\"), forspec1, expect(\")\"), poplex);\n  }\n  function forspec1(type) {\n    if (type == \"var\") return cont(vardef, expect(\";\"), forspec2);\n    if (type == \";\") return cont(forspec2);\n    if (type == \"variable\") return cont(formaybeinof);\n    return pass(expression, expect(\";\"), forspec2);\n  }\n  function formaybeinof(_type, value) {\n    if (value == \"in\" || value == \"of\") { cx.marked = \"keyword\"; return cont(expression); }\n    return cont(maybeoperatorComma, forspec2);\n  }\n  function forspec2(type, value) {\n    if (type == \";\") return cont(forspec3);\n    if (value == \"in\" || value == \"of\") { cx.marked = \"keyword\"; return cont(expression); }\n    return pass(expression, expect(\";\"), forspec3);\n  }\n  function forspec3(type) {\n    if (type != \")\") cont(expression);\n  }\n  function functiondef(type, value) {\n    if (value == \"*\") {cx.marked = \"keyword\"; return cont(functiondef);}\n    if (type == \"variable\") {register(value); return cont(functiondef);}\n    if (type == \"(\") return cont(pushcontext, pushlex(\")\"), commasep(funarg, \")\"), poplex, statement, popcontext);\n  }\n  function funarg(type) {\n    if (type == \"spread\") return cont(funarg);\n    return pass(pattern, maybetype);\n  }\n  function className(type, value) {\n    if (type == \"variable\") {register(value); return cont(classNameAfter);}\n  }\n  function classNameAfter(type, value) {\n    if (value == \"extends\") return cont(expression, classNameAfter);\n    if (type == \"{\") return cont(pushlex(\"}\"), classBody, poplex);\n  }\n  function classBody(type, value) {\n    if (type == \"variable\" || cx.style == \"keyword\") {\n      cx.marked = \"property\";\n      if (value == \"get\" || value == \"set\") return cont(classGetterSetter, functiondef, classBody);\n      return cont(functiondef, classBody);\n    }\n    if (value == \"*\") {\n      cx.marked = \"keyword\";\n      return cont(classBody);\n    }\n    if (type == \";\") return cont(classBody);\n    if (type == \"}\") return cont();\n  }\n  function classGetterSetter(type) {\n    if (type != \"variable\") return pass();\n    cx.marked = \"property\";\n    return cont();\n  }\n  function afterModule(type, value) {\n    if (type == \"string\") return cont(statement);\n    if (type == \"variable\") { register(value); return cont(maybeFrom); }\n  }\n  function afterExport(_type, value) {\n    if (value == \"*\") { cx.marked = \"keyword\"; return cont(maybeFrom, expect(\";\")); }\n    if (value == \"default\") { cx.marked = \"keyword\"; return cont(expression, expect(\";\")); }\n    return pass(statement);\n  }\n  function afterImport(type) {\n    if (type == \"string\") return cont();\n    return pass(importSpec, maybeFrom);\n  }\n  function importSpec(type, value) {\n    if (type == \"{\") return contCommasep(importSpec, \"}\");\n    if (type == \"variable\") register(value);\n    return cont();\n  }\n  function maybeFrom(_type, value) {\n    if (value == \"from\") { cx.marked = \"keyword\"; return cont(expression); }\n  }\n  function arrayLiteral(type) {\n    if (type == \"]\") return cont();\n    return pass(expressionNoComma, maybeArrayComprehension);\n  }\n  function maybeArrayComprehension(type) {\n    if (type == \"for\") return pass(comprehension, expect(\"]\"));\n    if (type == \",\") return cont(commasep(maybeexpressionNoComma, \"]\"));\n    return pass(commasep(expressionNoComma, \"]\"));\n  }\n  function comprehension(type) {\n    if (type == \"for\") return cont(forspec, comprehension);\n    if (type == \"if\") return cont(expression, comprehension);\n  }\n\n  // Interface\n\n  return {\n    startState: function(basecolumn) {\n      var state = {\n        tokenize: tokenBase,\n        lastType: \"sof\",\n        cc: [],\n        lexical: new JSLexical((basecolumn || 0) - indentUnit, 0, \"block\", false),\n        localVars: parserConfig.localVars,\n        context: parserConfig.localVars && {vars: parserConfig.localVars},\n        indented: 0\n      };\n      if (parserConfig.globalVars && typeof parserConfig.globalVars == \"object\")\n        state.globalVars = parserConfig.globalVars;\n      return state;\n    },\n\n    token: function(stream, state) {\n      if (stream.sol()) {\n        if (!state.lexical.hasOwnProperty(\"align\"))\n          state.lexical.align = false;\n        state.indented = stream.indentation();\n        findFatArrow(stream, state);\n      }\n      if (state.tokenize != tokenComment && stream.eatSpace()) return null;\n      var style = state.tokenize(stream, state);\n      if (type == \"comment\") return style;\n      state.lastType = type == \"operator\" && (content == \"++\" || content == \"--\") ? \"incdec\" : type;\n      return parseJS(state, style, type, content, stream);\n    },\n\n    indent: function(state, textAfter) {\n      if (state.tokenize == tokenComment) return CodeMirror.Pass;\n      if (state.tokenize != tokenBase) return 0;\n      var firstChar = textAfter && textAfter.charAt(0), lexical = state.lexical;\n      // Kludge to prevent 'maybelse' from blocking lexical scope pops\n      if (!/^\\s*else\\b/.test(textAfter)) for (var i = state.cc.length - 1; i >= 0; --i) {\n        var c = state.cc[i];\n        if (c == poplex) lexical = lexical.prev;\n        else if (c != maybeelse) break;\n      }\n      if (lexical.type == \"stat\" && firstChar == \"}\") lexical = lexical.prev;\n      if (statementIndent && lexical.type == \")\" && lexical.prev.type == \"stat\")\n        lexical = lexical.prev;\n      var type = lexical.type, closing = firstChar == type;\n\n      if (type == \"vardef\") return lexical.indented + (state.lastType == \"operator\" || state.lastType == \",\" ? lexical.info + 1 : 0);\n      else if (type == \"form\" && firstChar == \"{\") return lexical.indented;\n      else if (type == \"form\") return lexical.indented + indentUnit;\n      else if (type == \"stat\")\n        return lexical.indented + (state.lastType == \"operator\" || state.lastType == \",\" ? statementIndent || indentUnit : 0);\n      else if (lexical.info == \"switch\" && !closing && parserConfig.doubleIndentSwitch != false)\n        return lexical.indented + (/^(?:case|default)\\b/.test(textAfter) ? indentUnit : 2 * indentUnit);\n      else if (lexical.align) return lexical.column + (closing ? 0 : 1);\n      else return lexical.indented + (closing ? 0 : indentUnit);\n    },\n\n    electricInput: /^\\s*(?:case .*?:|default:|\\{|\\})$/,\n    blockCommentStart: jsonMode ? null : \"/*\",\n    blockCommentEnd: jsonMode ? null : \"*/\",\n    lineComment: jsonMode ? null : \"//\",\n    fold: \"brace\",\n\n    helperType: jsonMode ? \"json\" : \"javascript\",\n    jsonldMode: jsonldMode,\n    jsonMode: jsonMode\n  };\n});\n\nCodeMirror.registerHelper(\"wordChars\", \"javascript\", /[\\w$]/);\n\nCodeMirror.defineMIME(\"text/javascript\", \"javascript\");\nCodeMirror.defineMIME(\"text/ecmascript\", \"javascript\");\nCodeMirror.defineMIME(\"application/javascript\", \"javascript\");\nCodeMirror.defineMIME(\"application/x-javascript\", \"javascript\");\nCodeMirror.defineMIME(\"application/ecmascript\", \"javascript\");\nCodeMirror.defineMIME(\"application/json\", {name: \"javascript\", json: true});\nCodeMirror.defineMIME(\"application/x-json\", {name: \"javascript\", json: true});\nCodeMirror.defineMIME(\"application/ld+json\", {name: \"javascript\", jsonld: true});\nCodeMirror.defineMIME(\"text/typescript\", { name: \"javascript\", typescript: true });\nCodeMirror.defineMIME(\"application/typescript\", { name: \"javascript\", typescript: true });\n\n});\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n  var GUTTER_ID = \"CodeMirror-lint-markers\";\n\n  function showTooltip(e, content) {\n    var tt = document.createElement(\"div\");\n    tt.className = \"CodeMirror-lint-tooltip\";\n    tt.appendChild(content.cloneNode(true));\n    document.body.appendChild(tt);\n\n    function position(e) {\n      if (!tt.parentNode) return CodeMirror.off(document, \"mousemove\", position);\n      tt.style.top = Math.max(0, e.clientY - tt.offsetHeight - 5) + \"px\";\n      tt.style.left = (e.clientX + 5) + \"px\";\n    }\n    CodeMirror.on(document, \"mousemove\", position);\n    position(e);\n    if (tt.style.opacity != null) tt.style.opacity = 1;\n    return tt;\n  }\n  function rm(elt) {\n    if (elt.parentNode) elt.parentNode.removeChild(elt);\n  }\n  function hideTooltip(tt) {\n    if (!tt.parentNode) return;\n    if (tt.style.opacity == null) rm(tt);\n    tt.style.opacity = 0;\n    setTimeout(function() { rm(tt); }, 600);\n  }\n\n  function showTooltipFor(e, content, node) {\n    var tooltip = showTooltip(e, content);\n    function hide() {\n      CodeMirror.off(node, \"mouseout\", hide);\n      if (tooltip) { hideTooltip(tooltip); tooltip = null; }\n    }\n    var poll = setInterval(function() {\n      if (tooltip) for (var n = node;; n = n.parentNode) {\n        if (n == document.body) return;\n        if (!n) { hide(); break; }\n      }\n      if (!tooltip) return clearInterval(poll);\n    }, 400);\n    CodeMirror.on(node, \"mouseout\", hide);\n  }\n\n  function LintState(cm, options, hasGutter) {\n    this.marked = [];\n    this.options = options;\n    this.timeout = null;\n    this.hasGutter = hasGutter;\n    this.onMouseOver = function(e) { onMouseOver(cm, e); };\n  }\n\n  function parseOptions(cm, options) {\n    if (options instanceof Function) return {getAnnotations: options};\n    if (!options || options === true) options = {};\n    if (!options.getAnnotations) options.getAnnotations = cm.getHelper(CodeMirror.Pos(0, 0), \"lint\");\n    if (!options.getAnnotations) throw new Error(\"Required option 'getAnnotations' missing (lint addon)\");\n    return options;\n  }\n\n  function clearMarks(cm) {\n    var state = cm.state.lint;\n    if (state.hasGutter) cm.clearGutter(GUTTER_ID);\n    for (var i = 0; i < state.marked.length; ++i)\n      state.marked[i].clear();\n    state.marked.length = 0;\n  }\n\n  function makeMarker(labels, severity, multiple, tooltips) {\n    var marker = document.createElement(\"div\"), inner = marker;\n    marker.className = \"CodeMirror-lint-marker-\" + severity;\n    if (multiple) {\n      inner = marker.appendChild(document.createElement(\"div\"));\n      inner.className = \"CodeMirror-lint-marker-multiple\";\n    }\n\n    if (tooltips != false) CodeMirror.on(inner, \"mouseover\", function(e) {\n      showTooltipFor(e, labels, inner);\n    });\n\n    return marker;\n  }\n\n  function getMaxSeverity(a, b) {\n    if (a == \"error\") return a;\n    else return b;\n  }\n\n  function groupByLine(annotations) {\n    var lines = [];\n    for (var i = 0; i < annotations.length; ++i) {\n      var ann = annotations[i], line = ann.from.line;\n      (lines[line] || (lines[line] = [])).push(ann);\n    }\n    return lines;\n  }\n\n  function annotationTooltip(ann) {\n    var severity = ann.severity;\n    if (!severity) severity = \"error\";\n    var tip = document.createElement(\"div\");\n    tip.className = \"CodeMirror-lint-message-\" + severity;\n    tip.appendChild(document.createTextNode(ann.message));\n    return tip;\n  }\n\n  function startLinting(cm) {\n    var state = cm.state.lint, options = state.options;\n    var passOptions = options.options || options; // Support deprecated passing of `options` property in options\n    if (options.async)\n      options.getAnnotations(cm.getValue(), updateLinting, passOptions, cm);\n    else\n      updateLinting(cm, options.getAnnotations(cm.getValue(), passOptions, cm));\n  }\n\n  function updateLinting(cm, annotationsNotSorted) {\n    clearMarks(cm);\n    var state = cm.state.lint, options = state.options;\n\n    var annotations = groupByLine(annotationsNotSorted);\n\n    for (var line = 0; line < annotations.length; ++line) {\n      var anns = annotations[line];\n      if (!anns) continue;\n\n      var maxSeverity = null;\n      var tipLabel = state.hasGutter && document.createDocumentFragment();\n\n      for (var i = 0; i < anns.length; ++i) {\n        var ann = anns[i];\n        var severity = ann.severity;\n        if (!severity) severity = \"error\";\n        maxSeverity = getMaxSeverity(maxSeverity, severity);\n\n        if (options.formatAnnotation) ann = options.formatAnnotation(ann);\n        if (state.hasGutter) tipLabel.appendChild(annotationTooltip(ann));\n\n        if (ann.to) state.marked.push(cm.markText(ann.from, ann.to, {\n          className: \"CodeMirror-lint-mark-\" + severity,\n          __annotation: ann\n        }));\n      }\n\n      if (state.hasGutter)\n        cm.setGutterMarker(line, GUTTER_ID, makeMarker(tipLabel, maxSeverity, anns.length > 1,\n                                                       state.options.tooltips));\n    }\n    if (options.onUpdateLinting) options.onUpdateLinting(annotationsNotSorted, annotations, cm);\n  }\n\n  function onChange(cm) {\n    var state = cm.state.lint;\n    clearTimeout(state.timeout);\n    state.timeout = setTimeout(function(){startLinting(cm);}, state.options.delay || 500);\n  }\n\n  function popupSpanTooltip(ann, e) {\n    var target = e.target || e.srcElement;\n    showTooltipFor(e, annotationTooltip(ann), target);\n  }\n\n  function onMouseOver(cm, e) {\n    var target = e.target || e.srcElement;\n    if (!/\\bCodeMirror-lint-mark-/.test(target.className)) return;\n    var box = target.getBoundingClientRect(), x = (box.left + box.right) / 2, y = (box.top + box.bottom) / 2;\n    var spans = cm.findMarksAt(cm.coordsChar({left: x, top: y}, \"client\"));\n    for (var i = 0; i < spans.length; ++i) {\n      var ann = spans[i].__annotation;\n      if (ann) return popupSpanTooltip(ann, e);\n    }\n  }\n\n  CodeMirror.defineOption(\"lint\", false, function(cm, val, old) {\n    if (old && old != CodeMirror.Init) {\n      clearMarks(cm);\n      cm.off(\"change\", onChange);\n      CodeMirror.off(cm.getWrapperElement(), \"mouseover\", cm.state.lint.onMouseOver);\n      delete cm.state.lint;\n    }\n\n    if (val) {\n      var gutters = cm.getOption(\"gutters\"), hasLintGutter = false;\n      for (var i = 0; i < gutters.length; ++i) if (gutters[i] == GUTTER_ID) hasLintGutter = true;\n      var state = cm.state.lint = new LintState(cm, parseOptions(cm, val), hasLintGutter);\n      cm.on(\"change\", onChange);\n      if (state.options.tooltips != false)\n        CodeMirror.on(cm.getWrapperElement(), \"mouseover\", state.onMouseOver);\n\n      startLinting(cm);\n    }\n  });\n});\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n// Depends on jsonlint.js from https://github.com/zaach/jsonlint\n\n// declare global: jsonlint\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.registerHelper(\"lint\", \"json\", function(text) {\n  var found = [];\n  jsonlint.parseError = function(str, hash) {\n    var loc = hash.loc;\n    found.push({from: CodeMirror.Pos(loc.first_line - 1, loc.first_column),\n                to: CodeMirror.Pos(loc.last_line - 1, loc.last_column),\n                message: str});\n  };\n  try { jsonlint.parse(text); }\n  catch(e) {}\n  return found;\n});\n\n});\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.registerHelper(\"fold\", \"brace\", function(cm, start) {\n  var line = start.line, lineText = cm.getLine(line);\n  var startCh, tokenType;\n\n  function findOpening(openCh) {\n    for (var at = start.ch, pass = 0;;) {\n      var found = at <= 0 ? -1 : lineText.lastIndexOf(openCh, at - 1);\n      if (found == -1) {\n        if (pass == 1) break;\n        pass = 1;\n        at = lineText.length;\n        continue;\n      }\n      if (pass == 1 && found < start.ch) break;\n      tokenType = cm.getTokenTypeAt(CodeMirror.Pos(line, found + 1));\n      if (!/^(comment|string)/.test(tokenType)) return found + 1;\n      at = found - 1;\n    }\n  }\n\n  var startToken = \"{\", endToken = \"}\", startCh = findOpening(\"{\");\n  if (startCh == null) {\n    startToken = \"[\", endToken = \"]\";\n    startCh = findOpening(\"[\");\n  }\n\n  if (startCh == null) return;\n  var count = 1, lastLine = cm.lastLine(), end, endCh;\n  outer: for (var i = line; i <= lastLine; ++i) {\n    var text = cm.getLine(i), pos = i == line ? startCh : 0;\n    for (;;) {\n      var nextOpen = text.indexOf(startToken, pos), nextClose = text.indexOf(endToken, pos);\n      if (nextOpen < 0) nextOpen = text.length;\n      if (nextClose < 0) nextClose = text.length;\n      pos = Math.min(nextOpen, nextClose);\n      if (pos == text.length) break;\n      if (cm.getTokenTypeAt(CodeMirror.Pos(i, pos + 1)) == tokenType) {\n        if (pos == nextOpen) ++count;\n        else if (!--count) { end = i; endCh = pos; break outer; }\n      }\n      ++pos;\n    }\n  }\n  if (end == null || line == end && endCh == startCh) return;\n  return {from: CodeMirror.Pos(line, startCh),\n          to: CodeMirror.Pos(end, endCh)};\n});\n\nCodeMirror.registerHelper(\"fold\", \"import\", function(cm, start) {\n  function hasImport(line) {\n    if (line < cm.firstLine() || line > cm.lastLine()) return null;\n    var start = cm.getTokenAt(CodeMirror.Pos(line, 1));\n    if (!/\\S/.test(start.string)) start = cm.getTokenAt(CodeMirror.Pos(line, start.end + 1));\n    if (start.type != \"keyword\" || start.string != \"import\") return null;\n    // Now find closing semicolon, return its position\n    for (var i = line, e = Math.min(cm.lastLine(), line + 10); i <= e; ++i) {\n      var text = cm.getLine(i), semi = text.indexOf(\";\");\n      if (semi != -1) return {startCh: start.end, end: CodeMirror.Pos(i, semi)};\n    }\n  }\n\n  var start = start.line, has = hasImport(start), prev;\n  if (!has || hasImport(start - 1) || ((prev = hasImport(start - 2)) && prev.end.line == start - 1))\n    return null;\n  for (var end = has.end;;) {\n    var next = hasImport(end.line + 1);\n    if (next == null) break;\n    end = next.end;\n  }\n  return {from: cm.clipPos(CodeMirror.Pos(start, has.startCh + 1)), to: end};\n});\n\nCodeMirror.registerHelper(\"fold\", \"include\", function(cm, start) {\n  function hasInclude(line) {\n    if (line < cm.firstLine() || line > cm.lastLine()) return null;\n    var start = cm.getTokenAt(CodeMirror.Pos(line, 1));\n    if (!/\\S/.test(start.string)) start = cm.getTokenAt(CodeMirror.Pos(line, start.end + 1));\n    if (start.type == \"meta\" && start.string.slice(0, 8) == \"#include\") return start.start + 8;\n  }\n\n  var start = start.line, has = hasInclude(start);\n  if (has == null || hasInclude(start - 1) != null) return null;\n  for (var end = start;;) {\n    var next = hasInclude(end + 1);\n    if (next == null) break;\n    ++end;\n  }\n  return {from: CodeMirror.Pos(start, has + 1),\n          to: cm.clipPos(CodeMirror.Pos(end))};\n});\n\n});\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  function doFold(cm, pos, options, force) {\n    if (options && options.call) {\n      var finder = options;\n      options = null;\n    } else {\n      var finder = getOption(cm, options, \"rangeFinder\");\n    }\n    if (typeof pos == \"number\") pos = CodeMirror.Pos(pos, 0);\n    var minSize = getOption(cm, options, \"minFoldSize\");\n\n    function getRange(allowFolded) {\n      var range = finder(cm, pos);\n      if (!range || range.to.line - range.from.line < minSize) return null;\n      var marks = cm.findMarksAt(range.from);\n      for (var i = 0; i < marks.length; ++i) {\n        if (marks[i].__isFold && force !== \"fold\") {\n          if (!allowFolded) return null;\n          range.cleared = true;\n          marks[i].clear();\n        }\n      }\n      return range;\n    }\n\n    var range = getRange(true);\n    if (getOption(cm, options, \"scanUp\")) while (!range && pos.line > cm.firstLine()) {\n      pos = CodeMirror.Pos(pos.line - 1, 0);\n      range = getRange(false);\n    }\n    if (!range || range.cleared || force === \"unfold\") return;\n\n    var myWidget = makeWidget(cm, options);\n    CodeMirror.on(myWidget, \"mousedown\", function(e) {\n      myRange.clear();\n      CodeMirror.e_preventDefault(e);\n    });\n    var myRange = cm.markText(range.from, range.to, {\n      replacedWith: myWidget,\n      clearOnEnter: true,\n      __isFold: true\n    });\n    myRange.on(\"clear\", function(from, to) {\n      CodeMirror.signal(cm, \"unfold\", cm, from, to);\n    });\n    CodeMirror.signal(cm, \"fold\", cm, range.from, range.to);\n  }\n\n  function makeWidget(cm, options) {\n    var widget = getOption(cm, options, \"widget\");\n    if (typeof widget == \"string\") {\n      var text = document.createTextNode(widget);\n      widget = document.createElement(\"span\");\n      widget.appendChild(text);\n      widget.className = \"CodeMirror-foldmarker\";\n    }\n    return widget;\n  }\n\n  // Clumsy backwards-compatible interface\n  CodeMirror.newFoldFunction = function(rangeFinder, widget) {\n    return function(cm, pos) { doFold(cm, pos, {rangeFinder: rangeFinder, widget: widget}); };\n  };\n\n  // New-style interface\n  CodeMirror.defineExtension(\"foldCode\", function(pos, options, force) {\n    doFold(this, pos, options, force);\n  });\n\n  CodeMirror.defineExtension(\"isFolded\", function(pos) {\n    var marks = this.findMarksAt(pos);\n    for (var i = 0; i < marks.length; ++i)\n      if (marks[i].__isFold) return true;\n  });\n\n  CodeMirror.commands.toggleFold = function(cm) {\n    cm.foldCode(cm.getCursor());\n  };\n  CodeMirror.commands.fold = function(cm) {\n    cm.foldCode(cm.getCursor(), null, \"fold\");\n  };\n  CodeMirror.commands.unfold = function(cm) {\n    cm.foldCode(cm.getCursor(), null, \"unfold\");\n  };\n  CodeMirror.commands.foldAll = function(cm) {\n    cm.operation(function() {\n      for (var i = cm.firstLine(), e = cm.lastLine(); i <= e; i++)\n        cm.foldCode(CodeMirror.Pos(i, 0), null, \"fold\");\n    });\n  };\n  CodeMirror.commands.unfoldAll = function(cm) {\n    cm.operation(function() {\n      for (var i = cm.firstLine(), e = cm.lastLine(); i <= e; i++)\n        cm.foldCode(CodeMirror.Pos(i, 0), null, \"unfold\");\n    });\n  };\n\n  CodeMirror.registerHelper(\"fold\", \"combine\", function() {\n    var funcs = Array.prototype.slice.call(arguments, 0);\n    return function(cm, start) {\n      for (var i = 0; i < funcs.length; ++i) {\n        var found = funcs[i](cm, start);\n        if (found) return found;\n      }\n    };\n  });\n\n  CodeMirror.registerHelper(\"fold\", \"auto\", function(cm, start) {\n    var helpers = cm.getHelpers(start, \"fold\");\n    for (var i = 0; i < helpers.length; i++) {\n      var cur = helpers[i](cm, start);\n      if (cur) return cur;\n    }\n  });\n\n  var defaultOptions = {\n    rangeFinder: CodeMirror.fold.auto,\n    widget: \"\\u2194\",\n    minFoldSize: 0,\n    scanUp: false\n  };\n\n  CodeMirror.defineOption(\"foldOptions\", null);\n\n  function getOption(cm, options, name) {\n    if (options && options[name] !== undefined)\n      return options[name];\n    var editorOptions = cm.options.foldOptions;\n    if (editorOptions && editorOptions[name] !== undefined)\n      return editorOptions[name];\n    return defaultOptions[name];\n  }\n});\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"), require(\"./foldcode\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\", \"./foldcode\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.defineOption(\"foldGutter\", false, function(cm, val, old) {\n    if (old && old != CodeMirror.Init) {\n      cm.clearGutter(cm.state.foldGutter.options.gutter);\n      cm.state.foldGutter = null;\n      cm.off(\"gutterClick\", onGutterClick);\n      cm.off(\"change\", onChange);\n      cm.off(\"viewportChange\", onViewportChange);\n      cm.off(\"fold\", onFold);\n      cm.off(\"unfold\", onFold);\n      cm.off(\"swapDoc\", updateInViewport);\n    }\n    if (val) {\n      cm.state.foldGutter = new State(parseOptions(val));\n      updateInViewport(cm);\n      cm.on(\"gutterClick\", onGutterClick);\n      cm.on(\"change\", onChange);\n      cm.on(\"viewportChange\", onViewportChange);\n      cm.on(\"fold\", onFold);\n      cm.on(\"unfold\", onFold);\n      cm.on(\"swapDoc\", updateInViewport);\n    }\n  });\n\n  var Pos = CodeMirror.Pos;\n\n  function State(options) {\n    this.options = options;\n    this.from = this.to = 0;\n  }\n\n  function parseOptions(opts) {\n    if (opts === true) opts = {};\n    if (opts.gutter == null) opts.gutter = \"CodeMirror-foldgutter\";\n    if (opts.indicatorOpen == null) opts.indicatorOpen = \"CodeMirror-foldgutter-open\";\n    if (opts.indicatorFolded == null) opts.indicatorFolded = \"CodeMirror-foldgutter-folded\";\n    return opts;\n  }\n\n  function isFolded(cm, line) {\n    var marks = cm.findMarksAt(Pos(line));\n    for (var i = 0; i < marks.length; ++i)\n      if (marks[i].__isFold && marks[i].find().from.line == line) return true;\n  }\n\n  function marker(spec) {\n    if (typeof spec == \"string\") {\n      var elt = document.createElement(\"div\");\n      elt.className = spec + \" CodeMirror-guttermarker-subtle\";\n      return elt;\n    } else {\n      return spec.cloneNode(true);\n    }\n  }\n\n  function updateFoldInfo(cm, from, to) {\n    var opts = cm.state.foldGutter.options, cur = from;\n    cm.eachLine(from, to, function(line) {\n      var mark = null;\n      if (isFolded(cm, cur)) {\n        mark = marker(opts.indicatorFolded);\n      } else {\n        var pos = Pos(cur, 0), func = opts.rangeFinder || CodeMirror.fold.auto;\n        var range = func && func(cm, pos);\n        if (range && range.from.line + 1 < range.to.line)\n          mark = marker(opts.indicatorOpen);\n      }\n      cm.setGutterMarker(line, opts.gutter, mark);\n      ++cur;\n    });\n  }\n\n  function updateInViewport(cm) {\n    var vp = cm.getViewport(), state = cm.state.foldGutter;\n    if (!state) return;\n    cm.operation(function() {\n      updateFoldInfo(cm, vp.from, vp.to);\n    });\n    state.from = vp.from; state.to = vp.to;\n  }\n\n  function onGutterClick(cm, line, gutter) {\n    var opts = cm.state.foldGutter.options;\n    if (gutter != opts.gutter) return;\n    cm.foldCode(Pos(line, 0), opts.rangeFinder);\n  }\n\n  function onChange(cm) {\n    var state = cm.state.foldGutter, opts = cm.state.foldGutter.options;\n    state.from = state.to = 0;\n    clearTimeout(state.changeUpdate);\n    state.changeUpdate = setTimeout(function() { updateInViewport(cm); }, opts.foldOnChangeTimeSpan || 600);\n  }\n\n  function onViewportChange(cm) {\n    var state = cm.state.foldGutter, opts = cm.state.foldGutter.options;\n    clearTimeout(state.changeUpdate);\n    state.changeUpdate = setTimeout(function() {\n      var vp = cm.getViewport();\n      if (state.from == state.to || vp.from - state.to > 20 || state.from - vp.to > 20) {\n        updateInViewport(cm);\n      } else {\n        cm.operation(function() {\n          if (vp.from < state.from) {\n            updateFoldInfo(cm, vp.from, state.from);\n            state.from = vp.from;\n          }\n          if (vp.to > state.to) {\n            updateFoldInfo(cm, state.to, vp.to);\n            state.to = vp.to;\n          }\n        });\n      }\n    }, opts.updateViewportTimeSpan || 400);\n  }\n\n  function onFold(cm, from) {\n    var state = cm.state.foldGutter, line = from.line;\n    if (line >= state.from && line < state.to)\n      updateFoldInfo(cm, line, line + 1);\n  }\n});\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  var ie_lt8 = /MSIE \\d/.test(navigator.userAgent) &&\n    (document.documentMode == null || document.documentMode < 8);\n\n  var Pos = CodeMirror.Pos;\n\n  var matching = {\"(\": \")>\", \")\": \"(<\", \"[\": \"]>\", \"]\": \"[<\", \"{\": \"}>\", \"}\": \"{<\"};\n\n  function findMatchingBracket(cm, where, strict, config) {\n    var line = cm.getLineHandle(where.line), pos = where.ch - 1;\n    var match = (pos >= 0 && matching[line.text.charAt(pos)]) || matching[line.text.charAt(++pos)];\n    if (!match) return null;\n    var dir = match.charAt(1) == \">\" ? 1 : -1;\n    if (strict && (dir > 0) != (pos == where.ch)) return null;\n    var style = cm.getTokenTypeAt(Pos(where.line, pos + 1));\n\n    var found = scanForBracket(cm, Pos(where.line, pos + (dir > 0 ? 1 : 0)), dir, style || null, config);\n    if (found == null) return null;\n    return {from: Pos(where.line, pos), to: found && found.pos,\n            match: found && found.ch == match.charAt(0), forward: dir > 0};\n  }\n\n  // bracketRegex is used to specify which type of bracket to scan\n  // should be a regexp, e.g. /[[\\]]/\n  //\n  // Note: If \"where\" is on an open bracket, then this bracket is ignored.\n  //\n  // Returns false when no bracket was found, null when it reached\n  // maxScanLines and gave up\n  function scanForBracket(cm, where, dir, style, config) {\n    var maxScanLen = (config && config.maxScanLineLength) || 10000;\n    var maxScanLines = (config && config.maxScanLines) || 1000;\n\n    var stack = [];\n    var re = config && config.bracketRegex ? config.bracketRegex : /[(){}[\\]]/;\n    var lineEnd = dir > 0 ? Math.min(where.line + maxScanLines, cm.lastLine() + 1)\n                          : Math.max(cm.firstLine() - 1, where.line - maxScanLines);\n    for (var lineNo = where.line; lineNo != lineEnd; lineNo += dir) {\n      var line = cm.getLine(lineNo);\n      if (!line) continue;\n      var pos = dir > 0 ? 0 : line.length - 1, end = dir > 0 ? line.length : -1;\n      if (line.length > maxScanLen) continue;\n      if (lineNo == where.line) pos = where.ch - (dir < 0 ? 1 : 0);\n      for (; pos != end; pos += dir) {\n        var ch = line.charAt(pos);\n        if (re.test(ch) && (style === undefined || cm.getTokenTypeAt(Pos(lineNo, pos + 1)) == style)) {\n          var match = matching[ch];\n          if ((match.charAt(1) == \">\") == (dir > 0)) stack.push(ch);\n          else if (!stack.length) return {pos: Pos(lineNo, pos), ch: ch};\n          else stack.pop();\n        }\n      }\n    }\n    return lineNo - dir == (dir > 0 ? cm.lastLine() : cm.firstLine()) ? false : null;\n  }\n\n  function matchBrackets(cm, autoclear, config) {\n    // Disable brace matching in long lines, since it'll cause hugely slow updates\n    var maxHighlightLen = cm.state.matchBrackets.maxHighlightLineLength || 1000;\n    var marks = [], ranges = cm.listSelections();\n    for (var i = 0; i < ranges.length; i++) {\n      var match = ranges[i].empty() && findMatchingBracket(cm, ranges[i].head, false, config);\n      if (match && cm.getLine(match.from.line).length <= maxHighlightLen) {\n        var style = match.match ? \"CodeMirror-matchingbracket\" : \"CodeMirror-nonmatchingbracket\";\n        marks.push(cm.markText(match.from, Pos(match.from.line, match.from.ch + 1), {className: style}));\n        if (match.to && cm.getLine(match.to.line).length <= maxHighlightLen)\n          marks.push(cm.markText(match.to, Pos(match.to.line, match.to.ch + 1), {className: style}));\n      }\n    }\n\n    if (marks.length) {\n      // Kludge to work around the IE bug from issue #1193, where text\n      // input stops going to the textare whever this fires.\n      if (ie_lt8 && cm.state.focused) cm.display.input.focus();\n\n      var clear = function() {\n        cm.operation(function() {\n          for (var i = 0; i < marks.length; i++) marks[i].clear();\n        });\n      };\n      if (autoclear) setTimeout(clear, 800);\n      else return clear;\n    }\n  }\n\n  var currentlyHighlighted = null;\n  function doMatchBrackets(cm) {\n    cm.operation(function() {\n      if (currentlyHighlighted) {currentlyHighlighted(); currentlyHighlighted = null;}\n      currentlyHighlighted = matchBrackets(cm, false, cm.state.matchBrackets);\n    });\n  }\n\n  CodeMirror.defineOption(\"matchBrackets\", false, function(cm, val, old) {\n    if (old && old != CodeMirror.Init)\n      cm.off(\"cursorActivity\", doMatchBrackets);\n    if (val) {\n      cm.state.matchBrackets = typeof val == \"object\" ? val : {};\n      cm.on(\"cursorActivity\", doMatchBrackets);\n    }\n  });\n\n  CodeMirror.defineExtension(\"matchBrackets\", function() {matchBrackets(this, true);});\n  CodeMirror.defineExtension(\"findMatchingBracket\", function(pos, strict, config){\n    return findMatchingBracket(this, pos, strict, config);\n  });\n  CodeMirror.defineExtension(\"scanForBracket\", function(pos, dir, style, config){\n    return scanForBracket(this, pos, dir, style, config);\n  });\n});\n"]}