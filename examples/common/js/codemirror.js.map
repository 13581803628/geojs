{"version":3,"file":"codemirror.js","sources":["../../../../bower_components/jsonlint/lib/jsonlint.js","../../../../bower_components/codemirror/lib/codemirror.js","../../../../bower_components/codemirror/mode/javascript/javascript.js","../../../../bower_components/codemirror/addon/lint/lint.js","../../../../bower_components/codemirror/addon/lint/json-lint.js","../../../../bower_components/codemirror/addon/fold/brace-fold.js","../../../../bower_components/codemirror/addon/fold/foldcode.js","../../../../bower_components/codemirror/addon/fold/foldgutter.js","../../../../bower_components/codemirror/addon/edit/matchbrackets.js"],"names":["jsonlint","parser","trace","yy","symbols_","error","JSONString","STRING","JSONNumber","NUMBER","JSONNullLiteral","NULL","JSONBooleanLiteral","TRUE","FALSE","JSONText","JSONValue","EOF","JSONObject","JSONArray","{","}","JSONMemberList","JSONMember",":",",","[","]","JSONElementList","$accept","$end","terminals_",2,4,6,8,10,11,14,17,18,21,22,23,24,"productions_","performAction","yytext","yyleng","yylineno","yystate","$$","$0","length","this","$","replace","Number","push","table",3,5,7,9,12,13,15,16,1,19,20,25,"defaultActions","parseError","str","Error","parse","input","popStack","n","stack","vstack","lstack","lex","token","self","lexer","recovering","TERROR","setInput","yylloc","yyloc","symbol","preErrorSymbol","state","action","r","p","len","newState","expected","yyval","errStr","showPosition","join","text","match","line","loc","toString","Array","_$","first_line","last_line","first_column","last_column","call","slice","hash","_input","_more","_less","done","matched","conditionStack","ch","lines","unput","more","less","pastInput","past","substr","upcomingInput","next","pre","c","tempMatch","index","rules","_currentRules","i","options","flex","begin","condition","popState","pop","conditions","topState","pushState","yy_","$avoiding_name_collisions","YY_START","INITIAL","inclusive","require","exports","apply","arguments","main","args","process","source","readFileSync","cwd","path","read","charset","module","argv","mod","define","amd","CodeMirror","place","copyObj","defaults","setGuttersForLineNumbers","doc","value","Doc","mode","display","Display","wrapper","updateGutters","themeChanged","lineWrapping","className","autofocus","mobile","focusInput","keyMaps","overlays","modeGen","overwrite","focused","suppressEdits","pasteIncoming","cutIncoming","draggingText","highlight","Delayed","ie","ie_version","setTimeout","bind","resetInput","registerEventHandlers","ensureGlobalHandlers","startOperation","curOp","forceUpdate","attachDoc","activeElt","onFocus","onBlur","opt","optionHandlers","hasOwnProperty","Init","maybeUpdateLineNumberWidth","initHooks","endOperation","d","elt","webkit","style","width","setAttribute","ios","border","inputDiv","scrollbarH","scrollbarV","scrollbarFiller","gutterFiller","lineDiv","selectionDiv","cursorDiv","measure","lineMeasure","lineSpace","mover","sizer","heightForcer","scrollerCutOff","gutters","lineGutter","scroller","zIndex","paddingRight","draggable","khtml","height","position","minHeight","minWidth","appendChild","viewFrom","viewTo","first","view","externalMeasured","viewOffset","lastSizeC","updateLineNumbers","lineNumWidth","lineNumInnerWidth","lineNumChars","prevInput","alignWidgets","pollingFast","poll","cachedCharWidth","cachedTextHeight","cachedPaddingH","inaccurateSelection","maxLine","maxLineLength","maxLineChanged","wheelDX","wheelDY","wheelStartX","wheelStartY","shift","selForContextMenu","loadMode","cm","getMode","modeOption","resetModeState","iter","stateAfter","styles","frontier","startWorker","regChange","wrappingChanged","addClass","rmClass","findMaxLine","estimateLineHeights","clearCaches","updateScrollbars","estimateHeight","th","textHeight","wrapping","perLine","Math","max","clientWidth","charWidth","lineIsHidden","widgetsHeight","widgets","ceil","est","estHeight","updateLineHeight","keyMapChanged","map","keyMap","theme","guttersChanged","alignHorizontally","specs","removeChildren","gutterClass","gElt","updateGutterSpace","offsetWidth","marginLeft","left","fixedGutter","lineLength","merged","cur","collapsedSpanAtStart","found","find","from","to","collapsedSpanAtEnd","getLine","indexOf","lineNumbers","concat","splice","hScrollbarTakesSpace","clientHeight","measureForScrollbars","scroll","barHeight","scrollWidth","barWidth","docHeight","round","paddingVert","sWidth","scrollbarWidth","scrollHeight","needsH","needsV","bottom","firstChild","right","coverGutterNextToScrollbar","checkedOverlayScrollbar","w","mac","mac_geMountainLion","barMouseDown","e","e_target","operation","onMouseDown","on","visibleLines","viewport","top","scrollTop","floor","paddingTop","lineAtHeight","ensure","ensureFrom","ensureTo","heightAtLine","min","lastLine","comp","compensateForHScroll","scrollLeft","gutterW","hidden","gutter","align","alignable","j","last","lineNumberFor","size","test","innerW","padding","String","lineNumberFormatter","firstLineNumber","getBoundingClientRect","DisplayUpdate","force","visible","editorIsHidden","wrapperHeight","oldViewFrom","oldViewTo","oldScrollerWidth","dims","getDimensions","updateDisplayIfNeeded","update","resetView","countDirtyView","end","viewportMargin","sawCollapsedSpans","visualLineNo","visualLineEndNo","different","adjustView","toUpdate","patchDisplay","offsetHeight","focus","postUpdateDisplay","updateHeightsInViewport","barMeasure","updateSelection","setDocumentHeight","signalLater","updateDisplaySimple","checkForWebkitWidthBug","prevBottom","offsetTop","bot","node","box","diff","updateWidgetHeight","rest","gutterLeft","clientLeft","nextSibling","offsetLeft","fixedPos","gutterTotalWidth","gutterWidth","wrapperWidth","updateNumbersFrom","rm","currentWheelTarget","parentNode","removeChild","container","lineN","lineView","updateNumber","lineNumber","changes","updateLineForChanges","document","createTextNode","buildLineElement","insertBefore","type","updateLineText","updateLineGutter","updateLineClasses","updateLineWidgets","ensureLineWrapped","replaceChild","updateLineBackground","cls","bgClass","background","wrap","getLineContent","ext","built","buildLineContent","textClass","wrapClass","markers","gutterMarkers","gutterWrap","k","id","insertLineWidgets","insertLineWidgetsFor","allowAbove","ws","widget","handleMouseEvents","ignoreEvents","positionLineWidget","above","noHScroll","coverGutter","paddingLeft","copyPos","x","Pos","maxPos","a","b","cmp","minPos","Selection","ranges","primIndex","Range","anchor","head","normalizeSelection","prim","sort","prev","inv","empty","simpleSelection","clipLine","clipPos","pos","clipToLen","linelen","isLine","l","clipPosArray","array","out","extendRange","range","other","extend","posBefore","extendSelection","setSelection","sel","primary","extendSelections","heads","newSel","replaceOneSelection","setSimpleSelection","filterSelectionChange","obj","signal","setSelectionReplaceHistory","history","lst","setSelectionNoUndo","addSelectionToHistory","hasHandler","bias","setSelectionInner","skipAtomicInSelection","ensureCursorVisible","equals","updateInput","selectionChanged","signalCursorActivity","reCheckSelection","sel_dontScroll","mayClear","newAnchor","skipAtomic","newHead","flipped","curPos","dir","cantEdit","search","markedSpans","sp","m","marker","inclusiveLeft","inclusiveRight","explicitlyCleared","atomic","newPos","drawSelection","result","curFragment","cursors","createDocumentFragment","selFragment","selection","collapsed","showCursorWhenSelecting","drawSelectionCursor","drawSelectionRange","moveInputWithCursor","headPos","cursorCoords","wrapOff","lineOff","teTop","teLeft","showSelection","drawn","removeChildrenAndAdd","output","singleCursorHeightPerLine","cursor","cursorHeight","otherCursor","add","fragment","rightSide","drawForLine","fromArg","toArg","coords","charCoords","lineObj","start","lineLen","iterateBidiSections","getOrder","rightPos","leftPos","tmp","leftSide","paddingH","sFrom","sTo","fromLine","toLine","singleVLine","visualLine","leftEnd","rightStart","restartBlink","clearInterval","blinker","visibility","cursorBlinkRate","setInterval","time","startState","set","highlightWorker","Date","workTime","copyState","getStateBefore","changedLines","oldStyles","highlighted","highlightLine","oldCls","styleClasses","newCls","classes","ischange","processLine","workDelay","runInOp","regLineChange","findStartLine","precise","minindent","minline","lim","innerMode","indented","countColumn","tabSize","save","window","getComputedStyle","currentStyle","data","parseInt","isNaN","ensureLineHeights","rect","curWidth","heights","rects","getClientRects","abs","mapFromLineView","cache","maps","caches","lineNo","before","updateExternalMeasurement","LineView","measureChar","measureCharPrepared","prepareMeasureForLine","findViewForLine","findViewIndex","info","hasHeights","prepared","varHeight","key","measureCharInner","bogus","rtop","rbottom","collapse","mStart","mEnd","insertLeft","nodeType","isExtendingChar","charAt","nullRect","maybeUpdateRectForZooming","rSpan","rbot","mid","screen","logicalXDPI","deviceXDPI","hasBadZoomedRects","scaleX","scaleY","logicalYDPI","deviceYDPI","clearLineMeasurementCacheFor","clearLineMeasurementCache","externalMeasure","pageScrollX","pageXOffset","documentElement","body","pageScrollY","pageYOffset","intoCoordSystem","context","widgetHeight","yOff","lOff","xOff","fromCoordSystem","localBox","lineSpaceBox","preparedMeasure","get","getBidi","partPos","part","order","level","bidiLeft","bidiRight","getBidiPartAt","val","bidiOther","estimateCoords","PosWithInfo","outside","xRel","coordsChar","y","coordsCharInner","mergedPos","getX","wrongLine","innerOff","adjust","bidi","dist","lineLeft","lineRight","fromX","fromOutside","toX","toOutside","moveVisually","xDiff","step","middle","middleX","measureText","viewChanged","startHeight","typing","changeObjs","cursorActivityHandlers","cursorActivityCalled","updateMaxLine","scrollToPos","nextOpId","operationGroup","ops","ownsGroup","delayedCallbacks","fireCallbacksForOps","group","callbacks","op","endOperations","endOperation_R1","endOperation_W1","endOperation_R2","endOperation_W2","endOperation_finish","mustUpdate","updatedDisplay","adjustWidthTo","maxScrollLeft","newSelectionNodes","setScrollLeft","forceScroll","scrollPosIntoView","margin","isCursor","maybeScrollWindow","maybeHiddenMarkers","unhidden","maybeUnhiddenMarkers","f","methodOp","docMethodOp","visualLineContinued","buildViewArray","nextPos","lendiff","cut","viewCuttingPoint","cutTop","cutBot","arr","oldN","newN","dirty","slowPoll","pollInterval","readInput","fastPoll","changed","missed","hasSelection","isReadOnly","disableInput","fakedLastChar","substring","somethingSelected","inputHasSelection","withOp","charCodeAt","same","inserted","textLines","splitLines","multiPaste","lastCopied","changeEvent","origin","makeChange","electricChars","smartIndent","getModeAt","changeEnd","indentLine","electricInput","minimal","selected","hasCopyEvent","getSelection","content","selectInput","readOnly","ensureFocus","reFocus","drag_","signalDOMEvent","e_stop","prepareCopyCut","getSelections","lineRange","getRange","setSelections","posFromMouse","clickInGutter","eventInWidget","e_preventDefault","word","findWordAt","captureRightClick","onContextMenu","setScrollTop","onScrollWheel","onKeyUp","onKeyDown","onKeyPress","dragDrop","onDragStart","onDrop","lastMiddleDown","selectionStart","selectionEnd","blur","onResize","setSize","liberal","forRect","target","space","clientX","clientY","colDiff","shiftKey","e_button","leftButtonDown","now","lastDoubleClick","lastClick","modifier","metaKey","ctrlKey","dragAndDrop","contains","leftButtonStartDrag","leftButtonSelect","dragEnd","e2","off","addNew","extendTo","lastPos","startCol","posCol","findColumn","startSel","ourIndex","scrollIntoView","oldRange","ourRange","sel_mouse","curCount","counter","editorSize","move","up","lastSelOrigin","altKey","gutterEvent","prevent","signalfn","mX","mY","lineBox","e_defaultPrevented","g","childNodes","lastDrop","files","dataTransfer","FileReader","File","loadFile","file","reader","onload","change","readAsText","getData","listSelections","replaceRange","replaceSelection","setData","setDragImage","safari","img","src","presto","_top","gecko","isScroller","dx","wheelDeltaX","dy","wheelDeltaY","detail","axis","HORIZONTAL_AXIS","VERTICAL_AXIS","wheelDelta","outer","wheelPixelsPerUnit","pixels","wheelSamples","movedX","movedY","sample","doHandleBinding","bound","dropShift","commands","prevShift","Pass","allKeyMaps","extraKeys","handleKeyBinding","startMap","getKeyMap","auto","clearTimeout","maybeTransition","isModifierKey","name","keyName","handled","keymaps","lookupKey","motion","handleCharBinding","keyCode","returnValue","code","lastStoppedKey","showCrossHair","charCode","which","fromCharCode","prepareSelectAllHack","extval","rehide","cssText","oldCSS","scrollPos","selectAll","detectingSelectAll","contextMenuInGutter","reset","resetSelectionOnContextMenu","oldScrollY","scrollY","scrollTo","mouseup","adjustForChange","computeSelAfterChange","offsetPos","old","nw","computeReplacedSel","hint","oldPrev","newPrev","filterChange","canceled","cancel","undefined","ignoreReadOnly","split","sawReadOnlySpans","removeReadOnlyRanges","makeChangeInner","selAfter","addChangeToHistory","makeChangeSingleDoc","stretchSpansOverChange","rebased","linkedDocs","sharedHist","rebaseHist","makeChangeFromHistory","allowSelectionOnly","event","hist","undone","dest","lastOrigin","pushSelectionToHistory","clearRedo","antiChanges","generation","maxGeneration","filter","historyChangeFromChange","after","mergeOldSpans","shiftDoc","distance","spans","removed","getBetween","makeChangeSingleDocInEditor","updateDoc","recomputeMaxLength","checkWidthStart","isWholeLineUpdate","changesHandler","changeHandler","doScroll","innerHeight","phantom","scrollNode","limit","endCoords","calculateScrollPos","startTop","startLeft","x1","y1","x2","y2","snapMargin","screentop","docBottom","atTop","atBottom","newTop","screenleft","screenw","tooWide","addToScrollPos","resolveScrollToPos","getCursor","cursorScrollMargin","sPos","how","aggressive","indent","curSpace","indentation","curSpaceString","indentUnit","indentString","indentWithTabs","spaceStr","changeLine","handle","changeType","no","deleteNearSelection","compute","kill","toKill","replaced","findPosH","unit","visually","findNextLine","possible","moveOnce","boundToLine","moveLogically","origDir","sawType","helper","getHelper","isWordChar","hitSide","findPosV","pageSize","option","deflt","notOnInit","markText","shared","markTextShared","TextMarker","clearWhenEmpty","replacedWith","widgetNode","conflictingCollapsedRange","addToHistory","curLine","addMarkedSpan","MarkedSpan","clearOnEnter","clear","clearHistory","nextMarkerId","title","startStyle","endStyle","cloneNode","linked","isParent","SharedTextMarker","findSharedMarkers","findMarks","parent","copySharedMarkers","mFrom","mTo","subMark","detachSharedMarkers","subMarker","getMarkedSpanFor","span","removeMarkedSpan","attachLine","markedSpansBefore","startCh","isInsert","startsBefore","endsAfter","markedSpansAfter","endCh","oldFirst","oldLast","sameLine","offset","clearEmptySpans","newMarkers","gapMarkers","gap","getOldSpans","stretched","oldCur","stretchCur","mark","parts","mk","newParts","dfrom","dto","detachMarkedSpans","detachLine","attachMarkedSpans","extraLeft","extraRight","compareCollapsedMarkers","lenDiff","aPos","bPos","fromCmp","toCmp","collapsedSpanAtSide","sps","vis","lineIsHiddenInner","adjustScrollWhenAboveVisible","parentStyle","getGutterElement","addLineWidget","LineWidget","insertAt","aboveVisible","updateLine","cleanUpLine","extractLineClasses","lineClass","prop","RegExp","callBlankLine","blankLine","inner","readToken","stream","runMode","lineClasses","forceToEnd","flattenSpans","curStart","curStyle","StringStream","eol","maxHighlightLength","addModeClass","mName","st","o","overlay","at","i_end","opaque","getLineStyles","startAt","interpretTokenStyle","styleToClassCacheWithMode","styleToClassCache","builder","col","addToken","buildToken","getOption","buildTokenSplitSpaces","hasBadBidiRects","buildTokenBadBidi","insertLineContent","joinClasses","zeroWidthElement","defaultSpecialCharPlaceholder","special","specialChars","mustWrap","lastIndex","exec","skipped","txt","tabWidth","specialCharPlaceholder","fullStyle","buildCollapsedSpan","ignoreWidget","allText","spanStyle","spanEndStyle","spanStartStyle","nextChange","foundBookmarks","upto","tokenText","wholeLineUpdateBefore","spansFor","firstLine","lastText","lastSpans","nlines","added","Line","remove","insert","LeafChunk","BranchChunk","children","chunkSize","sharedHistOnly","propagate","skip","rel","chunk","child","sz","getLines","h","lh","bidiOrdering","History","startGen","undoDepth","lastModTime","lastSelTime","lastOp","lastSelOp","histChange","attachLocalSpans","clearSelectionEvents","lastChangeEvent","opId","historyEventDelay","selectionEventCanBeMerged","existing","removeClearedSpans","copyHistoryArray","events","newGroup","instantiateSel","copy","prototype","deepCopy","newChanges","rebaseHistSelSingle","rebaseHistArray","sub","ok","copied","defaultPrevented","srcElement","button","emitter","bnd","_handlers","list","orphanDelayedCallbacks","fireOrphanDelayed","delayed","override","codemirrorIgnore","cursorActivity","eventMixin","ctor","string","goal","nextTab","spaceStrs","createObj","base","props","inst","Object","create","isWordCharBasic","isEmpty","extendingChars","tag","createElement","count","activeElement","classTest","as","forEachCodeMirror","getElementsByClassName","byClass","globalsRegistered","registerGlobalHandlers","resizeTimer","knownScrollbarWidth","zwspSupported","badBidiRects","r0","r1","badZoomedRects","normal","fromRange","lineStart","visual","lineEnd","lineStartSmart","firstNonWS","inWS","compareBidiLevel","linedir","moveInLine","byUnit","navigator","userAgent","ie_upto10","ie_11up","documentMode","qtwebkit","chrome","vendor","platform","windows","presto_version","flipCtrlCmd","cmpPos","here","there","constructor","setOption","getDoc","addKeyMap","removeKeyMap","addOverlay","spec","modeSpec","removeOverlay","indentSelection","newRanges","getTokenAt","current","getTokenTypeAt","getHelpers","helpers","help","helperType","_global","pred","getStateAfter","defaultTextHeight","defaultCharWidth","setGutterMarker","gutterID","clearGutter","removeLineWidget","lineInfo","getViewport","addWidget","vert","horiz","vspace","hspace","triggerOnKeyDown","triggerOnKeyPress","triggerOnKeyUp","execCommand","cmd","amount","moveH","extendSelectionsBy","rtlMoveVisually","sel_move","deleteH","goalColumn","moveV","goals","startChar","check","toggleOverwrite","hasFocus","getScrollInfo","co","interpret","refresh","oldHeight","swapDoc","getInputField","getWrapperElement","getScrollerElement","setValue","integer","disabled","tabIndex","modes","mimeModes","defineMode","dependencies","defineMIME","mime","resolveMode","mfactory","modeObj","modeExtensions","exts","modeProps","skipToEnd","extendMode","properties","defineExtension","func","defineDocExtension","defineOption","defineInitHook","registerHelper","registerGlobalHelper","predicate","nstate","a1","a2","singleSelection","killLine","deleteLine","delLineLeft","delWrappedLineLeft","delWrappedLineRight","undo","redo","undoSelection","redoSelection","goDocStart","goDocEnd","goLineStart","goLineStartSmart","goLineEnd","goLineRight","goLineLeft","goLineLeftSmart","goLineUp","goLineDown","goPageUp","goPageDown","goCharLeft","goCharRight","goColumnLeft","goColumnRight","goWordLeft","goGroupRight","goGroupLeft","goWordRight","delCharBefore","delCharAfter","delWordBefore","delWordAfter","delGroupBefore","delGroupAfter","indentAuto","indentMore","indentLess","insertTab","insertSoftTab","spaces","replaceSelections","defaultTab","transposeChars","newlineAndIndent","basic","Left","Right","Up","Down","End","Home","PageUp","PageDown","Delete","Backspace","Shift-Backspace","Tab","Shift-Tab","Enter","Insert","Esc","pcDefault","Ctrl-A","Ctrl-D","Ctrl-Z","Shift-Ctrl-Z","Ctrl-Y","Ctrl-Home","Ctrl-End","Ctrl-Up","Ctrl-Down","Ctrl-Left","Ctrl-Right","Alt-Left","Alt-Right","Ctrl-Backspace","Ctrl-Delete","Ctrl-S","Ctrl-F","Ctrl-G","Shift-Ctrl-G","Shift-Ctrl-F","Shift-Ctrl-R","Ctrl-[","Ctrl-]","Ctrl-U","Shift-Ctrl-U","Alt-U","fallthrough","macDefault","Cmd-A","Cmd-D","Cmd-Z","Shift-Cmd-Z","Cmd-Y","Cmd-Home","Cmd-Up","Cmd-End","Cmd-Down","Cmd-Left","Cmd-Right","Alt-Backspace","Ctrl-Alt-Backspace","Alt-Delete","Cmd-S","Cmd-F","Cmd-G","Shift-Cmd-G","Cmd-Alt-F","Shift-Cmd-Alt-F","Cmd-[","Cmd-]","Cmd-Backspace","Cmd-Delete","Cmd-U","Shift-Cmd-U","emacsy","Ctrl-B","Ctrl-P","Ctrl-N","Alt-F","Alt-B","Ctrl-E","Ctrl-V","Shift-Ctrl-V","Ctrl-H","Alt-D","Ctrl-K","Ctrl-T","lookup","nofallthrough","keyNames","noShift","altGraphKey","fromTextArea","textarea","getValue","tabindex","placeholder","getAttribute","form","leaveSubmitMethodAlone","realSubmit","submit","wrappedSubmit","getTextArea","toTextArea","lastColumnPos","lastColumnValue","sol","peek","eat","eatWhile","eatSpace","skipTo","backUp","column","pattern","consume","caseInsensitive","cased","toLowerCase","hideFirstChars","side","dHeight","oldH","removeInner","insertInner","iterN","spilled","newleaf","maybeSpill","me","sibling","myIndex","used","nextDocId","cleanGeneration","lineSep","getLineHandle","getLineNumber","getLineHandleVisualStart","lineCount","setCursor","addSelection","dup","setExtending","getExtending","historySize","markClean","changeGeneration","forceSplit","isClean","gen","getHistory","setHistory","histData","addLineClass","where","removeLineClass","setBookmark","realOpts","findMarksAt","getAllMarks","posFromIndex","indexFromPos","copyHistory","linkedDoc","unlinkDoc","link","splitIds","iterLinkedDocs","getEditor","eachLine","dontDelegate","method","preventDefault","e_stopPropagation","stopPropagation","cancelBubble","addEventListener","attachEvent","removeEventListener","detachEvent","ms","startIndex","startValue","select","_e","nonASCIISingleCaseWordChar","toUpperCase","createRange","setEnd","setStart","createTextRange","moveToElementText","moveEnd","moveStart","div","nl","rt","te","ownerDocument","parentElement","compareEndPoints","oncopy",27,32,33,34,35,36,37,38,39,40,44,45,46,59,61,91,92,93,107,109,127,173,186,187,188,189,190,191,192,219,220,221,222,63232,63233,63234,63235,63272,63273,63275,63276,63277,63302,"charType","lowTypes","arabicTypes","BidiSpan","bidiRE","isNeutral","isStrong","countsAsLeft","countsAsNum","outerType","types","nstart","unshift","version","config","parserConfig","readRegexp","escaped","inSet","ret","tp","cont","tokenBase","tokenize","tokenString","tokenComment","lastType","isOperatorChar","tokenQuasi","wordRE","known","keywords","propertyIsEnumerable","quote","jsonldMode","isJsonldKeyword","maybeEnd","findFatArrow","fatArrowAt","arrow","depth","sawSomething","bracket","brackets","JSLexical","inScope","varname","v","localVars","cx","vars","parseJS","cc","marked","lexical","combinator","jsonMode","expression","statement","pass","register","inList","globalVars","pushcontext","defaultVars","popcontext","pushlex","poplex","expect","wanted","exp","vardef","block","maybeelse","functiondef","forspec","maybelabel","funarg","afterModule","afterExport","afterImport","expressionInner","expressionNoComma","noComma","arrowBodyNoComma","arrowBody","commasep","maybeop","maybeoperatorNoComma","maybeoperatorComma","atomicTypes","maybeexpressionNoComma","maybeexpression","comprehension","arrayLiteral","contCommasep","objprop","quasi","expr","property","continueQuasi","getterSetter","afterprop","what","proceed","maybetype","isTS","typedef","maybeAssign","vardefCont","proppattern","_type","forspec1","forspec2","formaybeinof","forspec3","classNameAfter","classBody","classGetterSetter","maybeFrom","importSpec","maybeArrayComprehension","statementIndent","jsonld","json","typescript","wordCharacters","kw","A","B","C","operator","atom","jsKeywords","if","while","with","else","do","try","finally","return","break","continue","new","delete","throw","debugger","var","const","let","function","catch","for","switch","case","default","in","typeof","instanceof","true","false","null","NaN","Infinity","class","super","yield","export","import","extends","tsKeywords","interface","public","private","protected","static","number","bool","any","attr","variable","regexp","jsonld-keyword","basecolumn","textAfter","firstChar","closing","doubleIndentSwitch","blockCommentStart","blockCommentEnd","lineComment","fold","showTooltip","tt","opacity","hideTooltip","showTooltipFor","hide","tooltip","LintState","hasGutter","timeout","onMouseOver","parseOptions","Function","getAnnotations","clearMarks","lint","GUTTER_ID","makeMarker","labels","severity","multiple","tooltips","getMaxSeverity","groupByLine","annotations","ann","annotationTooltip","tip","message","startLinting","passOptions","async","updateLinting","annotationsNotSorted","anns","maxSeverity","tipLabel","formatAnnotation","__annotation","onUpdateLinting","onChange","delay","popupSpanTooltip","hasLintGutter","findOpening","openCh","lineText","lastIndexOf","tokenType","startToken","endToken","nextOpen","nextClose","hasImport","semi","has","hasInclude","doFold","allowFolded","finder","minSize","marks","__isFold","cleared","myWidget","makeWidget","myRange","editorOptions","foldOptions","defaultOptions","newFoldFunction","rangeFinder","toggleFold","foldCode","unfold","foldAll","unfoldAll","funcs","minFoldSize","scanUp","State","opts","indicatorOpen","indicatorFolded","isFolded","updateFoldInfo","foldGutter","updateInViewport","vp","onGutterClick","changeUpdate","foldOnChangeTimeSpan","onViewportChange","updateViewportTimeSpan","onFold","findMatchingBracket","strict","matching","scanForBracket","forward","maxScanLen","maxScanLineLength","maxScanLines","re","bracketRegex","matchBrackets","autoclear","maxHighlightLen","maxHighlightLineLength","ie_lt8","doMatchBrackets","currentlyHighlighted","(",")"],"mappings":"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","sourcesContent":["/* Jison generated parser */\nvar jsonlint = (function(){\nvar parser = {trace: function trace() { },\nyy: {},\nsymbols_: {\"error\":2,\"JSONString\":3,\"STRING\":4,\"JSONNumber\":5,\"NUMBER\":6,\"JSONNullLiteral\":7,\"NULL\":8,\"JSONBooleanLiteral\":9,\"TRUE\":10,\"FALSE\":11,\"JSONText\":12,\"JSONValue\":13,\"EOF\":14,\"JSONObject\":15,\"JSONArray\":16,\"{\":17,\"}\":18,\"JSONMemberList\":19,\"JSONMember\":20,\":\":21,\",\":22,\"[\":23,\"]\":24,\"JSONElementList\":25,\"$accept\":0,\"$end\":1},\nterminals_: {2:\"error\",4:\"STRING\",6:\"NUMBER\",8:\"NULL\",10:\"TRUE\",11:\"FALSE\",14:\"EOF\",17:\"{\",18:\"}\",21:\":\",22:\",\",23:\"[\",24:\"]\"},\nproductions_: [0,[3,1],[5,1],[7,1],[9,1],[9,1],[12,2],[13,1],[13,1],[13,1],[13,1],[13,1],[13,1],[15,2],[15,3],[20,3],[19,1],[19,3],[16,2],[16,3],[25,1],[25,3]],\nperformAction: function anonymous(yytext,yyleng,yylineno,yy,yystate,$$,_$) {\n\nvar $0 = $$.length - 1;\nswitch (yystate) {\ncase 1: // replace escaped characters with actual character\n          this.$ = yytext.replace(/\\\\(\\\\|\")/g, \"$\"+\"1\")\n                     .replace(/\\\\n/g,'\\n')\n                     .replace(/\\\\r/g,'\\r')\n                     .replace(/\\\\t/g,'\\t')\n                     .replace(/\\\\v/g,'\\v')\n                     .replace(/\\\\f/g,'\\f')\n                     .replace(/\\\\b/g,'\\b');\n        \nbreak;\ncase 2:this.$ = Number(yytext);\nbreak;\ncase 3:this.$ = null;\nbreak;\ncase 4:this.$ = true;\nbreak;\ncase 5:this.$ = false;\nbreak;\ncase 6:return this.$ = $$[$0-1];\nbreak;\ncase 13:this.$ = {};\nbreak;\ncase 14:this.$ = $$[$0-1];\nbreak;\ncase 15:this.$ = [$$[$0-2], $$[$0]];\nbreak;\ncase 16:this.$ = {}; this.$[$$[$0][0]] = $$[$0][1];\nbreak;\ncase 17:this.$ = $$[$0-2]; $$[$0-2][$$[$0][0]] = $$[$0][1];\nbreak;\ncase 18:this.$ = [];\nbreak;\ncase 19:this.$ = $$[$0-1];\nbreak;\ncase 20:this.$ = [$$[$0]];\nbreak;\ncase 21:this.$ = $$[$0-2]; $$[$0-2].push($$[$0]);\nbreak;\n}\n},\ntable: [{3:5,4:[1,12],5:6,6:[1,13],7:3,8:[1,9],9:4,10:[1,10],11:[1,11],12:1,13:2,15:7,16:8,17:[1,14],23:[1,15]},{1:[3]},{14:[1,16]},{14:[2,7],18:[2,7],22:[2,7],24:[2,7]},{14:[2,8],18:[2,8],22:[2,8],24:[2,8]},{14:[2,9],18:[2,9],22:[2,9],24:[2,9]},{14:[2,10],18:[2,10],22:[2,10],24:[2,10]},{14:[2,11],18:[2,11],22:[2,11],24:[2,11]},{14:[2,12],18:[2,12],22:[2,12],24:[2,12]},{14:[2,3],18:[2,3],22:[2,3],24:[2,3]},{14:[2,4],18:[2,4],22:[2,4],24:[2,4]},{14:[2,5],18:[2,5],22:[2,5],24:[2,5]},{14:[2,1],18:[2,1],21:[2,1],22:[2,1],24:[2,1]},{14:[2,2],18:[2,2],22:[2,2],24:[2,2]},{3:20,4:[1,12],18:[1,17],19:18,20:19},{3:5,4:[1,12],5:6,6:[1,13],7:3,8:[1,9],9:4,10:[1,10],11:[1,11],13:23,15:7,16:8,17:[1,14],23:[1,15],24:[1,21],25:22},{1:[2,6]},{14:[2,13],18:[2,13],22:[2,13],24:[2,13]},{18:[1,24],22:[1,25]},{18:[2,16],22:[2,16]},{21:[1,26]},{14:[2,18],18:[2,18],22:[2,18],24:[2,18]},{22:[1,28],24:[1,27]},{22:[2,20],24:[2,20]},{14:[2,14],18:[2,14],22:[2,14],24:[2,14]},{3:20,4:[1,12],20:29},{3:5,4:[1,12],5:6,6:[1,13],7:3,8:[1,9],9:4,10:[1,10],11:[1,11],13:30,15:7,16:8,17:[1,14],23:[1,15]},{14:[2,19],18:[2,19],22:[2,19],24:[2,19]},{3:5,4:[1,12],5:6,6:[1,13],7:3,8:[1,9],9:4,10:[1,10],11:[1,11],13:31,15:7,16:8,17:[1,14],23:[1,15]},{18:[2,17],22:[2,17]},{18:[2,15],22:[2,15]},{22:[2,21],24:[2,21]}],\ndefaultActions: {16:[2,6]},\nparseError: function parseError(str, hash) {\n    throw new Error(str);\n},\nparse: function parse(input) {\n    var self = this,\n        stack = [0],\n        vstack = [null], // semantic value stack\n        lstack = [], // location stack\n        table = this.table,\n        yytext = '',\n        yylineno = 0,\n        yyleng = 0,\n        recovering = 0,\n        TERROR = 2,\n        EOF = 1;\n\n    //this.reductionCount = this.shiftCount = 0;\n\n    this.lexer.setInput(input);\n    this.lexer.yy = this.yy;\n    this.yy.lexer = this.lexer;\n    if (typeof this.lexer.yylloc == 'undefined')\n        this.lexer.yylloc = {};\n    var yyloc = this.lexer.yylloc;\n    lstack.push(yyloc);\n\n    if (typeof this.yy.parseError === 'function')\n        this.parseError = this.yy.parseError;\n\n    function popStack (n) {\n        stack.length = stack.length - 2*n;\n        vstack.length = vstack.length - n;\n        lstack.length = lstack.length - n;\n    }\n\n    function lex() {\n        var token;\n        token = self.lexer.lex() || 1; // $end = 1\n        // if token isn't its numeric value, convert\n        if (typeof token !== 'number') {\n            token = self.symbols_[token] || token;\n        }\n        return token;\n    }\n\n    var symbol, preErrorSymbol, state, action, a, r, yyval={},p,len,newState, expected;\n    while (true) {\n        // retreive state number from top of stack\n        state = stack[stack.length-1];\n\n        // use default actions if available\n        if (this.defaultActions[state]) {\n            action = this.defaultActions[state];\n        } else {\n            if (symbol == null)\n                symbol = lex();\n            // read action for current state and first input\n            action = table[state] && table[state][symbol];\n        }\n\n        // handle parse error\n        _handle_error:\n        if (typeof action === 'undefined' || !action.length || !action[0]) {\n\n            if (!recovering) {\n                // Report error\n                expected = [];\n                for (p in table[state]) if (this.terminals_[p] && p > 2) {\n                    expected.push(\"'\"+this.terminals_[p]+\"'\");\n                }\n                var errStr = '';\n                if (this.lexer.showPosition) {\n                    errStr = 'Parse error on line '+(yylineno+1)+\":\\n\"+this.lexer.showPosition()+\"\\nExpecting \"+expected.join(', ') + \", got '\" + this.terminals_[symbol]+ \"'\";\n                } else {\n                    errStr = 'Parse error on line '+(yylineno+1)+\": Unexpected \" +\n                                  (symbol == 1 /*EOF*/ ? \"end of input\" :\n                                              (\"'\"+(this.terminals_[symbol] || symbol)+\"'\"));\n                }\n                this.parseError(errStr,\n                    {text: this.lexer.match, token: this.terminals_[symbol] || symbol, line: this.lexer.yylineno, loc: yyloc, expected: expected});\n            }\n\n            // just recovered from another error\n            if (recovering == 3) {\n                if (symbol == EOF) {\n                    throw new Error(errStr || 'Parsing halted.');\n                }\n\n                // discard current lookahead and grab another\n                yyleng = this.lexer.yyleng;\n                yytext = this.lexer.yytext;\n                yylineno = this.lexer.yylineno;\n                yyloc = this.lexer.yylloc;\n                symbol = lex();\n            }\n\n            // try to recover from error\n            while (1) {\n                // check for error recovery rule in this state\n                if ((TERROR.toString()) in table[state]) {\n                    break;\n                }\n                if (state == 0) {\n                    throw new Error(errStr || 'Parsing halted.');\n                }\n                popStack(1);\n                state = stack[stack.length-1];\n            }\n\n            preErrorSymbol = symbol; // save the lookahead token\n            symbol = TERROR;         // insert generic error symbol as new lookahead\n            state = stack[stack.length-1];\n            action = table[state] && table[state][TERROR];\n            recovering = 3; // allow 3 real symbols to be shifted before reporting a new error\n        }\n\n        // this shouldn't happen, unless resolve defaults are off\n        if (action[0] instanceof Array && action.length > 1) {\n            throw new Error('Parse Error: multiple actions possible at state: '+state+', token: '+symbol);\n        }\n\n        switch (action[0]) {\n\n            case 1: // shift\n                //this.shiftCount++;\n\n                stack.push(symbol);\n                vstack.push(this.lexer.yytext);\n                lstack.push(this.lexer.yylloc);\n                stack.push(action[1]); // push state\n                symbol = null;\n                if (!preErrorSymbol) { // normal execution/no error\n                    yyleng = this.lexer.yyleng;\n                    yytext = this.lexer.yytext;\n                    yylineno = this.lexer.yylineno;\n                    yyloc = this.lexer.yylloc;\n                    if (recovering > 0)\n                        recovering--;\n                } else { // error just occurred, resume old lookahead f/ before error\n                    symbol = preErrorSymbol;\n                    preErrorSymbol = null;\n                }\n                break;\n\n            case 2: // reduce\n                //this.reductionCount++;\n\n                len = this.productions_[action[1]][1];\n\n                // perform semantic action\n                yyval.$ = vstack[vstack.length-len]; // default to $$ = $1\n                // default location, uses first token for firsts, last for lasts\n                yyval._$ = {\n                    first_line: lstack[lstack.length-(len||1)].first_line,\n                    last_line: lstack[lstack.length-1].last_line,\n                    first_column: lstack[lstack.length-(len||1)].first_column,\n                    last_column: lstack[lstack.length-1].last_column\n                };\n                r = this.performAction.call(yyval, yytext, yyleng, yylineno, this.yy, action[1], vstack, lstack);\n\n                if (typeof r !== 'undefined') {\n                    return r;\n                }\n\n                // pop off stack\n                if (len) {\n                    stack = stack.slice(0,-1*len*2);\n                    vstack = vstack.slice(0, -1*len);\n                    lstack = lstack.slice(0, -1*len);\n                }\n\n                stack.push(this.productions_[action[1]][0]);    // push nonterminal (reduce)\n                vstack.push(yyval.$);\n                lstack.push(yyval._$);\n                // goto new state = table[STATE][NONTERMINAL]\n                newState = table[stack[stack.length-2]][stack[stack.length-1]];\n                stack.push(newState);\n                break;\n\n            case 3: // accept\n                return true;\n        }\n\n    }\n\n    return true;\n}};\n/* Jison generated lexer */\nvar lexer = (function(){\nvar lexer = ({EOF:1,\nparseError:function parseError(str, hash) {\n        if (this.yy.parseError) {\n            this.yy.parseError(str, hash);\n        } else {\n            throw new Error(str);\n        }\n    },\nsetInput:function (input) {\n        this._input = input;\n        this._more = this._less = this.done = false;\n        this.yylineno = this.yyleng = 0;\n        this.yytext = this.matched = this.match = '';\n        this.conditionStack = ['INITIAL'];\n        this.yylloc = {first_line:1,first_column:0,last_line:1,last_column:0};\n        return this;\n    },\ninput:function () {\n        var ch = this._input[0];\n        this.yytext+=ch;\n        this.yyleng++;\n        this.match+=ch;\n        this.matched+=ch;\n        var lines = ch.match(/\\n/);\n        if (lines) this.yylineno++;\n        this._input = this._input.slice(1);\n        return ch;\n    },\nunput:function (ch) {\n        this._input = ch + this._input;\n        return this;\n    },\nmore:function () {\n        this._more = true;\n        return this;\n    },\nless:function (n) {\n        this._input = this.match.slice(n) + this._input;\n    },\npastInput:function () {\n        var past = this.matched.substr(0, this.matched.length - this.match.length);\n        return (past.length > 20 ? '...':'') + past.substr(-20).replace(/\\n/g, \"\");\n    },\nupcomingInput:function () {\n        var next = this.match;\n        if (next.length < 20) {\n            next += this._input.substr(0, 20-next.length);\n        }\n        return (next.substr(0,20)+(next.length > 20 ? '...':'')).replace(/\\n/g, \"\");\n    },\nshowPosition:function () {\n        var pre = this.pastInput();\n        var c = new Array(pre.length + 1).join(\"-\");\n        return pre + this.upcomingInput() + \"\\n\" + c+\"^\";\n    },\nnext:function () {\n        if (this.done) {\n            return this.EOF;\n        }\n        if (!this._input) this.done = true;\n\n        var token,\n            match,\n            tempMatch,\n            index,\n            col,\n            lines;\n        if (!this._more) {\n            this.yytext = '';\n            this.match = '';\n        }\n        var rules = this._currentRules();\n        for (var i=0;i < rules.length; i++) {\n            tempMatch = this._input.match(this.rules[rules[i]]);\n            if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {\n                match = tempMatch;\n                index = i;\n                if (!this.options.flex) break;\n            }\n        }\n        if (match) {\n            lines = match[0].match(/\\n.*/g);\n            if (lines) this.yylineno += lines.length;\n            this.yylloc = {first_line: this.yylloc.last_line,\n                           last_line: this.yylineno+1,\n                           first_column: this.yylloc.last_column,\n                           last_column: lines ? lines[lines.length-1].length-1 : this.yylloc.last_column + match[0].length}\n            this.yytext += match[0];\n            this.match += match[0];\n            this.yyleng = this.yytext.length;\n            this._more = false;\n            this._input = this._input.slice(match[0].length);\n            this.matched += match[0];\n            token = this.performAction.call(this, this.yy, this, rules[index],this.conditionStack[this.conditionStack.length-1]);\n            if (this.done && this._input) this.done = false;\n            if (token) return token;\n            else return;\n        }\n        if (this._input === \"\") {\n            return this.EOF;\n        } else {\n            this.parseError('Lexical error on line '+(this.yylineno+1)+'. Unrecognized text.\\n'+this.showPosition(), \n                    {text: \"\", token: null, line: this.yylineno});\n        }\n    },\nlex:function lex() {\n        var r = this.next();\n        if (typeof r !== 'undefined') {\n            return r;\n        } else {\n            return this.lex();\n        }\n    },\nbegin:function begin(condition) {\n        this.conditionStack.push(condition);\n    },\npopState:function popState() {\n        return this.conditionStack.pop();\n    },\n_currentRules:function _currentRules() {\n        return this.conditions[this.conditionStack[this.conditionStack.length-1]].rules;\n    },\ntopState:function () {\n        return this.conditionStack[this.conditionStack.length-2];\n    },\npushState:function begin(condition) {\n        this.begin(condition);\n    }});\nlexer.options = {};\nlexer.performAction = function anonymous(yy,yy_,$avoiding_name_collisions,YY_START) {\n\nvar YYSTATE=YY_START\nswitch($avoiding_name_collisions) {\ncase 0:/* skip whitespace */\nbreak;\ncase 1:return 6\nbreak;\ncase 2:yy_.yytext = yy_.yytext.substr(1,yy_.yyleng-2); return 4\nbreak;\ncase 3:return 17\nbreak;\ncase 4:return 18\nbreak;\ncase 5:return 23\nbreak;\ncase 6:return 24\nbreak;\ncase 7:return 22\nbreak;\ncase 8:return 21\nbreak;\ncase 9:return 10\nbreak;\ncase 10:return 11\nbreak;\ncase 11:return 8\nbreak;\ncase 12:return 14\nbreak;\ncase 13:return 'INVALID'\nbreak;\n}\n};\nlexer.rules = [/^(?:\\s+)/,/^(?:(-?([0-9]|[1-9][0-9]+))(\\.[0-9]+)?([eE][-+]?[0-9]+)?\\b)/,/^(?:\"(?:\\\\[\\\\\"bfnrt/]|\\\\u[a-fA-F0-9]{4}|[^\\\\\\0-\\x09\\x0a-\\x1f\"])*\")/,/^(?:\\{)/,/^(?:\\})/,/^(?:\\[)/,/^(?:\\])/,/^(?:,)/,/^(?::)/,/^(?:true\\b)/,/^(?:false\\b)/,/^(?:null\\b)/,/^(?:$)/,/^(?:.)/];\nlexer.conditions = {\"INITIAL\":{\"rules\":[0,1,2,3,4,5,6,7,8,9,10,11,12,13],\"inclusive\":true}};\n\n\n;\nreturn lexer;})()\nparser.lexer = lexer;\nreturn parser;\n})();\nif (typeof require !== 'undefined' && typeof exports !== 'undefined') {\nexports.parser = jsonlint;\nexports.parse = function () { return jsonlint.parse.apply(jsonlint, arguments); }\nexports.main = function commonjsMain(args) {\n    if (!args[1])\n        throw new Error('Usage: '+args[0]+' FILE');\n    if (typeof process !== 'undefined') {\n        var source = require('fs').readFileSync(require('path').join(process.cwd(), args[1]), \"utf8\");\n    } else {\n        var cwd = require(\"file\").path(require(\"file\").cwd());\n        var source = cwd.join(args[1]).read({charset: \"utf-8\"});\n    }\n    return exports.parser.parse(source);\n}\nif (typeof module !== 'undefined' && require.main === module) {\n  exports.main(typeof process !== 'undefined' ? process.argv.slice(1) : require(\"system\").args);\n}\n}","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n// This is CodeMirror (http://codemirror.net), a code editor\n// implemented in JavaScript on top of the browser's DOM.\n//\n// You can find some technical background for some of the code below\n// at http://marijnhaverbeke.nl/blog/#cm-internals .\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    module.exports = mod();\n  else if (typeof define == \"function\" && define.amd) // AMD\n    return define([], mod);\n  else // Plain browser env\n    this.CodeMirror = mod();\n})(function() {\n  \"use strict\";\n\n  // BROWSER SNIFFING\n\n  // Kludges for bugs and behavior differences that can't be feature\n  // detected are enabled based on userAgent etc sniffing.\n\n  var gecko = /gecko\\/\\d/i.test(navigator.userAgent);\n  // ie_uptoN means Internet Explorer version N or lower\n  var ie_upto10 = /MSIE \\d/.test(navigator.userAgent);\n  var ie_11up = /Trident\\/(?:[7-9]|\\d{2,})\\..*rv:(\\d+)/.exec(navigator.userAgent);\n  var ie = ie_upto10 || ie_11up;\n  var ie_version = ie && (ie_upto10 ? document.documentMode || 6 : ie_11up[1]);\n  var webkit = /WebKit\\//.test(navigator.userAgent);\n  var qtwebkit = webkit && /Qt\\/\\d+\\.\\d+/.test(navigator.userAgent);\n  var chrome = /Chrome\\//.test(navigator.userAgent);\n  var presto = /Opera\\//.test(navigator.userAgent);\n  var safari = /Apple Computer/.test(navigator.vendor);\n  var khtml = /KHTML\\//.test(navigator.userAgent);\n  var mac_geMountainLion = /Mac OS X 1\\d\\D([8-9]|\\d\\d)\\D/.test(navigator.userAgent);\n  var phantom = /PhantomJS/.test(navigator.userAgent);\n\n  var ios = /AppleWebKit/.test(navigator.userAgent) && /Mobile\\/\\w+/.test(navigator.userAgent);\n  // This is woefully incomplete. Suggestions for alternative methods welcome.\n  var mobile = ios || /Android|webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(navigator.userAgent);\n  var mac = ios || /Mac/.test(navigator.platform);\n  var windows = /win/i.test(navigator.platform);\n\n  var presto_version = presto && navigator.userAgent.match(/Version\\/(\\d*\\.\\d*)/);\n  if (presto_version) presto_version = Number(presto_version[1]);\n  if (presto_version && presto_version >= 15) { presto = false; webkit = true; }\n  // Some browsers use the wrong event properties to signal cmd/ctrl on OS X\n  var flipCtrlCmd = mac && (qtwebkit || presto && (presto_version == null || presto_version < 12.11));\n  var captureRightClick = gecko || (ie && ie_version >= 9);\n\n  // Optimize some code when these features are not used.\n  var sawReadOnlySpans = false, sawCollapsedSpans = false;\n\n  // EDITOR CONSTRUCTOR\n\n  // A CodeMirror instance represents an editor. This is the object\n  // that user code is usually dealing with.\n\n  function CodeMirror(place, options) {\n    if (!(this instanceof CodeMirror)) return new CodeMirror(place, options);\n\n    this.options = options = options ? copyObj(options) : {};\n    // Determine effective options based on given values and defaults.\n    copyObj(defaults, options, false);\n    setGuttersForLineNumbers(options);\n\n    var doc = options.value;\n    if (typeof doc == \"string\") doc = new Doc(doc, options.mode);\n    this.doc = doc;\n\n    var display = this.display = new Display(place, doc);\n    display.wrapper.CodeMirror = this;\n    updateGutters(this);\n    themeChanged(this);\n    if (options.lineWrapping)\n      this.display.wrapper.className += \" CodeMirror-wrap\";\n    if (options.autofocus && !mobile) focusInput(this);\n\n    this.state = {\n      keyMaps: [],  // stores maps added by addKeyMap\n      overlays: [], // highlighting overlays, as added by addOverlay\n      modeGen: 0,   // bumped when mode/overlay changes, used to invalidate highlighting info\n      overwrite: false, focused: false,\n      suppressEdits: false, // used to disable editing during key handlers when in readOnly mode\n      pasteIncoming: false, cutIncoming: false, // help recognize paste/cut edits in readInput\n      draggingText: false,\n      highlight: new Delayed() // stores highlight worker timeout\n    };\n\n    // Override magic textarea content restore that IE sometimes does\n    // on our hidden textarea on reload\n    if (ie && ie_version < 11) setTimeout(bind(resetInput, this, true), 20);\n\n    registerEventHandlers(this);\n    ensureGlobalHandlers();\n\n    startOperation(this);\n    this.curOp.forceUpdate = true;\n    attachDoc(this, doc);\n\n    if ((options.autofocus && !mobile) || activeElt() == display.input)\n      setTimeout(bind(onFocus, this), 20);\n    else\n      onBlur(this);\n\n    for (var opt in optionHandlers) if (optionHandlers.hasOwnProperty(opt))\n      optionHandlers[opt](this, options[opt], Init);\n    maybeUpdateLineNumberWidth(this);\n    for (var i = 0; i < initHooks.length; ++i) initHooks[i](this);\n    endOperation(this);\n  }\n\n  // DISPLAY CONSTRUCTOR\n\n  // The display handles the DOM integration, both for input reading\n  // and content drawing. It holds references to DOM nodes and\n  // display-related state.\n\n  function Display(place, doc) {\n    var d = this;\n\n    // The semihidden textarea that is focused when the editor is\n    // focused, and receives input.\n    var input = d.input = elt(\"textarea\", null, null, \"position: absolute; padding: 0; width: 1px; height: 1em; outline: none\");\n    // The textarea is kept positioned near the cursor to prevent the\n    // fact that it'll be scrolled into view on input from scrolling\n    // our fake cursor out of view. On webkit, when wrap=off, paste is\n    // very slow. So make the area wide instead.\n    if (webkit) input.style.width = \"1000px\";\n    else input.setAttribute(\"wrap\", \"off\");\n    // If border: 0; -- iOS fails to open keyboard (issue #1287)\n    if (ios) input.style.border = \"1px solid black\";\n    input.setAttribute(\"autocorrect\", \"off\"); input.setAttribute(\"autocapitalize\", \"off\"); input.setAttribute(\"spellcheck\", \"false\");\n\n    // Wraps and hides input textarea\n    d.inputDiv = elt(\"div\", [input], null, \"overflow: hidden; position: relative; width: 3px; height: 0px;\");\n    // The fake scrollbar elements.\n    d.scrollbarH = elt(\"div\", [elt(\"div\", null, null, \"height: 100%; min-height: 1px\")], \"CodeMirror-hscrollbar\");\n    d.scrollbarV = elt(\"div\", [elt(\"div\", null, null, \"min-width: 1px\")], \"CodeMirror-vscrollbar\");\n    // Covers bottom-right square when both scrollbars are present.\n    d.scrollbarFiller = elt(\"div\", null, \"CodeMirror-scrollbar-filler\");\n    // Covers bottom of gutter when coverGutterNextToScrollbar is on\n    // and h scrollbar is present.\n    d.gutterFiller = elt(\"div\", null, \"CodeMirror-gutter-filler\");\n    // Will contain the actual code, positioned to cover the viewport.\n    d.lineDiv = elt(\"div\", null, \"CodeMirror-code\");\n    // Elements are added to these to represent selection and cursors.\n    d.selectionDiv = elt(\"div\", null, null, \"position: relative; z-index: 1\");\n    d.cursorDiv = elt(\"div\", null, \"CodeMirror-cursors\");\n    // A visibility: hidden element used to find the size of things.\n    d.measure = elt(\"div\", null, \"CodeMirror-measure\");\n    // When lines outside of the viewport are measured, they are drawn in this.\n    d.lineMeasure = elt(\"div\", null, \"CodeMirror-measure\");\n    // Wraps everything that needs to exist inside the vertically-padded coordinate system\n    d.lineSpace = elt(\"div\", [d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv],\n                      null, \"position: relative; outline: none\");\n    // Moved around its parent to cover visible view.\n    d.mover = elt(\"div\", [elt(\"div\", [d.lineSpace], \"CodeMirror-lines\")], null, \"position: relative\");\n    // Set to the height of the document, allowing scrolling.\n    d.sizer = elt(\"div\", [d.mover], \"CodeMirror-sizer\");\n    // Behavior of elts with overflow: auto and padding is\n    // inconsistent across browsers. This is used to ensure the\n    // scrollable area is big enough.\n    d.heightForcer = elt(\"div\", null, null, \"position: absolute; height: \" + scrollerCutOff + \"px; width: 1px;\");\n    // Will contain the gutters, if any.\n    d.gutters = elt(\"div\", null, \"CodeMirror-gutters\");\n    d.lineGutter = null;\n    // Actual scrollable element.\n    d.scroller = elt(\"div\", [d.sizer, d.heightForcer, d.gutters], \"CodeMirror-scroll\");\n    d.scroller.setAttribute(\"tabIndex\", \"-1\");\n    // The element in which the editor lives.\n    d.wrapper = elt(\"div\", [d.inputDiv, d.scrollbarH, d.scrollbarV,\n                            d.scrollbarFiller, d.gutterFiller, d.scroller], \"CodeMirror\");\n\n    // Work around IE7 z-index bug (not perfect, hence IE7 not really being supported)\n    if (ie && ie_version < 8) { d.gutters.style.zIndex = -1; d.scroller.style.paddingRight = 0; }\n    // Needed to hide big blue blinking cursor on Mobile Safari\n    if (ios) input.style.width = \"0px\";\n    if (!webkit) d.scroller.draggable = true;\n    // Needed to handle Tab key in KHTML\n    if (khtml) { d.inputDiv.style.height = \"1px\"; d.inputDiv.style.position = \"absolute\"; }\n    // Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8).\n    if (ie && ie_version < 8) d.scrollbarH.style.minHeight = d.scrollbarV.style.minWidth = \"18px\";\n\n    if (place.appendChild) place.appendChild(d.wrapper);\n    else place(d.wrapper);\n\n    // Current rendered range (may be bigger than the view window).\n    d.viewFrom = d.viewTo = doc.first;\n    // Information about the rendered lines.\n    d.view = [];\n    // Holds info about a single rendered line when it was rendered\n    // for measurement, while not in view.\n    d.externalMeasured = null;\n    // Empty space (in pixels) above the view\n    d.viewOffset = 0;\n    d.lastSizeC = 0;\n    d.updateLineNumbers = null;\n\n    // Used to only resize the line number gutter when necessary (when\n    // the amount of lines crosses a boundary that makes its width change)\n    d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;\n    // See readInput and resetInput\n    d.prevInput = \"\";\n    // Set to true when a non-horizontal-scrolling line widget is\n    // added. As an optimization, line widget aligning is skipped when\n    // this is false.\n    d.alignWidgets = false;\n    // Flag that indicates whether we expect input to appear real soon\n    // now (after some event like 'keypress' or 'input') and are\n    // polling intensively.\n    d.pollingFast = false;\n    // Self-resetting timeout for the poller\n    d.poll = new Delayed();\n\n    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;\n\n    // Tracks when resetInput has punted to just putting a short\n    // string into the textarea instead of the full selection.\n    d.inaccurateSelection = false;\n\n    // Tracks the maximum line length so that the horizontal scrollbar\n    // can be kept static when scrolling.\n    d.maxLine = null;\n    d.maxLineLength = 0;\n    d.maxLineChanged = false;\n\n    // Used for measuring wheel scrolling granularity\n    d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;\n\n    // True when shift is held down.\n    d.shift = false;\n\n    // Used to track whether anything happened since the context menu\n    // was opened.\n    d.selForContextMenu = null;\n  }\n\n  // STATE UPDATES\n\n  // Used to get the editor into a consistent state again when options change.\n\n  function loadMode(cm) {\n    cm.doc.mode = CodeMirror.getMode(cm.options, cm.doc.modeOption);\n    resetModeState(cm);\n  }\n\n  function resetModeState(cm) {\n    cm.doc.iter(function(line) {\n      if (line.stateAfter) line.stateAfter = null;\n      if (line.styles) line.styles = null;\n    });\n    cm.doc.frontier = cm.doc.first;\n    startWorker(cm, 100);\n    cm.state.modeGen++;\n    if (cm.curOp) regChange(cm);\n  }\n\n  function wrappingChanged(cm) {\n    if (cm.options.lineWrapping) {\n      addClass(cm.display.wrapper, \"CodeMirror-wrap\");\n      cm.display.sizer.style.minWidth = \"\";\n    } else {\n      rmClass(cm.display.wrapper, \"CodeMirror-wrap\");\n      findMaxLine(cm);\n    }\n    estimateLineHeights(cm);\n    regChange(cm);\n    clearCaches(cm);\n    setTimeout(function(){updateScrollbars(cm);}, 100);\n  }\n\n  // Returns a function that estimates the height of a line, to use as\n  // first approximation until the line becomes visible (and is thus\n  // properly measurable).\n  function estimateHeight(cm) {\n    var th = textHeight(cm.display), wrapping = cm.options.lineWrapping;\n    var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);\n    return function(line) {\n      if (lineIsHidden(cm.doc, line)) return 0;\n\n      var widgetsHeight = 0;\n      if (line.widgets) for (var i = 0; i < line.widgets.length; i++) {\n        if (line.widgets[i].height) widgetsHeight += line.widgets[i].height;\n      }\n\n      if (wrapping)\n        return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th;\n      else\n        return widgetsHeight + th;\n    };\n  }\n\n  function estimateLineHeights(cm) {\n    var doc = cm.doc, est = estimateHeight(cm);\n    doc.iter(function(line) {\n      var estHeight = est(line);\n      if (estHeight != line.height) updateLineHeight(line, estHeight);\n    });\n  }\n\n  function keyMapChanged(cm) {\n    var map = keyMap[cm.options.keyMap], style = map.style;\n    cm.display.wrapper.className = cm.display.wrapper.className.replace(/\\s*cm-keymap-\\S+/g, \"\") +\n      (style ? \" cm-keymap-\" + style : \"\");\n  }\n\n  function themeChanged(cm) {\n    cm.display.wrapper.className = cm.display.wrapper.className.replace(/\\s*cm-s-\\S+/g, \"\") +\n      cm.options.theme.replace(/(^|\\s)\\s*/g, \" cm-s-\");\n    clearCaches(cm);\n  }\n\n  function guttersChanged(cm) {\n    updateGutters(cm);\n    regChange(cm);\n    setTimeout(function(){alignHorizontally(cm);}, 20);\n  }\n\n  // Rebuild the gutter elements, ensure the margin to the left of the\n  // code matches their width.\n  function updateGutters(cm) {\n    var gutters = cm.display.gutters, specs = cm.options.gutters;\n    removeChildren(gutters);\n    for (var i = 0; i < specs.length; ++i) {\n      var gutterClass = specs[i];\n      var gElt = gutters.appendChild(elt(\"div\", null, \"CodeMirror-gutter \" + gutterClass));\n      if (gutterClass == \"CodeMirror-linenumbers\") {\n        cm.display.lineGutter = gElt;\n        gElt.style.width = (cm.display.lineNumWidth || 1) + \"px\";\n      }\n    }\n    gutters.style.display = i ? \"\" : \"none\";\n    updateGutterSpace(cm);\n  }\n\n  function updateGutterSpace(cm) {\n    var width = cm.display.gutters.offsetWidth;\n    cm.display.sizer.style.marginLeft = width + \"px\";\n    cm.display.scrollbarH.style.left = cm.options.fixedGutter ? width + \"px\" : 0;\n  }\n\n  // Compute the character length of a line, taking into account\n  // collapsed ranges (see markText) that might hide parts, and join\n  // other lines onto it.\n  function lineLength(line) {\n    if (line.height == 0) return 0;\n    var len = line.text.length, merged, cur = line;\n    while (merged = collapsedSpanAtStart(cur)) {\n      var found = merged.find(0, true);\n      cur = found.from.line;\n      len += found.from.ch - found.to.ch;\n    }\n    cur = line;\n    while (merged = collapsedSpanAtEnd(cur)) {\n      var found = merged.find(0, true);\n      len -= cur.text.length - found.from.ch;\n      cur = found.to.line;\n      len += cur.text.length - found.to.ch;\n    }\n    return len;\n  }\n\n  // Find the longest line in the document.\n  function findMaxLine(cm) {\n    var d = cm.display, doc = cm.doc;\n    d.maxLine = getLine(doc, doc.first);\n    d.maxLineLength = lineLength(d.maxLine);\n    d.maxLineChanged = true;\n    doc.iter(function(line) {\n      var len = lineLength(line);\n      if (len > d.maxLineLength) {\n        d.maxLineLength = len;\n        d.maxLine = line;\n      }\n    });\n  }\n\n  // Make sure the gutters options contains the element\n  // \"CodeMirror-linenumbers\" when the lineNumbers option is true.\n  function setGuttersForLineNumbers(options) {\n    var found = indexOf(options.gutters, \"CodeMirror-linenumbers\");\n    if (found == -1 && options.lineNumbers) {\n      options.gutters = options.gutters.concat([\"CodeMirror-linenumbers\"]);\n    } else if (found > -1 && !options.lineNumbers) {\n      options.gutters = options.gutters.slice(0);\n      options.gutters.splice(found, 1);\n    }\n  }\n\n  // SCROLLBARS\n\n  function hScrollbarTakesSpace(cm) {\n    return cm.display.scroller.clientHeight - cm.display.wrapper.clientHeight < scrollerCutOff - 3;\n  }\n\n  // Prepare DOM reads needed to update the scrollbars. Done in one\n  // shot to minimize update/measure roundtrips.\n  function measureForScrollbars(cm) {\n    var scroll = cm.display.scroller;\n    return {\n      clientHeight: scroll.clientHeight,\n      barHeight: cm.display.scrollbarV.clientHeight,\n      scrollWidth: scroll.scrollWidth, clientWidth: scroll.clientWidth,\n      hScrollbarTakesSpace: hScrollbarTakesSpace(cm),\n      barWidth: cm.display.scrollbarH.clientWidth,\n      docHeight: Math.round(cm.doc.height + paddingVert(cm.display))\n    };\n  }\n\n  // Re-synchronize the fake scrollbars with the actual size of the\n  // content.\n  function updateScrollbars(cm, measure) {\n    if (!measure) measure = measureForScrollbars(cm);\n    var d = cm.display, sWidth = scrollbarWidth(d.measure);\n    var scrollHeight = measure.docHeight + scrollerCutOff;\n    var needsH = measure.scrollWidth > measure.clientWidth;\n    if (needsH && measure.scrollWidth <= measure.clientWidth + 1 &&\n        sWidth > 0 && !measure.hScrollbarTakesSpace)\n      needsH = false; // (Issue #2562)\n    var needsV = scrollHeight > measure.clientHeight;\n\n    if (needsV) {\n      d.scrollbarV.style.display = \"block\";\n      d.scrollbarV.style.bottom = needsH ? sWidth + \"px\" : \"0\";\n      // A bug in IE8 can cause this value to be negative, so guard it.\n      d.scrollbarV.firstChild.style.height =\n        Math.max(0, scrollHeight - measure.clientHeight + (measure.barHeight || d.scrollbarV.clientHeight)) + \"px\";\n    } else {\n      d.scrollbarV.style.display = \"\";\n      d.scrollbarV.firstChild.style.height = \"0\";\n    }\n    if (needsH) {\n      d.scrollbarH.style.display = \"block\";\n      d.scrollbarH.style.right = needsV ? sWidth + \"px\" : \"0\";\n      d.scrollbarH.firstChild.style.width =\n        (measure.scrollWidth - measure.clientWidth + (measure.barWidth || d.scrollbarH.clientWidth)) + \"px\";\n    } else {\n      d.scrollbarH.style.display = \"\";\n      d.scrollbarH.firstChild.style.width = \"0\";\n    }\n    if (needsH && needsV) {\n      d.scrollbarFiller.style.display = \"block\";\n      d.scrollbarFiller.style.height = d.scrollbarFiller.style.width = sWidth + \"px\";\n    } else d.scrollbarFiller.style.display = \"\";\n    if (needsH && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {\n      d.gutterFiller.style.display = \"block\";\n      d.gutterFiller.style.height = sWidth + \"px\";\n      d.gutterFiller.style.width = d.gutters.offsetWidth + \"px\";\n    } else d.gutterFiller.style.display = \"\";\n\n    if (!cm.state.checkedOverlayScrollbar && measure.clientHeight > 0) {\n      if (sWidth === 0) {\n        var w = mac && !mac_geMountainLion ? \"12px\" : \"18px\";\n        d.scrollbarV.style.minWidth = d.scrollbarH.style.minHeight = w;\n        var barMouseDown = function(e) {\n          if (e_target(e) != d.scrollbarV && e_target(e) != d.scrollbarH)\n            operation(cm, onMouseDown)(e);\n        };\n        on(d.scrollbarV, \"mousedown\", barMouseDown);\n        on(d.scrollbarH, \"mousedown\", barMouseDown);\n      }\n      cm.state.checkedOverlayScrollbar = true;\n    }\n  }\n\n  // Compute the lines that are visible in a given viewport (defaults\n  // the the current scroll position). viewport may contain top,\n  // height, and ensure (see op.scrollToPos) properties.\n  function visibleLines(display, doc, viewport) {\n    var top = viewport && viewport.top != null ? Math.max(0, viewport.top) : display.scroller.scrollTop;\n    top = Math.floor(top - paddingTop(display));\n    var bottom = viewport && viewport.bottom != null ? viewport.bottom : top + display.wrapper.clientHeight;\n\n    var from = lineAtHeight(doc, top), to = lineAtHeight(doc, bottom);\n    // Ensure is a {from: {line, ch}, to: {line, ch}} object, and\n    // forces those lines into the viewport (if possible).\n    if (viewport && viewport.ensure) {\n      var ensureFrom = viewport.ensure.from.line, ensureTo = viewport.ensure.to.line;\n      if (ensureFrom < from)\n        return {from: ensureFrom,\n                to: lineAtHeight(doc, heightAtLine(getLine(doc, ensureFrom)) + display.wrapper.clientHeight)};\n      if (Math.min(ensureTo, doc.lastLine()) >= to)\n        return {from: lineAtHeight(doc, heightAtLine(getLine(doc, ensureTo)) - display.wrapper.clientHeight),\n                to: ensureTo};\n    }\n    return {from: from, to: Math.max(to, from + 1)};\n  }\n\n  // LINE NUMBERS\n\n  // Re-align line numbers and gutter marks to compensate for\n  // horizontal scrolling.\n  function alignHorizontally(cm) {\n    var display = cm.display, view = display.view;\n    if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) return;\n    var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;\n    var gutterW = display.gutters.offsetWidth, left = comp + \"px\";\n    for (var i = 0; i < view.length; i++) if (!view[i].hidden) {\n      if (cm.options.fixedGutter && view[i].gutter)\n        view[i].gutter.style.left = left;\n      var align = view[i].alignable;\n      if (align) for (var j = 0; j < align.length; j++)\n        align[j].style.left = left;\n    }\n    if (cm.options.fixedGutter)\n      display.gutters.style.left = (comp + gutterW) + \"px\";\n  }\n\n  // Used to ensure that the line number gutter is still the right\n  // size for the current document size. Returns true when an update\n  // is needed.\n  function maybeUpdateLineNumberWidth(cm) {\n    if (!cm.options.lineNumbers) return false;\n    var doc = cm.doc, last = lineNumberFor(cm.options, doc.first + doc.size - 1), display = cm.display;\n    if (last.length != display.lineNumChars) {\n      var test = display.measure.appendChild(elt(\"div\", [elt(\"div\", last)],\n                                                 \"CodeMirror-linenumber CodeMirror-gutter-elt\"));\n      var innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW;\n      display.lineGutter.style.width = \"\";\n      display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding);\n      display.lineNumWidth = display.lineNumInnerWidth + padding;\n      display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;\n      display.lineGutter.style.width = display.lineNumWidth + \"px\";\n      updateGutterSpace(cm);\n      return true;\n    }\n    return false;\n  }\n\n  function lineNumberFor(options, i) {\n    return String(options.lineNumberFormatter(i + options.firstLineNumber));\n  }\n\n  // Computes display.scroller.scrollLeft + display.gutters.offsetWidth,\n  // but using getBoundingClientRect to get a sub-pixel-accurate\n  // result.\n  function compensateForHScroll(display) {\n    return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left;\n  }\n\n  // DISPLAY DRAWING\n\n  function DisplayUpdate(cm, viewport, force) {\n    var display = cm.display;\n\n    this.viewport = viewport;\n    // Store some values that we'll need later (but don't want to force a relayout for)\n    this.visible = visibleLines(display, cm.doc, viewport);\n    this.editorIsHidden = !display.wrapper.offsetWidth;\n    this.wrapperHeight = display.wrapper.clientHeight;\n    this.oldViewFrom = display.viewFrom; this.oldViewTo = display.viewTo;\n    this.oldScrollerWidth = display.scroller.clientWidth;\n    this.force = force;\n    this.dims = getDimensions(cm);\n  }\n\n  // Does the actual updating of the line display. Bails out\n  // (returning false) when there is nothing to be done and forced is\n  // false.\n  function updateDisplayIfNeeded(cm, update) {\n    var display = cm.display, doc = cm.doc;\n    if (update.editorIsHidden) {\n      resetView(cm);\n      return false;\n    }\n\n    // Bail out if the visible area is already rendered and nothing changed.\n    if (!update.force &&\n        update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo &&\n        (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo) &&\n        countDirtyView(cm) == 0)\n      return false;\n\n    if (maybeUpdateLineNumberWidth(cm)) {\n      resetView(cm);\n      update.dims = getDimensions(cm);\n    }\n\n    // Compute a suitable new viewport (from & to)\n    var end = doc.first + doc.size;\n    var from = Math.max(update.visible.from - cm.options.viewportMargin, doc.first);\n    var to = Math.min(end, update.visible.to + cm.options.viewportMargin);\n    if (display.viewFrom < from && from - display.viewFrom < 20) from = Math.max(doc.first, display.viewFrom);\n    if (display.viewTo > to && display.viewTo - to < 20) to = Math.min(end, display.viewTo);\n    if (sawCollapsedSpans) {\n      from = visualLineNo(cm.doc, from);\n      to = visualLineEndNo(cm.doc, to);\n    }\n\n    var different = from != display.viewFrom || to != display.viewTo ||\n      display.lastSizeC != update.wrapperHeight;\n    adjustView(cm, from, to);\n\n    display.viewOffset = heightAtLine(getLine(cm.doc, display.viewFrom));\n    // Position the mover div to align with the current scroll position\n    cm.display.mover.style.top = display.viewOffset + \"px\";\n\n    var toUpdate = countDirtyView(cm);\n    if (!different && toUpdate == 0 && !update.force &&\n        (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo))\n      return false;\n\n    // For big changes, we hide the enclosing element during the\n    // update, since that speeds up the operations on most browsers.\n    var focused = activeElt();\n    if (toUpdate > 4) display.lineDiv.style.display = \"none\";\n    patchDisplay(cm, display.updateLineNumbers, update.dims);\n    if (toUpdate > 4) display.lineDiv.style.display = \"\";\n    // There might have been a widget with a focused element that got\n    // hidden or updated, if so re-focus it.\n    if (focused && activeElt() != focused && focused.offsetHeight) focused.focus();\n\n    // Prevent selection and cursors from interfering with the scroll\n    // width.\n    removeChildren(display.cursorDiv);\n    removeChildren(display.selectionDiv);\n\n    if (different) {\n      display.lastSizeC = update.wrapperHeight;\n      startWorker(cm, 400);\n    }\n\n    display.updateLineNumbers = null;\n\n    return true;\n  }\n\n  function postUpdateDisplay(cm, update) {\n    var force = update.force, viewport = update.viewport;\n    for (var first = true;; first = false) {\n      if (first && cm.options.lineWrapping && update.oldScrollerWidth != cm.display.scroller.clientWidth) {\n        force = true;\n      } else {\n        force = false;\n        // Clip forced viewport to actual scrollable area.\n        if (viewport && viewport.top != null)\n          viewport = {top: Math.min(cm.doc.height + paddingVert(cm.display) - scrollerCutOff -\n                                    cm.display.scroller.clientHeight, viewport.top)};\n        // Updated line heights might result in the drawn area not\n        // actually covering the viewport. Keep looping until it does.\n        update.visible = visibleLines(cm.display, cm.doc, viewport);\n        if (update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo)\n          break;\n      }\n      if (!updateDisplayIfNeeded(cm, update)) break;\n      updateHeightsInViewport(cm);\n      var barMeasure = measureForScrollbars(cm);\n      updateSelection(cm);\n      setDocumentHeight(cm, barMeasure);\n      updateScrollbars(cm, barMeasure);\n    }\n\n    signalLater(cm, \"update\", cm);\n    if (cm.display.viewFrom != update.oldViewFrom || cm.display.viewTo != update.oldViewTo)\n      signalLater(cm, \"viewportChange\", cm, cm.display.viewFrom, cm.display.viewTo);\n  }\n\n  function updateDisplaySimple(cm, viewport) {\n    var update = new DisplayUpdate(cm, viewport);\n    if (updateDisplayIfNeeded(cm, update)) {\n      updateHeightsInViewport(cm);\n      postUpdateDisplay(cm, update);\n      var barMeasure = measureForScrollbars(cm);\n      updateSelection(cm);\n      setDocumentHeight(cm, barMeasure);\n      updateScrollbars(cm, barMeasure);\n    }\n  }\n\n  function setDocumentHeight(cm, measure) {\n    cm.display.sizer.style.minHeight = cm.display.heightForcer.style.top = measure.docHeight + \"px\";\n    cm.display.gutters.style.height = Math.max(measure.docHeight, measure.clientHeight - scrollerCutOff) + \"px\";\n  }\n\n  function checkForWebkitWidthBug(cm, measure) {\n    // Work around Webkit bug where it sometimes reserves space for a\n    // non-existing phantom scrollbar in the scroller (Issue #2420)\n    if (cm.display.sizer.offsetWidth + cm.display.gutters.offsetWidth < cm.display.scroller.clientWidth - 1) {\n      cm.display.sizer.style.minHeight = cm.display.heightForcer.style.top = \"0px\";\n      cm.display.gutters.style.height = measure.docHeight + \"px\";\n    }\n  }\n\n  // Read the actual heights of the rendered lines, and update their\n  // stored heights to match.\n  function updateHeightsInViewport(cm) {\n    var display = cm.display;\n    var prevBottom = display.lineDiv.offsetTop;\n    for (var i = 0; i < display.view.length; i++) {\n      var cur = display.view[i], height;\n      if (cur.hidden) continue;\n      if (ie && ie_version < 8) {\n        var bot = cur.node.offsetTop + cur.node.offsetHeight;\n        height = bot - prevBottom;\n        prevBottom = bot;\n      } else {\n        var box = cur.node.getBoundingClientRect();\n        height = box.bottom - box.top;\n      }\n      var diff = cur.line.height - height;\n      if (height < 2) height = textHeight(display);\n      if (diff > .001 || diff < -.001) {\n        updateLineHeight(cur.line, height);\n        updateWidgetHeight(cur.line);\n        if (cur.rest) for (var j = 0; j < cur.rest.length; j++)\n          updateWidgetHeight(cur.rest[j]);\n      }\n    }\n  }\n\n  // Read and store the height of line widgets associated with the\n  // given line.\n  function updateWidgetHeight(line) {\n    if (line.widgets) for (var i = 0; i < line.widgets.length; ++i)\n      line.widgets[i].height = line.widgets[i].node.offsetHeight;\n  }\n\n  // Do a bulk-read of the DOM positions and sizes needed to draw the\n  // view, so that we don't interleave reading and writing to the DOM.\n  function getDimensions(cm) {\n    var d = cm.display, left = {}, width = {};\n    var gutterLeft = d.gutters.clientLeft;\n    for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {\n      left[cm.options.gutters[i]] = n.offsetLeft + n.clientLeft + gutterLeft;\n      width[cm.options.gutters[i]] = n.clientWidth;\n    }\n    return {fixedPos: compensateForHScroll(d),\n            gutterTotalWidth: d.gutters.offsetWidth,\n            gutterLeft: left,\n            gutterWidth: width,\n            wrapperWidth: d.wrapper.clientWidth};\n  }\n\n  // Sync the actual display DOM structure with display.view, removing\n  // nodes for lines that are no longer in view, and creating the ones\n  // that are not there yet, and updating the ones that are out of\n  // date.\n  function patchDisplay(cm, updateNumbersFrom, dims) {\n    var display = cm.display, lineNumbers = cm.options.lineNumbers;\n    var container = display.lineDiv, cur = container.firstChild;\n\n    function rm(node) {\n      var next = node.nextSibling;\n      // Works around a throw-scroll bug in OS X Webkit\n      if (webkit && mac && cm.display.currentWheelTarget == node)\n        node.style.display = \"none\";\n      else\n        node.parentNode.removeChild(node);\n      return next;\n    }\n\n    var view = display.view, lineN = display.viewFrom;\n    // Loop over the elements in the view, syncing cur (the DOM nodes\n    // in display.lineDiv) with the view as we go.\n    for (var i = 0; i < view.length; i++) {\n      var lineView = view[i];\n      if (lineView.hidden) {\n      } else if (!lineView.node) { // Not drawn yet\n        var node = buildLineElement(cm, lineView, lineN, dims);\n        container.insertBefore(node, cur);\n      } else { // Already drawn\n        while (cur != lineView.node) cur = rm(cur);\n        var updateNumber = lineNumbers && updateNumbersFrom != null &&\n          updateNumbersFrom <= lineN && lineView.lineNumber;\n        if (lineView.changes) {\n          if (indexOf(lineView.changes, \"gutter\") > -1) updateNumber = false;\n          updateLineForChanges(cm, lineView, lineN, dims);\n        }\n        if (updateNumber) {\n          removeChildren(lineView.lineNumber);\n          lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)));\n        }\n        cur = lineView.node.nextSibling;\n      }\n      lineN += lineView.size;\n    }\n    while (cur) cur = rm(cur);\n  }\n\n  // When an aspect of a line changes, a string is added to\n  // lineView.changes. This updates the relevant part of the line's\n  // DOM structure.\n  function updateLineForChanges(cm, lineView, lineN, dims) {\n    for (var j = 0; j < lineView.changes.length; j++) {\n      var type = lineView.changes[j];\n      if (type == \"text\") updateLineText(cm, lineView);\n      else if (type == \"gutter\") updateLineGutter(cm, lineView, lineN, dims);\n      else if (type == \"class\") updateLineClasses(lineView);\n      else if (type == \"widget\") updateLineWidgets(lineView, dims);\n    }\n    lineView.changes = null;\n  }\n\n  // Lines with gutter elements, widgets or a background class need to\n  // be wrapped, and have the extra elements added to the wrapper div\n  function ensureLineWrapped(lineView) {\n    if (lineView.node == lineView.text) {\n      lineView.node = elt(\"div\", null, null, \"position: relative\");\n      if (lineView.text.parentNode)\n        lineView.text.parentNode.replaceChild(lineView.node, lineView.text);\n      lineView.node.appendChild(lineView.text);\n      if (ie && ie_version < 8) lineView.node.style.zIndex = 2;\n    }\n    return lineView.node;\n  }\n\n  function updateLineBackground(lineView) {\n    var cls = lineView.bgClass ? lineView.bgClass + \" \" + (lineView.line.bgClass || \"\") : lineView.line.bgClass;\n    if (cls) cls += \" CodeMirror-linebackground\";\n    if (lineView.background) {\n      if (cls) lineView.background.className = cls;\n      else { lineView.background.parentNode.removeChild(lineView.background); lineView.background = null; }\n    } else if (cls) {\n      var wrap = ensureLineWrapped(lineView);\n      lineView.background = wrap.insertBefore(elt(\"div\", null, cls), wrap.firstChild);\n    }\n  }\n\n  // Wrapper around buildLineContent which will reuse the structure\n  // in display.externalMeasured when possible.\n  function getLineContent(cm, lineView) {\n    var ext = cm.display.externalMeasured;\n    if (ext && ext.line == lineView.line) {\n      cm.display.externalMeasured = null;\n      lineView.measure = ext.measure;\n      return ext.built;\n    }\n    return buildLineContent(cm, lineView);\n  }\n\n  // Redraw the line's text. Interacts with the background and text\n  // classes because the mode may output tokens that influence these\n  // classes.\n  function updateLineText(cm, lineView) {\n    var cls = lineView.text.className;\n    var built = getLineContent(cm, lineView);\n    if (lineView.text == lineView.node) lineView.node = built.pre;\n    lineView.text.parentNode.replaceChild(built.pre, lineView.text);\n    lineView.text = built.pre;\n    if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {\n      lineView.bgClass = built.bgClass;\n      lineView.textClass = built.textClass;\n      updateLineClasses(lineView);\n    } else if (cls) {\n      lineView.text.className = cls;\n    }\n  }\n\n  function updateLineClasses(lineView) {\n    updateLineBackground(lineView);\n    if (lineView.line.wrapClass)\n      ensureLineWrapped(lineView).className = lineView.line.wrapClass;\n    else if (lineView.node != lineView.text)\n      lineView.node.className = \"\";\n    var textClass = lineView.textClass ? lineView.textClass + \" \" + (lineView.line.textClass || \"\") : lineView.line.textClass;\n    lineView.text.className = textClass || \"\";\n  }\n\n  function updateLineGutter(cm, lineView, lineN, dims) {\n    if (lineView.gutter) {\n      lineView.node.removeChild(lineView.gutter);\n      lineView.gutter = null;\n    }\n    var markers = lineView.line.gutterMarkers;\n    if (cm.options.lineNumbers || markers) {\n      var wrap = ensureLineWrapped(lineView);\n      var gutterWrap = lineView.gutter =\n        wrap.insertBefore(elt(\"div\", null, \"CodeMirror-gutter-wrapper\", \"position: absolute; left: \" +\n                              (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + \"px\"),\n                          lineView.text);\n      if (cm.options.lineNumbers && (!markers || !markers[\"CodeMirror-linenumbers\"]))\n        lineView.lineNumber = gutterWrap.appendChild(\n          elt(\"div\", lineNumberFor(cm.options, lineN),\n              \"CodeMirror-linenumber CodeMirror-gutter-elt\",\n              \"left: \" + dims.gutterLeft[\"CodeMirror-linenumbers\"] + \"px; width: \"\n              + cm.display.lineNumInnerWidth + \"px\"));\n      if (markers) for (var k = 0; k < cm.options.gutters.length; ++k) {\n        var id = cm.options.gutters[k], found = markers.hasOwnProperty(id) && markers[id];\n        if (found)\n          gutterWrap.appendChild(elt(\"div\", [found], \"CodeMirror-gutter-elt\", \"left: \" +\n                                     dims.gutterLeft[id] + \"px; width: \" + dims.gutterWidth[id] + \"px\"));\n      }\n    }\n  }\n\n  function updateLineWidgets(lineView, dims) {\n    if (lineView.alignable) lineView.alignable = null;\n    for (var node = lineView.node.firstChild, next; node; node = next) {\n      var next = node.nextSibling;\n      if (node.className == \"CodeMirror-linewidget\")\n        lineView.node.removeChild(node);\n    }\n    insertLineWidgets(lineView, dims);\n  }\n\n  // Build a line's DOM representation from scratch\n  function buildLineElement(cm, lineView, lineN, dims) {\n    var built = getLineContent(cm, lineView);\n    lineView.text = lineView.node = built.pre;\n    if (built.bgClass) lineView.bgClass = built.bgClass;\n    if (built.textClass) lineView.textClass = built.textClass;\n\n    updateLineClasses(lineView);\n    updateLineGutter(cm, lineView, lineN, dims);\n    insertLineWidgets(lineView, dims);\n    return lineView.node;\n  }\n\n  // A lineView may contain multiple logical lines (when merged by\n  // collapsed spans). The widgets for all of them need to be drawn.\n  function insertLineWidgets(lineView, dims) {\n    insertLineWidgetsFor(lineView.line, lineView, dims, true);\n    if (lineView.rest) for (var i = 0; i < lineView.rest.length; i++)\n      insertLineWidgetsFor(lineView.rest[i], lineView, dims, false);\n  }\n\n  function insertLineWidgetsFor(line, lineView, dims, allowAbove) {\n    if (!line.widgets) return;\n    var wrap = ensureLineWrapped(lineView);\n    for (var i = 0, ws = line.widgets; i < ws.length; ++i) {\n      var widget = ws[i], node = elt(\"div\", [widget.node], \"CodeMirror-linewidget\");\n      if (!widget.handleMouseEvents) node.ignoreEvents = true;\n      positionLineWidget(widget, node, lineView, dims);\n      if (allowAbove && widget.above)\n        wrap.insertBefore(node, lineView.gutter || lineView.text);\n      else\n        wrap.appendChild(node);\n      signalLater(widget, \"redraw\");\n    }\n  }\n\n  function positionLineWidget(widget, node, lineView, dims) {\n    if (widget.noHScroll) {\n      (lineView.alignable || (lineView.alignable = [])).push(node);\n      var width = dims.wrapperWidth;\n      node.style.left = dims.fixedPos + \"px\";\n      if (!widget.coverGutter) {\n        width -= dims.gutterTotalWidth;\n        node.style.paddingLeft = dims.gutterTotalWidth + \"px\";\n      }\n      node.style.width = width + \"px\";\n    }\n    if (widget.coverGutter) {\n      node.style.zIndex = 5;\n      node.style.position = \"relative\";\n      if (!widget.noHScroll) node.style.marginLeft = -dims.gutterTotalWidth + \"px\";\n    }\n  }\n\n  // POSITION OBJECT\n\n  // A Pos instance represents a position within the text.\n  var Pos = CodeMirror.Pos = function(line, ch) {\n    if (!(this instanceof Pos)) return new Pos(line, ch);\n    this.line = line; this.ch = ch;\n  };\n\n  // Compare two positions, return 0 if they are the same, a negative\n  // number when a is less, and a positive number otherwise.\n  var cmp = CodeMirror.cmpPos = function(a, b) { return a.line - b.line || a.ch - b.ch; };\n\n  function copyPos(x) {return Pos(x.line, x.ch);}\n  function maxPos(a, b) { return cmp(a, b) < 0 ? b : a; }\n  function minPos(a, b) { return cmp(a, b) < 0 ? a : b; }\n\n  // SELECTION / CURSOR\n\n  // Selection objects are immutable. A new one is created every time\n  // the selection changes. A selection is one or more non-overlapping\n  // (and non-touching) ranges, sorted, and an integer that indicates\n  // which one is the primary selection (the one that's scrolled into\n  // view, that getCursor returns, etc).\n  function Selection(ranges, primIndex) {\n    this.ranges = ranges;\n    this.primIndex = primIndex;\n  }\n\n  Selection.prototype = {\n    primary: function() { return this.ranges[this.primIndex]; },\n    equals: function(other) {\n      if (other == this) return true;\n      if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) return false;\n      for (var i = 0; i < this.ranges.length; i++) {\n        var here = this.ranges[i], there = other.ranges[i];\n        if (cmp(here.anchor, there.anchor) != 0 || cmp(here.head, there.head) != 0) return false;\n      }\n      return true;\n    },\n    deepCopy: function() {\n      for (var out = [], i = 0; i < this.ranges.length; i++)\n        out[i] = new Range(copyPos(this.ranges[i].anchor), copyPos(this.ranges[i].head));\n      return new Selection(out, this.primIndex);\n    },\n    somethingSelected: function() {\n      for (var i = 0; i < this.ranges.length; i++)\n        if (!this.ranges[i].empty()) return true;\n      return false;\n    },\n    contains: function(pos, end) {\n      if (!end) end = pos;\n      for (var i = 0; i < this.ranges.length; i++) {\n        var range = this.ranges[i];\n        if (cmp(end, range.from()) >= 0 && cmp(pos, range.to()) <= 0)\n          return i;\n      }\n      return -1;\n    }\n  };\n\n  function Range(anchor, head) {\n    this.anchor = anchor; this.head = head;\n  }\n\n  Range.prototype = {\n    from: function() { return minPos(this.anchor, this.head); },\n    to: function() { return maxPos(this.anchor, this.head); },\n    empty: function() {\n      return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch;\n    }\n  };\n\n  // Take an unsorted, potentially overlapping set of ranges, and\n  // build a selection out of it. 'Consumes' ranges array (modifying\n  // it).\n  function normalizeSelection(ranges, primIndex) {\n    var prim = ranges[primIndex];\n    ranges.sort(function(a, b) { return cmp(a.from(), b.from()); });\n    primIndex = indexOf(ranges, prim);\n    for (var i = 1; i < ranges.length; i++) {\n      var cur = ranges[i], prev = ranges[i - 1];\n      if (cmp(prev.to(), cur.from()) >= 0) {\n        var from = minPos(prev.from(), cur.from()), to = maxPos(prev.to(), cur.to());\n        var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;\n        if (i <= primIndex) --primIndex;\n        ranges.splice(--i, 2, new Range(inv ? to : from, inv ? from : to));\n      }\n    }\n    return new Selection(ranges, primIndex);\n  }\n\n  function simpleSelection(anchor, head) {\n    return new Selection([new Range(anchor, head || anchor)], 0);\n  }\n\n  // Most of the external API clips given positions to make sure they\n  // actually exist within the document.\n  function clipLine(doc, n) {return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1));}\n  function clipPos(doc, pos) {\n    if (pos.line < doc.first) return Pos(doc.first, 0);\n    var last = doc.first + doc.size - 1;\n    if (pos.line > last) return Pos(last, getLine(doc, last).text.length);\n    return clipToLen(pos, getLine(doc, pos.line).text.length);\n  }\n  function clipToLen(pos, linelen) {\n    var ch = pos.ch;\n    if (ch == null || ch > linelen) return Pos(pos.line, linelen);\n    else if (ch < 0) return Pos(pos.line, 0);\n    else return pos;\n  }\n  function isLine(doc, l) {return l >= doc.first && l < doc.first + doc.size;}\n  function clipPosArray(doc, array) {\n    for (var out = [], i = 0; i < array.length; i++) out[i] = clipPos(doc, array[i]);\n    return out;\n  }\n\n  // SELECTION UPDATES\n\n  // The 'scroll' parameter given to many of these indicated whether\n  // the new cursor position should be scrolled into view after\n  // modifying the selection.\n\n  // If shift is held or the extend flag is set, extends a range to\n  // include a given position (and optionally a second position).\n  // Otherwise, simply returns the range between the given positions.\n  // Used for cursor motion and such.\n  function extendRange(doc, range, head, other) {\n    if (doc.cm && doc.cm.display.shift || doc.extend) {\n      var anchor = range.anchor;\n      if (other) {\n        var posBefore = cmp(head, anchor) < 0;\n        if (posBefore != (cmp(other, anchor) < 0)) {\n          anchor = head;\n          head = other;\n        } else if (posBefore != (cmp(head, other) < 0)) {\n          head = other;\n        }\n      }\n      return new Range(anchor, head);\n    } else {\n      return new Range(other || head, head);\n    }\n  }\n\n  // Extend the primary selection range, discard the rest.\n  function extendSelection(doc, head, other, options) {\n    setSelection(doc, new Selection([extendRange(doc, doc.sel.primary(), head, other)], 0), options);\n  }\n\n  // Extend all selections (pos is an array of selections with length\n  // equal the number of selections)\n  function extendSelections(doc, heads, options) {\n    for (var out = [], i = 0; i < doc.sel.ranges.length; i++)\n      out[i] = extendRange(doc, doc.sel.ranges[i], heads[i], null);\n    var newSel = normalizeSelection(out, doc.sel.primIndex);\n    setSelection(doc, newSel, options);\n  }\n\n  // Updates a single range in the selection.\n  function replaceOneSelection(doc, i, range, options) {\n    var ranges = doc.sel.ranges.slice(0);\n    ranges[i] = range;\n    setSelection(doc, normalizeSelection(ranges, doc.sel.primIndex), options);\n  }\n\n  // Reset the selection to a single range.\n  function setSimpleSelection(doc, anchor, head, options) {\n    setSelection(doc, simpleSelection(anchor, head), options);\n  }\n\n  // Give beforeSelectionChange handlers a change to influence a\n  // selection update.\n  function filterSelectionChange(doc, sel) {\n    var obj = {\n      ranges: sel.ranges,\n      update: function(ranges) {\n        this.ranges = [];\n        for (var i = 0; i < ranges.length; i++)\n          this.ranges[i] = new Range(clipPos(doc, ranges[i].anchor),\n                                     clipPos(doc, ranges[i].head));\n      }\n    };\n    signal(doc, \"beforeSelectionChange\", doc, obj);\n    if (doc.cm) signal(doc.cm, \"beforeSelectionChange\", doc.cm, obj);\n    if (obj.ranges != sel.ranges) return normalizeSelection(obj.ranges, obj.ranges.length - 1);\n    else return sel;\n  }\n\n  function setSelectionReplaceHistory(doc, sel, options) {\n    var done = doc.history.done, last = lst(done);\n    if (last && last.ranges) {\n      done[done.length - 1] = sel;\n      setSelectionNoUndo(doc, sel, options);\n    } else {\n      setSelection(doc, sel, options);\n    }\n  }\n\n  // Set a new selection.\n  function setSelection(doc, sel, options) {\n    setSelectionNoUndo(doc, sel, options);\n    addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options);\n  }\n\n  function setSelectionNoUndo(doc, sel, options) {\n    if (hasHandler(doc, \"beforeSelectionChange\") || doc.cm && hasHandler(doc.cm, \"beforeSelectionChange\"))\n      sel = filterSelectionChange(doc, sel);\n\n    var bias = options && options.bias ||\n      (cmp(sel.primary().head, doc.sel.primary().head) < 0 ? -1 : 1);\n    setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, true));\n\n    if (!(options && options.scroll === false) && doc.cm)\n      ensureCursorVisible(doc.cm);\n  }\n\n  function setSelectionInner(doc, sel) {\n    if (sel.equals(doc.sel)) return;\n\n    doc.sel = sel;\n\n    if (doc.cm) {\n      doc.cm.curOp.updateInput = doc.cm.curOp.selectionChanged = true;\n      signalCursorActivity(doc.cm);\n    }\n    signalLater(doc, \"cursorActivity\", doc);\n  }\n\n  // Verify that the selection does not partially select any atomic\n  // marked ranges.\n  function reCheckSelection(doc) {\n    setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, false), sel_dontScroll);\n  }\n\n  // Return a selection that does not partially select any atomic\n  // ranges.\n  function skipAtomicInSelection(doc, sel, bias, mayClear) {\n    var out;\n    for (var i = 0; i < sel.ranges.length; i++) {\n      var range = sel.ranges[i];\n      var newAnchor = skipAtomic(doc, range.anchor, bias, mayClear);\n      var newHead = skipAtomic(doc, range.head, bias, mayClear);\n      if (out || newAnchor != range.anchor || newHead != range.head) {\n        if (!out) out = sel.ranges.slice(0, i);\n        out[i] = new Range(newAnchor, newHead);\n      }\n    }\n    return out ? normalizeSelection(out, sel.primIndex) : sel;\n  }\n\n  // Ensure a given position is not inside an atomic range.\n  function skipAtomic(doc, pos, bias, mayClear) {\n    var flipped = false, curPos = pos;\n    var dir = bias || 1;\n    doc.cantEdit = false;\n    search: for (;;) {\n      var line = getLine(doc, curPos.line);\n      if (line.markedSpans) {\n        for (var i = 0; i < line.markedSpans.length; ++i) {\n          var sp = line.markedSpans[i], m = sp.marker;\n          if ((sp.from == null || (m.inclusiveLeft ? sp.from <= curPos.ch : sp.from < curPos.ch)) &&\n              (sp.to == null || (m.inclusiveRight ? sp.to >= curPos.ch : sp.to > curPos.ch))) {\n            if (mayClear) {\n              signal(m, \"beforeCursorEnter\");\n              if (m.explicitlyCleared) {\n                if (!line.markedSpans) break;\n                else {--i; continue;}\n              }\n            }\n            if (!m.atomic) continue;\n            var newPos = m.find(dir < 0 ? -1 : 1);\n            if (cmp(newPos, curPos) == 0) {\n              newPos.ch += dir;\n              if (newPos.ch < 0) {\n                if (newPos.line > doc.first) newPos = clipPos(doc, Pos(newPos.line - 1));\n                else newPos = null;\n              } else if (newPos.ch > line.text.length) {\n                if (newPos.line < doc.first + doc.size - 1) newPos = Pos(newPos.line + 1, 0);\n                else newPos = null;\n              }\n              if (!newPos) {\n                if (flipped) {\n                  // Driven in a corner -- no valid cursor position found at all\n                  // -- try again *with* clearing, if we didn't already\n                  if (!mayClear) return skipAtomic(doc, pos, bias, true);\n                  // Otherwise, turn off editing until further notice, and return the start of the doc\n                  doc.cantEdit = true;\n                  return Pos(doc.first, 0);\n                }\n                flipped = true; newPos = pos; dir = -dir;\n              }\n            }\n            curPos = newPos;\n            continue search;\n          }\n        }\n      }\n      return curPos;\n    }\n  }\n\n  // SELECTION DRAWING\n\n  // Redraw the selection and/or cursor\n  function drawSelection(cm) {\n    var display = cm.display, doc = cm.doc, result = {};\n    var curFragment = result.cursors = document.createDocumentFragment();\n    var selFragment = result.selection = document.createDocumentFragment();\n\n    for (var i = 0; i < doc.sel.ranges.length; i++) {\n      var range = doc.sel.ranges[i];\n      var collapsed = range.empty();\n      if (collapsed || cm.options.showCursorWhenSelecting)\n        drawSelectionCursor(cm, range, curFragment);\n      if (!collapsed)\n        drawSelectionRange(cm, range, selFragment);\n    }\n\n    // Move the hidden textarea near the cursor to prevent scrolling artifacts\n    if (cm.options.moveInputWithCursor) {\n      var headPos = cursorCoords(cm, doc.sel.primary().head, \"div\");\n      var wrapOff = display.wrapper.getBoundingClientRect(), lineOff = display.lineDiv.getBoundingClientRect();\n      result.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10,\n                                          headPos.top + lineOff.top - wrapOff.top));\n      result.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10,\n                                           headPos.left + lineOff.left - wrapOff.left));\n    }\n\n    return result;\n  }\n\n  function showSelection(cm, drawn) {\n    removeChildrenAndAdd(cm.display.cursorDiv, drawn.cursors);\n    removeChildrenAndAdd(cm.display.selectionDiv, drawn.selection);\n    if (drawn.teTop != null) {\n      cm.display.inputDiv.style.top = drawn.teTop + \"px\";\n      cm.display.inputDiv.style.left = drawn.teLeft + \"px\";\n    }\n  }\n\n  function updateSelection(cm) {\n    showSelection(cm, drawSelection(cm));\n  }\n\n  // Draws a cursor for the given range\n  function drawSelectionCursor(cm, range, output) {\n    var pos = cursorCoords(cm, range.head, \"div\", null, null, !cm.options.singleCursorHeightPerLine);\n\n    var cursor = output.appendChild(elt(\"div\", \"\\u00a0\", \"CodeMirror-cursor\"));\n    cursor.style.left = pos.left + \"px\";\n    cursor.style.top = pos.top + \"px\";\n    cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + \"px\";\n\n    if (pos.other) {\n      // Secondary cursor, shown when on a 'jump' in bi-directional text\n      var otherCursor = output.appendChild(elt(\"div\", \"\\u00a0\", \"CodeMirror-cursor CodeMirror-secondarycursor\"));\n      otherCursor.style.display = \"\";\n      otherCursor.style.left = pos.other.left + \"px\";\n      otherCursor.style.top = pos.other.top + \"px\";\n      otherCursor.style.height = (pos.other.bottom - pos.other.top) * .85 + \"px\";\n    }\n  }\n\n  // Draws the given range as a highlighted selection\n  function drawSelectionRange(cm, range, output) {\n    var display = cm.display, doc = cm.doc;\n    var fragment = document.createDocumentFragment();\n    var padding = paddingH(cm.display), leftSide = padding.left, rightSide = display.lineSpace.offsetWidth - padding.right;\n\n    function add(left, top, width, bottom) {\n      if (top < 0) top = 0;\n      top = Math.round(top);\n      bottom = Math.round(bottom);\n      fragment.appendChild(elt(\"div\", null, \"CodeMirror-selected\", \"position: absolute; left: \" + left +\n                               \"px; top: \" + top + \"px; width: \" + (width == null ? rightSide - left : width) +\n                               \"px; height: \" + (bottom - top) + \"px\"));\n    }\n\n    function drawForLine(line, fromArg, toArg) {\n      var lineObj = getLine(doc, line);\n      var lineLen = lineObj.text.length;\n      var start, end;\n      function coords(ch, bias) {\n        return charCoords(cm, Pos(line, ch), \"div\", lineObj, bias);\n      }\n\n      iterateBidiSections(getOrder(lineObj), fromArg || 0, toArg == null ? lineLen : toArg, function(from, to, dir) {\n        var leftPos = coords(from, \"left\"), rightPos, left, right;\n        if (from == to) {\n          rightPos = leftPos;\n          left = right = leftPos.left;\n        } else {\n          rightPos = coords(to - 1, \"right\");\n          if (dir == \"rtl\") { var tmp = leftPos; leftPos = rightPos; rightPos = tmp; }\n          left = leftPos.left;\n          right = rightPos.right;\n        }\n        if (fromArg == null && from == 0) left = leftSide;\n        if (rightPos.top - leftPos.top > 3) { // Different lines, draw top part\n          add(left, leftPos.top, null, leftPos.bottom);\n          left = leftSide;\n          if (leftPos.bottom < rightPos.top) add(left, leftPos.bottom, null, rightPos.top);\n        }\n        if (toArg == null && to == lineLen) right = rightSide;\n        if (!start || leftPos.top < start.top || leftPos.top == start.top && leftPos.left < start.left)\n          start = leftPos;\n        if (!end || rightPos.bottom > end.bottom || rightPos.bottom == end.bottom && rightPos.right > end.right)\n          end = rightPos;\n        if (left < leftSide + 1) left = leftSide;\n        add(left, rightPos.top, right - left, rightPos.bottom);\n      });\n      return {start: start, end: end};\n    }\n\n    var sFrom = range.from(), sTo = range.to();\n    if (sFrom.line == sTo.line) {\n      drawForLine(sFrom.line, sFrom.ch, sTo.ch);\n    } else {\n      var fromLine = getLine(doc, sFrom.line), toLine = getLine(doc, sTo.line);\n      var singleVLine = visualLine(fromLine) == visualLine(toLine);\n      var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end;\n      var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;\n      if (singleVLine) {\n        if (leftEnd.top < rightStart.top - 2) {\n          add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);\n          add(leftSide, rightStart.top, rightStart.left, rightStart.bottom);\n        } else {\n          add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);\n        }\n      }\n      if (leftEnd.bottom < rightStart.top)\n        add(leftSide, leftEnd.bottom, null, rightStart.top);\n    }\n\n    output.appendChild(fragment);\n  }\n\n  // Cursor-blinking\n  function restartBlink(cm) {\n    if (!cm.state.focused) return;\n    var display = cm.display;\n    clearInterval(display.blinker);\n    var on = true;\n    display.cursorDiv.style.visibility = \"\";\n    if (cm.options.cursorBlinkRate > 0)\n      display.blinker = setInterval(function() {\n        display.cursorDiv.style.visibility = (on = !on) ? \"\" : \"hidden\";\n      }, cm.options.cursorBlinkRate);\n    else if (cm.options.cursorBlinkRate < 0)\n      display.cursorDiv.style.visibility = \"hidden\";\n  }\n\n  // HIGHLIGHT WORKER\n\n  function startWorker(cm, time) {\n    if (cm.doc.mode.startState && cm.doc.frontier < cm.display.viewTo)\n      cm.state.highlight.set(time, bind(highlightWorker, cm));\n  }\n\n  function highlightWorker(cm) {\n    var doc = cm.doc;\n    if (doc.frontier < doc.first) doc.frontier = doc.first;\n    if (doc.frontier >= cm.display.viewTo) return;\n    var end = +new Date + cm.options.workTime;\n    var state = copyState(doc.mode, getStateBefore(cm, doc.frontier));\n    var changedLines = [];\n\n    doc.iter(doc.frontier, Math.min(doc.first + doc.size, cm.display.viewTo + 500), function(line) {\n      if (doc.frontier >= cm.display.viewFrom) { // Visible\n        var oldStyles = line.styles;\n        var highlighted = highlightLine(cm, line, state, true);\n        line.styles = highlighted.styles;\n        var oldCls = line.styleClasses, newCls = highlighted.classes;\n        if (newCls) line.styleClasses = newCls;\n        else if (oldCls) line.styleClasses = null;\n        var ischange = !oldStyles || oldStyles.length != line.styles.length ||\n          oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass);\n        for (var i = 0; !ischange && i < oldStyles.length; ++i) ischange = oldStyles[i] != line.styles[i];\n        if (ischange) changedLines.push(doc.frontier);\n        line.stateAfter = copyState(doc.mode, state);\n      } else {\n        processLine(cm, line.text, state);\n        line.stateAfter = doc.frontier % 5 == 0 ? copyState(doc.mode, state) : null;\n      }\n      ++doc.frontier;\n      if (+new Date > end) {\n        startWorker(cm, cm.options.workDelay);\n        return true;\n      }\n    });\n    if (changedLines.length) runInOp(cm, function() {\n      for (var i = 0; i < changedLines.length; i++)\n        regLineChange(cm, changedLines[i], \"text\");\n    });\n  }\n\n  // Finds the line to start with when starting a parse. Tries to\n  // find a line with a stateAfter, so that it can start with a\n  // valid state. If that fails, it returns the line with the\n  // smallest indentation, which tends to need the least context to\n  // parse correctly.\n  function findStartLine(cm, n, precise) {\n    var minindent, minline, doc = cm.doc;\n    var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1000 : 100);\n    for (var search = n; search > lim; --search) {\n      if (search <= doc.first) return doc.first;\n      var line = getLine(doc, search - 1);\n      if (line.stateAfter && (!precise || search <= doc.frontier)) return search;\n      var indented = countColumn(line.text, null, cm.options.tabSize);\n      if (minline == null || minindent > indented) {\n        minline = search - 1;\n        minindent = indented;\n      }\n    }\n    return minline;\n  }\n\n  function getStateBefore(cm, n, precise) {\n    var doc = cm.doc, display = cm.display;\n    if (!doc.mode.startState) return true;\n    var pos = findStartLine(cm, n, precise), state = pos > doc.first && getLine(doc, pos-1).stateAfter;\n    if (!state) state = startState(doc.mode);\n    else state = copyState(doc.mode, state);\n    doc.iter(pos, n, function(line) {\n      processLine(cm, line.text, state);\n      var save = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo;\n      line.stateAfter = save ? copyState(doc.mode, state) : null;\n      ++pos;\n    });\n    if (precise) doc.frontier = pos;\n    return state;\n  }\n\n  // POSITION MEASUREMENT\n\n  function paddingTop(display) {return display.lineSpace.offsetTop;}\n  function paddingVert(display) {return display.mover.offsetHeight - display.lineSpace.offsetHeight;}\n  function paddingH(display) {\n    if (display.cachedPaddingH) return display.cachedPaddingH;\n    var e = removeChildrenAndAdd(display.measure, elt(\"pre\", \"x\"));\n    var style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle;\n    var data = {left: parseInt(style.paddingLeft), right: parseInt(style.paddingRight)};\n    if (!isNaN(data.left) && !isNaN(data.right)) display.cachedPaddingH = data;\n    return data;\n  }\n\n  // Ensure the lineView.wrapping.heights array is populated. This is\n  // an array of bottom offsets for the lines that make up a drawn\n  // line. When lineWrapping is on, there might be more than one\n  // height.\n  function ensureLineHeights(cm, lineView, rect) {\n    var wrapping = cm.options.lineWrapping;\n    var curWidth = wrapping && cm.display.scroller.clientWidth;\n    if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {\n      var heights = lineView.measure.heights = [];\n      if (wrapping) {\n        lineView.measure.width = curWidth;\n        var rects = lineView.text.firstChild.getClientRects();\n        for (var i = 0; i < rects.length - 1; i++) {\n          var cur = rects[i], next = rects[i + 1];\n          if (Math.abs(cur.bottom - next.bottom) > 2)\n            heights.push((cur.bottom + next.top) / 2 - rect.top);\n        }\n      }\n      heights.push(rect.bottom - rect.top);\n    }\n  }\n\n  // Find a line map (mapping character offsets to text nodes) and a\n  // measurement cache for the given line number. (A line view might\n  // contain multiple lines when collapsed ranges are present.)\n  function mapFromLineView(lineView, line, lineN) {\n    if (lineView.line == line)\n      return {map: lineView.measure.map, cache: lineView.measure.cache};\n    for (var i = 0; i < lineView.rest.length; i++)\n      if (lineView.rest[i] == line)\n        return {map: lineView.measure.maps[i], cache: lineView.measure.caches[i]};\n    for (var i = 0; i < lineView.rest.length; i++)\n      if (lineNo(lineView.rest[i]) > lineN)\n        return {map: lineView.measure.maps[i], cache: lineView.measure.caches[i], before: true};\n  }\n\n  // Render a line into the hidden node display.externalMeasured. Used\n  // when measurement is needed for a line that's not in the viewport.\n  function updateExternalMeasurement(cm, line) {\n    line = visualLine(line);\n    var lineN = lineNo(line);\n    var view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN);\n    view.lineN = lineN;\n    var built = view.built = buildLineContent(cm, view);\n    view.text = built.pre;\n    removeChildrenAndAdd(cm.display.lineMeasure, built.pre);\n    return view;\n  }\n\n  // Get a {top, bottom, left, right} box (in line-local coordinates)\n  // for a given character.\n  function measureChar(cm, line, ch, bias) {\n    return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias);\n  }\n\n  // Find a line view that corresponds to the given line number.\n  function findViewForLine(cm, lineN) {\n    if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo)\n      return cm.display.view[findViewIndex(cm, lineN)];\n    var ext = cm.display.externalMeasured;\n    if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size)\n      return ext;\n  }\n\n  // Measurement can be split in two steps, the set-up work that\n  // applies to the whole line, and the measurement of the actual\n  // character. Functions like coordsChar, that need to do a lot of\n  // measurements in a row, can thus ensure that the set-up work is\n  // only done once.\n  function prepareMeasureForLine(cm, line) {\n    var lineN = lineNo(line);\n    var view = findViewForLine(cm, lineN);\n    if (view && !view.text)\n      view = null;\n    else if (view && view.changes)\n      updateLineForChanges(cm, view, lineN, getDimensions(cm));\n    if (!view)\n      view = updateExternalMeasurement(cm, line);\n\n    var info = mapFromLineView(view, line, lineN);\n    return {\n      line: line, view: view, rect: null,\n      map: info.map, cache: info.cache, before: info.before,\n      hasHeights: false\n    };\n  }\n\n  // Given a prepared measurement object, measures the position of an\n  // actual character (or fetches it from the cache).\n  function measureCharPrepared(cm, prepared, ch, bias, varHeight) {\n    if (prepared.before) ch = -1;\n    var key = ch + (bias || \"\"), found;\n    if (prepared.cache.hasOwnProperty(key)) {\n      found = prepared.cache[key];\n    } else {\n      if (!prepared.rect)\n        prepared.rect = prepared.view.text.getBoundingClientRect();\n      if (!prepared.hasHeights) {\n        ensureLineHeights(cm, prepared.view, prepared.rect);\n        prepared.hasHeights = true;\n      }\n      found = measureCharInner(cm, prepared, ch, bias);\n      if (!found.bogus) prepared.cache[key] = found;\n    }\n    return {left: found.left, right: found.right,\n            top: varHeight ? found.rtop : found.top,\n            bottom: varHeight ? found.rbottom : found.bottom};\n  }\n\n  var nullRect = {left: 0, right: 0, top: 0, bottom: 0};\n\n  function measureCharInner(cm, prepared, ch, bias) {\n    var map = prepared.map;\n\n    var node, start, end, collapse;\n    // First, search the line map for the text node corresponding to,\n    // or closest to, the target character.\n    for (var i = 0; i < map.length; i += 3) {\n      var mStart = map[i], mEnd = map[i + 1];\n      if (ch < mStart) {\n        start = 0; end = 1;\n        collapse = \"left\";\n      } else if (ch < mEnd) {\n        start = ch - mStart;\n        end = start + 1;\n      } else if (i == map.length - 3 || ch == mEnd && map[i + 3] > ch) {\n        end = mEnd - mStart;\n        start = end - 1;\n        if (ch >= mEnd) collapse = \"right\";\n      }\n      if (start != null) {\n        node = map[i + 2];\n        if (mStart == mEnd && bias == (node.insertLeft ? \"left\" : \"right\"))\n          collapse = bias;\n        if (bias == \"left\" && start == 0)\n          while (i && map[i - 2] == map[i - 3] && map[i - 1].insertLeft) {\n            node = map[(i -= 3) + 2];\n            collapse = \"left\";\n          }\n        if (bias == \"right\" && start == mEnd - mStart)\n          while (i < map.length - 3 && map[i + 3] == map[i + 4] && !map[i + 5].insertLeft) {\n            node = map[(i += 3) + 2];\n            collapse = \"right\";\n          }\n        break;\n      }\n    }\n\n    var rect;\n    if (node.nodeType == 3) { // If it is a text node, use a range to retrieve the coordinates.\n      for (var i = 0; i < 4; i++) { // Retry a maximum of 4 times when nonsense rectangles are returned\n        while (start && isExtendingChar(prepared.line.text.charAt(mStart + start))) --start;\n        while (mStart + end < mEnd && isExtendingChar(prepared.line.text.charAt(mStart + end))) ++end;\n        if (ie && ie_version < 9 && start == 0 && end == mEnd - mStart) {\n          rect = node.parentNode.getBoundingClientRect();\n        } else if (ie && cm.options.lineWrapping) {\n          var rects = range(node, start, end).getClientRects();\n          if (rects.length)\n            rect = rects[bias == \"right\" ? rects.length - 1 : 0];\n          else\n            rect = nullRect;\n        } else {\n          rect = range(node, start, end).getBoundingClientRect() || nullRect;\n        }\n        if (rect.left || rect.right || start == 0) break;\n        end = start;\n        start = start - 1;\n        collapse = \"right\";\n      }\n      if (ie && ie_version < 11) rect = maybeUpdateRectForZooming(cm.display.measure, rect);\n    } else { // If it is a widget, simply get the box for the whole widget.\n      if (start > 0) collapse = bias = \"right\";\n      var rects;\n      if (cm.options.lineWrapping && (rects = node.getClientRects()).length > 1)\n        rect = rects[bias == \"right\" ? rects.length - 1 : 0];\n      else\n        rect = node.getBoundingClientRect();\n    }\n    if (ie && ie_version < 9 && !start && (!rect || !rect.left && !rect.right)) {\n      var rSpan = node.parentNode.getClientRects()[0];\n      if (rSpan)\n        rect = {left: rSpan.left, right: rSpan.left + charWidth(cm.display), top: rSpan.top, bottom: rSpan.bottom};\n      else\n        rect = nullRect;\n    }\n\n    var rtop = rect.top - prepared.rect.top, rbot = rect.bottom - prepared.rect.top;\n    var mid = (rtop + rbot) / 2;\n    var heights = prepared.view.measure.heights;\n    for (var i = 0; i < heights.length - 1; i++)\n      if (mid < heights[i]) break;\n    var top = i ? heights[i - 1] : 0, bot = heights[i];\n    var result = {left: (collapse == \"right\" ? rect.right : rect.left) - prepared.rect.left,\n                  right: (collapse == \"left\" ? rect.left : rect.right) - prepared.rect.left,\n                  top: top, bottom: bot};\n    if (!rect.left && !rect.right) result.bogus = true;\n    if (!cm.options.singleCursorHeightPerLine) { result.rtop = rtop; result.rbottom = rbot; }\n\n    return result;\n  }\n\n  // Work around problem with bounding client rects on ranges being\n  // returned incorrectly when zoomed on IE10 and below.\n  function maybeUpdateRectForZooming(measure, rect) {\n    if (!window.screen || screen.logicalXDPI == null ||\n        screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure))\n      return rect;\n    var scaleX = screen.logicalXDPI / screen.deviceXDPI;\n    var scaleY = screen.logicalYDPI / screen.deviceYDPI;\n    return {left: rect.left * scaleX, right: rect.right * scaleX,\n            top: rect.top * scaleY, bottom: rect.bottom * scaleY};\n  }\n\n  function clearLineMeasurementCacheFor(lineView) {\n    if (lineView.measure) {\n      lineView.measure.cache = {};\n      lineView.measure.heights = null;\n      if (lineView.rest) for (var i = 0; i < lineView.rest.length; i++)\n        lineView.measure.caches[i] = {};\n    }\n  }\n\n  function clearLineMeasurementCache(cm) {\n    cm.display.externalMeasure = null;\n    removeChildren(cm.display.lineMeasure);\n    for (var i = 0; i < cm.display.view.length; i++)\n      clearLineMeasurementCacheFor(cm.display.view[i]);\n  }\n\n  function clearCaches(cm) {\n    clearLineMeasurementCache(cm);\n    cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null;\n    if (!cm.options.lineWrapping) cm.display.maxLineChanged = true;\n    cm.display.lineNumChars = null;\n  }\n\n  function pageScrollX() { return window.pageXOffset || (document.documentElement || document.body).scrollLeft; }\n  function pageScrollY() { return window.pageYOffset || (document.documentElement || document.body).scrollTop; }\n\n  // Converts a {top, bottom, left, right} box from line-local\n  // coordinates into another coordinate system. Context may be one of\n  // \"line\", \"div\" (display.lineDiv), \"local\"/null (editor), or \"page\".\n  function intoCoordSystem(cm, lineObj, rect, context) {\n    if (lineObj.widgets) for (var i = 0; i < lineObj.widgets.length; ++i) if (lineObj.widgets[i].above) {\n      var size = widgetHeight(lineObj.widgets[i]);\n      rect.top += size; rect.bottom += size;\n    }\n    if (context == \"line\") return rect;\n    if (!context) context = \"local\";\n    var yOff = heightAtLine(lineObj);\n    if (context == \"local\") yOff += paddingTop(cm.display);\n    else yOff -= cm.display.viewOffset;\n    if (context == \"page\" || context == \"window\") {\n      var lOff = cm.display.lineSpace.getBoundingClientRect();\n      yOff += lOff.top + (context == \"window\" ? 0 : pageScrollY());\n      var xOff = lOff.left + (context == \"window\" ? 0 : pageScrollX());\n      rect.left += xOff; rect.right += xOff;\n    }\n    rect.top += yOff; rect.bottom += yOff;\n    return rect;\n  }\n\n  // Coverts a box from \"div\" coords to another coordinate system.\n  // Context may be \"window\", \"page\", \"div\", or \"local\"/null.\n  function fromCoordSystem(cm, coords, context) {\n    if (context == \"div\") return coords;\n    var left = coords.left, top = coords.top;\n    // First move into \"page\" coordinate system\n    if (context == \"page\") {\n      left -= pageScrollX();\n      top -= pageScrollY();\n    } else if (context == \"local\" || !context) {\n      var localBox = cm.display.sizer.getBoundingClientRect();\n      left += localBox.left;\n      top += localBox.top;\n    }\n\n    var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();\n    return {left: left - lineSpaceBox.left, top: top - lineSpaceBox.top};\n  }\n\n  function charCoords(cm, pos, context, lineObj, bias) {\n    if (!lineObj) lineObj = getLine(cm.doc, pos.line);\n    return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context);\n  }\n\n  // Returns a box for a given cursor position, which may have an\n  // 'other' property containing the position of the secondary cursor\n  // on a bidi boundary.\n  function cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {\n    lineObj = lineObj || getLine(cm.doc, pos.line);\n    if (!preparedMeasure) preparedMeasure = prepareMeasureForLine(cm, lineObj);\n    function get(ch, right) {\n      var m = measureCharPrepared(cm, preparedMeasure, ch, right ? \"right\" : \"left\", varHeight);\n      if (right) m.left = m.right; else m.right = m.left;\n      return intoCoordSystem(cm, lineObj, m, context);\n    }\n    function getBidi(ch, partPos) {\n      var part = order[partPos], right = part.level % 2;\n      if (ch == bidiLeft(part) && partPos && part.level < order[partPos - 1].level) {\n        part = order[--partPos];\n        ch = bidiRight(part) - (part.level % 2 ? 0 : 1);\n        right = true;\n      } else if (ch == bidiRight(part) && partPos < order.length - 1 && part.level < order[partPos + 1].level) {\n        part = order[++partPos];\n        ch = bidiLeft(part) - part.level % 2;\n        right = false;\n      }\n      if (right && ch == part.to && ch > part.from) return get(ch - 1);\n      return get(ch, right);\n    }\n    var order = getOrder(lineObj), ch = pos.ch;\n    if (!order) return get(ch);\n    var partPos = getBidiPartAt(order, ch);\n    var val = getBidi(ch, partPos);\n    if (bidiOther != null) val.other = getBidi(ch, bidiOther);\n    return val;\n  }\n\n  // Used to cheaply estimate the coordinates for a position. Used for\n  // intermediate scroll updates.\n  function estimateCoords(cm, pos) {\n    var left = 0, pos = clipPos(cm.doc, pos);\n    if (!cm.options.lineWrapping) left = charWidth(cm.display) * pos.ch;\n    var lineObj = getLine(cm.doc, pos.line);\n    var top = heightAtLine(lineObj) + paddingTop(cm.display);\n    return {left: left, right: left, top: top, bottom: top + lineObj.height};\n  }\n\n  // Positions returned by coordsChar contain some extra information.\n  // xRel is the relative x position of the input coordinates compared\n  // to the found position (so xRel > 0 means the coordinates are to\n  // the right of the character position, for example). When outside\n  // is true, that means the coordinates lie outside the line's\n  // vertical range.\n  function PosWithInfo(line, ch, outside, xRel) {\n    var pos = Pos(line, ch);\n    pos.xRel = xRel;\n    if (outside) pos.outside = true;\n    return pos;\n  }\n\n  // Compute the character position closest to the given coordinates.\n  // Input must be lineSpace-local (\"div\" coordinate system).\n  function coordsChar(cm, x, y) {\n    var doc = cm.doc;\n    y += cm.display.viewOffset;\n    if (y < 0) return PosWithInfo(doc.first, 0, true, -1);\n    var lineN = lineAtHeight(doc, y), last = doc.first + doc.size - 1;\n    if (lineN > last)\n      return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, true, 1);\n    if (x < 0) x = 0;\n\n    var lineObj = getLine(doc, lineN);\n    for (;;) {\n      var found = coordsCharInner(cm, lineObj, lineN, x, y);\n      var merged = collapsedSpanAtEnd(lineObj);\n      var mergedPos = merged && merged.find(0, true);\n      if (merged && (found.ch > mergedPos.from.ch || found.ch == mergedPos.from.ch && found.xRel > 0))\n        lineN = lineNo(lineObj = mergedPos.to.line);\n      else\n        return found;\n    }\n  }\n\n  function coordsCharInner(cm, lineObj, lineNo, x, y) {\n    var innerOff = y - heightAtLine(lineObj);\n    var wrongLine = false, adjust = 2 * cm.display.wrapper.clientWidth;\n    var preparedMeasure = prepareMeasureForLine(cm, lineObj);\n\n    function getX(ch) {\n      var sp = cursorCoords(cm, Pos(lineNo, ch), \"line\", lineObj, preparedMeasure);\n      wrongLine = true;\n      if (innerOff > sp.bottom) return sp.left - adjust;\n      else if (innerOff < sp.top) return sp.left + adjust;\n      else wrongLine = false;\n      return sp.left;\n    }\n\n    var bidi = getOrder(lineObj), dist = lineObj.text.length;\n    var from = lineLeft(lineObj), to = lineRight(lineObj);\n    var fromX = getX(from), fromOutside = wrongLine, toX = getX(to), toOutside = wrongLine;\n\n    if (x > toX) return PosWithInfo(lineNo, to, toOutside, 1);\n    // Do a binary search between these bounds.\n    for (;;) {\n      if (bidi ? to == from || to == moveVisually(lineObj, from, 1) : to - from <= 1) {\n        var ch = x < fromX || x - fromX <= toX - x ? from : to;\n        var xDiff = x - (ch == from ? fromX : toX);\n        while (isExtendingChar(lineObj.text.charAt(ch))) ++ch;\n        var pos = PosWithInfo(lineNo, ch, ch == from ? fromOutside : toOutside,\n                              xDiff < -1 ? -1 : xDiff > 1 ? 1 : 0);\n        return pos;\n      }\n      var step = Math.ceil(dist / 2), middle = from + step;\n      if (bidi) {\n        middle = from;\n        for (var i = 0; i < step; ++i) middle = moveVisually(lineObj, middle, 1);\n      }\n      var middleX = getX(middle);\n      if (middleX > x) {to = middle; toX = middleX; if (toOutside = wrongLine) toX += 1000; dist = step;}\n      else {from = middle; fromX = middleX; fromOutside = wrongLine; dist -= step;}\n    }\n  }\n\n  var measureText;\n  // Compute the default text height.\n  function textHeight(display) {\n    if (display.cachedTextHeight != null) return display.cachedTextHeight;\n    if (measureText == null) {\n      measureText = elt(\"pre\");\n      // Measure a bunch of lines, for browsers that compute\n      // fractional heights.\n      for (var i = 0; i < 49; ++i) {\n        measureText.appendChild(document.createTextNode(\"x\"));\n        measureText.appendChild(elt(\"br\"));\n      }\n      measureText.appendChild(document.createTextNode(\"x\"));\n    }\n    removeChildrenAndAdd(display.measure, measureText);\n    var height = measureText.offsetHeight / 50;\n    if (height > 3) display.cachedTextHeight = height;\n    removeChildren(display.measure);\n    return height || 1;\n  }\n\n  // Compute the default character width.\n  function charWidth(display) {\n    if (display.cachedCharWidth != null) return display.cachedCharWidth;\n    var anchor = elt(\"span\", \"xxxxxxxxxx\");\n    var pre = elt(\"pre\", [anchor]);\n    removeChildrenAndAdd(display.measure, pre);\n    var rect = anchor.getBoundingClientRect(), width = (rect.right - rect.left) / 10;\n    if (width > 2) display.cachedCharWidth = width;\n    return width || 10;\n  }\n\n  // OPERATIONS\n\n  // Operations are used to wrap a series of changes to the editor\n  // state in such a way that each change won't have to update the\n  // cursor and display (which would be awkward, slow, and\n  // error-prone). Instead, display updates are batched and then all\n  // combined and executed at once.\n\n  var operationGroup = null;\n\n  var nextOpId = 0;\n  // Start a new operation.\n  function startOperation(cm) {\n    cm.curOp = {\n      cm: cm,\n      viewChanged: false,      // Flag that indicates that lines might need to be redrawn\n      startHeight: cm.doc.height, // Used to detect need to update scrollbar\n      forceUpdate: false,      // Used to force a redraw\n      updateInput: null,       // Whether to reset the input textarea\n      typing: false,           // Whether this reset should be careful to leave existing text (for compositing)\n      changeObjs: null,        // Accumulated changes, for firing change events\n      cursorActivityHandlers: null, // Set of handlers to fire cursorActivity on\n      cursorActivityCalled: 0, // Tracks which cursorActivity handlers have been called already\n      selectionChanged: false, // Whether the selection needs to be redrawn\n      updateMaxLine: false,    // Set when the widest line needs to be determined anew\n      scrollLeft: null, scrollTop: null, // Intermediate scroll position, not pushed to DOM yet\n      scrollToPos: null,       // Used to scroll to a specific position\n      id: ++nextOpId           // Unique ID\n    };\n    if (operationGroup) {\n      operationGroup.ops.push(cm.curOp);\n    } else {\n      cm.curOp.ownsGroup = operationGroup = {\n        ops: [cm.curOp],\n        delayedCallbacks: []\n      };\n    }\n  }\n\n  function fireCallbacksForOps(group) {\n    // Calls delayed callbacks and cursorActivity handlers until no\n    // new ones appear\n    var callbacks = group.delayedCallbacks, i = 0;\n    do {\n      for (; i < callbacks.length; i++)\n        callbacks[i]();\n      for (var j = 0; j < group.ops.length; j++) {\n        var op = group.ops[j];\n        if (op.cursorActivityHandlers)\n          while (op.cursorActivityCalled < op.cursorActivityHandlers.length)\n            op.cursorActivityHandlers[op.cursorActivityCalled++](op.cm);\n      }\n    } while (i < callbacks.length);\n  }\n\n  // Finish an operation, updating the display and signalling delayed events\n  function endOperation(cm) {\n    var op = cm.curOp, group = op.ownsGroup;\n    if (!group) return;\n\n    try { fireCallbacksForOps(group); }\n    finally {\n      operationGroup = null;\n      for (var i = 0; i < group.ops.length; i++)\n        group.ops[i].cm.curOp = null;\n      endOperations(group);\n    }\n  }\n\n  // The DOM updates done when an operation finishes are batched so\n  // that the minimum number of relayouts are required.\n  function endOperations(group) {\n    var ops = group.ops;\n    for (var i = 0; i < ops.length; i++) // Read DOM\n      endOperation_R1(ops[i]);\n    for (var i = 0; i < ops.length; i++) // Write DOM (maybe)\n      endOperation_W1(ops[i]);\n    for (var i = 0; i < ops.length; i++) // Read DOM\n      endOperation_R2(ops[i]);\n    for (var i = 0; i < ops.length; i++) // Write DOM (maybe)\n      endOperation_W2(ops[i]);\n    for (var i = 0; i < ops.length; i++) // Read DOM\n      endOperation_finish(ops[i]);\n  }\n\n  function endOperation_R1(op) {\n    var cm = op.cm, display = cm.display;\n    if (op.updateMaxLine) findMaxLine(cm);\n\n    op.mustUpdate = op.viewChanged || op.forceUpdate || op.scrollTop != null ||\n      op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom ||\n                         op.scrollToPos.to.line >= display.viewTo) ||\n      display.maxLineChanged && cm.options.lineWrapping;\n    op.update = op.mustUpdate &&\n      new DisplayUpdate(cm, op.mustUpdate && {top: op.scrollTop, ensure: op.scrollToPos}, op.forceUpdate);\n  }\n\n  function endOperation_W1(op) {\n    op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update);\n  }\n\n  function endOperation_R2(op) {\n    var cm = op.cm, display = cm.display;\n    if (op.updatedDisplay) updateHeightsInViewport(cm);\n\n    op.barMeasure = measureForScrollbars(cm);\n\n    // If the max line changed since it was last measured, measure it,\n    // and ensure the document's width matches it.\n    // updateDisplay_W2 will use these properties to do the actual resizing\n    if (display.maxLineChanged && !cm.options.lineWrapping) {\n      op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3;\n      op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo +\n                                  scrollerCutOff - display.scroller.clientWidth);\n    }\n\n    if (op.updatedDisplay || op.selectionChanged)\n      op.newSelectionNodes = drawSelection(cm);\n  }\n\n  function endOperation_W2(op) {\n    var cm = op.cm;\n\n    if (op.adjustWidthTo != null) {\n      cm.display.sizer.style.minWidth = op.adjustWidthTo + \"px\";\n      if (op.maxScrollLeft < cm.doc.scrollLeft)\n        setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), true);\n      cm.display.maxLineChanged = false;\n    }\n\n    if (op.newSelectionNodes)\n      showSelection(cm, op.newSelectionNodes);\n    if (op.updatedDisplay)\n      setDocumentHeight(cm, op.barMeasure);\n    if (op.updatedDisplay || op.startHeight != cm.doc.height)\n      updateScrollbars(cm, op.barMeasure);\n\n    if (op.selectionChanged) restartBlink(cm);\n\n    if (cm.state.focused && op.updateInput)\n      resetInput(cm, op.typing);\n  }\n\n  function endOperation_finish(op) {\n    var cm = op.cm, display = cm.display, doc = cm.doc;\n\n    if (op.adjustWidthTo != null && Math.abs(op.barMeasure.scrollWidth - cm.display.scroller.scrollWidth) > 1)\n      updateScrollbars(cm);\n\n    if (op.updatedDisplay) postUpdateDisplay(cm, op.update);\n\n    // Abort mouse wheel delta measurement, when scrolling explicitly\n    if (display.wheelStartX != null && (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos))\n      display.wheelStartX = display.wheelStartY = null;\n\n    // Propagate the scroll position to the actual DOM scroller\n    if (op.scrollTop != null && (display.scroller.scrollTop != op.scrollTop || op.forceScroll)) {\n      var top = Math.max(0, Math.min(display.scroller.scrollHeight - display.scroller.clientHeight, op.scrollTop));\n      display.scroller.scrollTop = display.scrollbarV.scrollTop = doc.scrollTop = top;\n    }\n    if (op.scrollLeft != null && (display.scroller.scrollLeft != op.scrollLeft || op.forceScroll)) {\n      var left = Math.max(0, Math.min(display.scroller.scrollWidth - display.scroller.clientWidth, op.scrollLeft));\n      display.scroller.scrollLeft = display.scrollbarH.scrollLeft = doc.scrollLeft = left;\n      alignHorizontally(cm);\n    }\n    // If we need to scroll a specific position into view, do so.\n    if (op.scrollToPos) {\n      var coords = scrollPosIntoView(cm, clipPos(doc, op.scrollToPos.from),\n                                     clipPos(doc, op.scrollToPos.to), op.scrollToPos.margin);\n      if (op.scrollToPos.isCursor && cm.state.focused) maybeScrollWindow(cm, coords);\n    }\n\n    // Fire events for markers that are hidden/unidden by editing or\n    // undoing\n    var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;\n    if (hidden) for (var i = 0; i < hidden.length; ++i)\n      if (!hidden[i].lines.length) signal(hidden[i], \"hide\");\n    if (unhidden) for (var i = 0; i < unhidden.length; ++i)\n      if (unhidden[i].lines.length) signal(unhidden[i], \"unhide\");\n\n    if (display.wrapper.offsetHeight)\n      doc.scrollTop = cm.display.scroller.scrollTop;\n\n    // Apply workaround for two webkit bugs\n    if (op.updatedDisplay && webkit) {\n      if (cm.options.lineWrapping)\n        checkForWebkitWidthBug(cm, op.barMeasure); // (Issue #2420)\n      if (op.barMeasure.scrollWidth > op.barMeasure.clientWidth &&\n          op.barMeasure.scrollWidth < op.barMeasure.clientWidth + 1 &&\n          !hScrollbarTakesSpace(cm))\n        updateScrollbars(cm); // (Issue #2562)\n    }\n\n    // Fire change events, and delayed event handlers\n    if (op.changeObjs)\n      signal(cm, \"changes\", cm, op.changeObjs);\n  }\n\n  // Run the given function in an operation\n  function runInOp(cm, f) {\n    if (cm.curOp) return f();\n    startOperation(cm);\n    try { return f(); }\n    finally { endOperation(cm); }\n  }\n  // Wraps a function in an operation. Returns the wrapped function.\n  function operation(cm, f) {\n    return function() {\n      if (cm.curOp) return f.apply(cm, arguments);\n      startOperation(cm);\n      try { return f.apply(cm, arguments); }\n      finally { endOperation(cm); }\n    };\n  }\n  // Used to add methods to editor and doc instances, wrapping them in\n  // operations.\n  function methodOp(f) {\n    return function() {\n      if (this.curOp) return f.apply(this, arguments);\n      startOperation(this);\n      try { return f.apply(this, arguments); }\n      finally { endOperation(this); }\n    };\n  }\n  function docMethodOp(f) {\n    return function() {\n      var cm = this.cm;\n      if (!cm || cm.curOp) return f.apply(this, arguments);\n      startOperation(cm);\n      try { return f.apply(this, arguments); }\n      finally { endOperation(cm); }\n    };\n  }\n\n  // VIEW TRACKING\n\n  // These objects are used to represent the visible (currently drawn)\n  // part of the document. A LineView may correspond to multiple\n  // logical lines, if those are connected by collapsed ranges.\n  function LineView(doc, line, lineN) {\n    // The starting line\n    this.line = line;\n    // Continuing lines, if any\n    this.rest = visualLineContinued(line);\n    // Number of logical lines in this visual line\n    this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1;\n    this.node = this.text = null;\n    this.hidden = lineIsHidden(doc, line);\n  }\n\n  // Create a range of LineView objects for the given lines.\n  function buildViewArray(cm, from, to) {\n    var array = [], nextPos;\n    for (var pos = from; pos < to; pos = nextPos) {\n      var view = new LineView(cm.doc, getLine(cm.doc, pos), pos);\n      nextPos = pos + view.size;\n      array.push(view);\n    }\n    return array;\n  }\n\n  // Updates the display.view data structure for a given change to the\n  // document. From and to are in pre-change coordinates. Lendiff is\n  // the amount of lines added or subtracted by the change. This is\n  // used for changes that span multiple lines, or change the way\n  // lines are divided into visual lines. regLineChange (below)\n  // registers single-line changes.\n  function regChange(cm, from, to, lendiff) {\n    if (from == null) from = cm.doc.first;\n    if (to == null) to = cm.doc.first + cm.doc.size;\n    if (!lendiff) lendiff = 0;\n\n    var display = cm.display;\n    if (lendiff && to < display.viewTo &&\n        (display.updateLineNumbers == null || display.updateLineNumbers > from))\n      display.updateLineNumbers = from;\n\n    cm.curOp.viewChanged = true;\n\n    if (from >= display.viewTo) { // Change after\n      if (sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo)\n        resetView(cm);\n    } else if (to <= display.viewFrom) { // Change before\n      if (sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom) {\n        resetView(cm);\n      } else {\n        display.viewFrom += lendiff;\n        display.viewTo += lendiff;\n      }\n    } else if (from <= display.viewFrom && to >= display.viewTo) { // Full overlap\n      resetView(cm);\n    } else if (from <= display.viewFrom) { // Top overlap\n      var cut = viewCuttingPoint(cm, to, to + lendiff, 1);\n      if (cut) {\n        display.view = display.view.slice(cut.index);\n        display.viewFrom = cut.lineN;\n        display.viewTo += lendiff;\n      } else {\n        resetView(cm);\n      }\n    } else if (to >= display.viewTo) { // Bottom overlap\n      var cut = viewCuttingPoint(cm, from, from, -1);\n      if (cut) {\n        display.view = display.view.slice(0, cut.index);\n        display.viewTo = cut.lineN;\n      } else {\n        resetView(cm);\n      }\n    } else { // Gap in the middle\n      var cutTop = viewCuttingPoint(cm, from, from, -1);\n      var cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);\n      if (cutTop && cutBot) {\n        display.view = display.view.slice(0, cutTop.index)\n          .concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN))\n          .concat(display.view.slice(cutBot.index));\n        display.viewTo += lendiff;\n      } else {\n        resetView(cm);\n      }\n    }\n\n    var ext = display.externalMeasured;\n    if (ext) {\n      if (to < ext.lineN)\n        ext.lineN += lendiff;\n      else if (from < ext.lineN + ext.size)\n        display.externalMeasured = null;\n    }\n  }\n\n  // Register a change to a single line. Type must be one of \"text\",\n  // \"gutter\", \"class\", \"widget\"\n  function regLineChange(cm, line, type) {\n    cm.curOp.viewChanged = true;\n    var display = cm.display, ext = cm.display.externalMeasured;\n    if (ext && line >= ext.lineN && line < ext.lineN + ext.size)\n      display.externalMeasured = null;\n\n    if (line < display.viewFrom || line >= display.viewTo) return;\n    var lineView = display.view[findViewIndex(cm, line)];\n    if (lineView.node == null) return;\n    var arr = lineView.changes || (lineView.changes = []);\n    if (indexOf(arr, type) == -1) arr.push(type);\n  }\n\n  // Clear the view.\n  function resetView(cm) {\n    cm.display.viewFrom = cm.display.viewTo = cm.doc.first;\n    cm.display.view = [];\n    cm.display.viewOffset = 0;\n  }\n\n  // Find the view element corresponding to a given line. Return null\n  // when the line isn't visible.\n  function findViewIndex(cm, n) {\n    if (n >= cm.display.viewTo) return null;\n    n -= cm.display.viewFrom;\n    if (n < 0) return null;\n    var view = cm.display.view;\n    for (var i = 0; i < view.length; i++) {\n      n -= view[i].size;\n      if (n < 0) return i;\n    }\n  }\n\n  function viewCuttingPoint(cm, oldN, newN, dir) {\n    var index = findViewIndex(cm, oldN), diff, view = cm.display.view;\n    if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size)\n      return {index: index, lineN: newN};\n    for (var i = 0, n = cm.display.viewFrom; i < index; i++)\n      n += view[i].size;\n    if (n != oldN) {\n      if (dir > 0) {\n        if (index == view.length - 1) return null;\n        diff = (n + view[index].size) - oldN;\n        index++;\n      } else {\n        diff = n - oldN;\n      }\n      oldN += diff; newN += diff;\n    }\n    while (visualLineNo(cm.doc, newN) != newN) {\n      if (index == (dir < 0 ? 0 : view.length - 1)) return null;\n      newN += dir * view[index - (dir < 0 ? 1 : 0)].size;\n      index += dir;\n    }\n    return {index: index, lineN: newN};\n  }\n\n  // Force the view to cover a given range, adding empty view element\n  // or clipping off existing ones as needed.\n  function adjustView(cm, from, to) {\n    var display = cm.display, view = display.view;\n    if (view.length == 0 || from >= display.viewTo || to <= display.viewFrom) {\n      display.view = buildViewArray(cm, from, to);\n      display.viewFrom = from;\n    } else {\n      if (display.viewFrom > from)\n        display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view);\n      else if (display.viewFrom < from)\n        display.view = display.view.slice(findViewIndex(cm, from));\n      display.viewFrom = from;\n      if (display.viewTo < to)\n        display.view = display.view.concat(buildViewArray(cm, display.viewTo, to));\n      else if (display.viewTo > to)\n        display.view = display.view.slice(0, findViewIndex(cm, to));\n    }\n    display.viewTo = to;\n  }\n\n  // Count the number of lines in the view whose DOM representation is\n  // out of date (or nonexistent).\n  function countDirtyView(cm) {\n    var view = cm.display.view, dirty = 0;\n    for (var i = 0; i < view.length; i++) {\n      var lineView = view[i];\n      if (!lineView.hidden && (!lineView.node || lineView.changes)) ++dirty;\n    }\n    return dirty;\n  }\n\n  // INPUT HANDLING\n\n  // Poll for input changes, using the normal rate of polling. This\n  // runs as long as the editor is focused.\n  function slowPoll(cm) {\n    if (cm.display.pollingFast) return;\n    cm.display.poll.set(cm.options.pollInterval, function() {\n      readInput(cm);\n      if (cm.state.focused) slowPoll(cm);\n    });\n  }\n\n  // When an event has just come in that is likely to add or change\n  // something in the input textarea, we poll faster, to ensure that\n  // the change appears on the screen quickly.\n  function fastPoll(cm) {\n    var missed = false;\n    cm.display.pollingFast = true;\n    function p() {\n      var changed = readInput(cm);\n      if (!changed && !missed) {missed = true; cm.display.poll.set(60, p);}\n      else {cm.display.pollingFast = false; slowPoll(cm);}\n    }\n    cm.display.poll.set(20, p);\n  }\n\n  // This will be set to an array of strings when copying, so that,\n  // when pasting, we know what kind of selections the copied text\n  // was made out of.\n  var lastCopied = null;\n\n  // Read input from the textarea, and update the document to match.\n  // When something is selected, it is present in the textarea, and\n  // selected (unless it is huge, in which case a placeholder is\n  // used). When nothing is selected, the cursor sits after previously\n  // seen text (can be empty), which is stored in prevInput (we must\n  // not reset the textarea when typing, because that breaks IME).\n  function readInput(cm) {\n    var input = cm.display.input, prevInput = cm.display.prevInput, doc = cm.doc;\n    // Since this is called a *lot*, try to bail out as cheaply as\n    // possible when it is clear that nothing happened. hasSelection\n    // will be the case when there is a lot of text in the textarea,\n    // in which case reading its value would be expensive.\n    if (!cm.state.focused || (hasSelection(input) && !prevInput) || isReadOnly(cm) || cm.options.disableInput)\n      return false;\n    // See paste handler for more on the fakedLastChar kludge\n    if (cm.state.pasteIncoming && cm.state.fakedLastChar) {\n      input.value = input.value.substring(0, input.value.length - 1);\n      cm.state.fakedLastChar = false;\n    }\n    var text = input.value;\n    // If nothing changed, bail.\n    if (text == prevInput && !cm.somethingSelected()) return false;\n    // Work around nonsensical selection resetting in IE9/10, and\n    // inexplicable appearance of private area unicode characters on\n    // some key combos in Mac (#2689).\n    if (ie && ie_version >= 9 && cm.display.inputHasSelection === text ||\n        mac && /[\\uf700-\\uf7ff]/.test(text)) {\n      resetInput(cm);\n      return false;\n    }\n\n    var withOp = !cm.curOp;\n    if (withOp) startOperation(cm);\n    cm.display.shift = false;\n\n    if (text.charCodeAt(0) == 0x200b && doc.sel == cm.display.selForContextMenu && !prevInput)\n      prevInput = \"\\u200b\";\n    // Find the part of the input that is actually new\n    var same = 0, l = Math.min(prevInput.length, text.length);\n    while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same)) ++same;\n    var inserted = text.slice(same), textLines = splitLines(inserted);\n\n    // When pasing N lines into N selections, insert one line per selection\n    var multiPaste = null;\n    if (cm.state.pasteIncoming && doc.sel.ranges.length > 1) {\n      if (lastCopied && lastCopied.join(\"\\n\") == inserted)\n        multiPaste = doc.sel.ranges.length % lastCopied.length == 0 && map(lastCopied, splitLines);\n      else if (textLines.length == doc.sel.ranges.length)\n        multiPaste = map(textLines, function(l) { return [l]; });\n    }\n\n    // Normal behavior is to insert the new text into every selection\n    for (var i = doc.sel.ranges.length - 1; i >= 0; i--) {\n      var range = doc.sel.ranges[i];\n      var from = range.from(), to = range.to();\n      // Handle deletion\n      if (same < prevInput.length)\n        from = Pos(from.line, from.ch - (prevInput.length - same));\n      // Handle overwrite\n      else if (cm.state.overwrite && range.empty() && !cm.state.pasteIncoming)\n        to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + lst(textLines).length));\n      var updateInput = cm.curOp.updateInput;\n      var changeEvent = {from: from, to: to, text: multiPaste ? multiPaste[i % multiPaste.length] : textLines,\n                         origin: cm.state.pasteIncoming ? \"paste\" : cm.state.cutIncoming ? \"cut\" : \"+input\"};\n      makeChange(cm.doc, changeEvent);\n      signalLater(cm, \"inputRead\", cm, changeEvent);\n      // When an 'electric' character is inserted, immediately trigger a reindent\n      if (inserted && !cm.state.pasteIncoming && cm.options.electricChars &&\n          cm.options.smartIndent && range.head.ch < 100 &&\n          (!i || doc.sel.ranges[i - 1].head.line != range.head.line)) {\n        var mode = cm.getModeAt(range.head);\n        var end = changeEnd(changeEvent);\n        if (mode.electricChars) {\n          for (var j = 0; j < mode.electricChars.length; j++)\n            if (inserted.indexOf(mode.electricChars.charAt(j)) > -1) {\n              indentLine(cm, end.line, \"smart\");\n              break;\n            }\n        } else if (mode.electricInput) {\n          if (mode.electricInput.test(getLine(doc, end.line).text.slice(0, end.ch)))\n            indentLine(cm, end.line, \"smart\");\n        }\n      }\n    }\n    ensureCursorVisible(cm);\n    cm.curOp.updateInput = updateInput;\n    cm.curOp.typing = true;\n\n    // Don't leave long text in the textarea, since it makes further polling slow\n    if (text.length > 1000 || text.indexOf(\"\\n\") > -1) input.value = cm.display.prevInput = \"\";\n    else cm.display.prevInput = text;\n    if (withOp) endOperation(cm);\n    cm.state.pasteIncoming = cm.state.cutIncoming = false;\n    return true;\n  }\n\n  // Reset the input to correspond to the selection (or to be empty,\n  // when not typing and nothing is selected)\n  function resetInput(cm, typing) {\n    var minimal, selected, doc = cm.doc;\n    if (cm.somethingSelected()) {\n      cm.display.prevInput = \"\";\n      var range = doc.sel.primary();\n      minimal = hasCopyEvent &&\n        (range.to().line - range.from().line > 100 || (selected = cm.getSelection()).length > 1000);\n      var content = minimal ? \"-\" : selected || cm.getSelection();\n      cm.display.input.value = content;\n      if (cm.state.focused) selectInput(cm.display.input);\n      if (ie && ie_version >= 9) cm.display.inputHasSelection = content;\n    } else if (!typing) {\n      cm.display.prevInput = cm.display.input.value = \"\";\n      if (ie && ie_version >= 9) cm.display.inputHasSelection = null;\n    }\n    cm.display.inaccurateSelection = minimal;\n  }\n\n  function focusInput(cm) {\n    if (cm.options.readOnly != \"nocursor\" && (!mobile || activeElt() != cm.display.input))\n      cm.display.input.focus();\n  }\n\n  function ensureFocus(cm) {\n    if (!cm.state.focused) { focusInput(cm); onFocus(cm); }\n  }\n\n  function isReadOnly(cm) {\n    return cm.options.readOnly || cm.doc.cantEdit;\n  }\n\n  // EVENT HANDLERS\n\n  // Attach the necessary event handlers when initializing the editor\n  function registerEventHandlers(cm) {\n    var d = cm.display;\n    on(d.scroller, \"mousedown\", operation(cm, onMouseDown));\n    // Older IE's will not fire a second mousedown for a double click\n    if (ie && ie_version < 11)\n      on(d.scroller, \"dblclick\", operation(cm, function(e) {\n        if (signalDOMEvent(cm, e)) return;\n        var pos = posFromMouse(cm, e);\n        if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) return;\n        e_preventDefault(e);\n        var word = cm.findWordAt(pos);\n        extendSelection(cm.doc, word.anchor, word.head);\n      }));\n    else\n      on(d.scroller, \"dblclick\", function(e) { signalDOMEvent(cm, e) || e_preventDefault(e); });\n    // Prevent normal selection in the editor (we handle our own)\n    on(d.lineSpace, \"selectstart\", function(e) {\n      if (!eventInWidget(d, e)) e_preventDefault(e);\n    });\n    // Some browsers fire contextmenu *after* opening the menu, at\n    // which point we can't mess with it anymore. Context menu is\n    // handled in onMouseDown for these browsers.\n    if (!captureRightClick) on(d.scroller, \"contextmenu\", function(e) {onContextMenu(cm, e);});\n\n    // Sync scrolling between fake scrollbars and real scrollable\n    // area, ensure viewport is updated when scrolling.\n    on(d.scroller, \"scroll\", function() {\n      if (d.scroller.clientHeight) {\n        setScrollTop(cm, d.scroller.scrollTop);\n        setScrollLeft(cm, d.scroller.scrollLeft, true);\n        signal(cm, \"scroll\", cm);\n      }\n    });\n    on(d.scrollbarV, \"scroll\", function() {\n      if (d.scroller.clientHeight) setScrollTop(cm, d.scrollbarV.scrollTop);\n    });\n    on(d.scrollbarH, \"scroll\", function() {\n      if (d.scroller.clientHeight) setScrollLeft(cm, d.scrollbarH.scrollLeft);\n    });\n\n    // Listen to wheel events in order to try and update the viewport on time.\n    on(d.scroller, \"mousewheel\", function(e){onScrollWheel(cm, e);});\n    on(d.scroller, \"DOMMouseScroll\", function(e){onScrollWheel(cm, e);});\n\n    // Prevent clicks in the scrollbars from killing focus\n    function reFocus() { if (cm.state.focused) setTimeout(bind(focusInput, cm), 0); }\n    on(d.scrollbarH, \"mousedown\", reFocus);\n    on(d.scrollbarV, \"mousedown\", reFocus);\n    // Prevent wrapper from ever scrolling\n    on(d.wrapper, \"scroll\", function() { d.wrapper.scrollTop = d.wrapper.scrollLeft = 0; });\n\n    on(d.input, \"keyup\", function(e) { onKeyUp.call(cm, e); });\n    on(d.input, \"input\", function() {\n      if (ie && ie_version >= 9 && cm.display.inputHasSelection) cm.display.inputHasSelection = null;\n      fastPoll(cm);\n    });\n    on(d.input, \"keydown\", operation(cm, onKeyDown));\n    on(d.input, \"keypress\", operation(cm, onKeyPress));\n    on(d.input, \"focus\", bind(onFocus, cm));\n    on(d.input, \"blur\", bind(onBlur, cm));\n\n    function drag_(e) {\n      if (!signalDOMEvent(cm, e)) e_stop(e);\n    }\n    if (cm.options.dragDrop) {\n      on(d.scroller, \"dragstart\", function(e){onDragStart(cm, e);});\n      on(d.scroller, \"dragenter\", drag_);\n      on(d.scroller, \"dragover\", drag_);\n      on(d.scroller, \"drop\", operation(cm, onDrop));\n    }\n    on(d.scroller, \"paste\", function(e) {\n      if (eventInWidget(d, e)) return;\n      cm.state.pasteIncoming = true;\n      focusInput(cm);\n      fastPoll(cm);\n    });\n    on(d.input, \"paste\", function() {\n      // Workaround for webkit bug https://bugs.webkit.org/show_bug.cgi?id=90206\n      // Add a char to the end of textarea before paste occur so that\n      // selection doesn't span to the end of textarea.\n      if (webkit && !cm.state.fakedLastChar && !(new Date - cm.state.lastMiddleDown < 200)) {\n        var start = d.input.selectionStart, end = d.input.selectionEnd;\n        d.input.value += \"$\";\n        // The selection end needs to be set before the start, otherwise there\n        // can be an intermediate non-empty selection between the two, which\n        // can override the middle-click paste buffer on linux and cause the\n        // wrong thing to get pasted.\n        d.input.selectionEnd = end;\n        d.input.selectionStart = start;\n        cm.state.fakedLastChar = true;\n      }\n      cm.state.pasteIncoming = true;\n      fastPoll(cm);\n    });\n\n    function prepareCopyCut(e) {\n      if (cm.somethingSelected()) {\n        lastCopied = cm.getSelections();\n        if (d.inaccurateSelection) {\n          d.prevInput = \"\";\n          d.inaccurateSelection = false;\n          d.input.value = lastCopied.join(\"\\n\");\n          selectInput(d.input);\n        }\n      } else {\n        var text = [], ranges = [];\n        for (var i = 0; i < cm.doc.sel.ranges.length; i++) {\n          var line = cm.doc.sel.ranges[i].head.line;\n          var lineRange = {anchor: Pos(line, 0), head: Pos(line + 1, 0)};\n          ranges.push(lineRange);\n          text.push(cm.getRange(lineRange.anchor, lineRange.head));\n        }\n        if (e.type == \"cut\") {\n          cm.setSelections(ranges, null, sel_dontScroll);\n        } else {\n          d.prevInput = \"\";\n          d.input.value = text.join(\"\\n\");\n          selectInput(d.input);\n        }\n        lastCopied = text;\n      }\n      if (e.type == \"cut\") cm.state.cutIncoming = true;\n    }\n    on(d.input, \"cut\", prepareCopyCut);\n    on(d.input, \"copy\", prepareCopyCut);\n\n    // Needed to handle Tab key in KHTML\n    if (khtml) on(d.sizer, \"mouseup\", function() {\n      if (activeElt() == d.input) d.input.blur();\n      focusInput(cm);\n    });\n  }\n\n  // Called when the window resizes\n  function onResize(cm) {\n    // Might be a text scaling operation, clear size caches.\n    var d = cm.display;\n    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;\n    cm.setSize();\n  }\n\n  // MOUSE EVENTS\n\n  // Return true when the given mouse event happened in a widget\n  function eventInWidget(display, e) {\n    for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {\n      if (!n || n.ignoreEvents || n.parentNode == display.sizer && n != display.mover) return true;\n    }\n  }\n\n  // Given a mouse event, find the corresponding position. If liberal\n  // is false, it checks whether a gutter or scrollbar was clicked,\n  // and returns null if it was. forRect is used by rectangular\n  // selections, and tries to estimate a character position even for\n  // coordinates beyond the right of the text.\n  function posFromMouse(cm, e, liberal, forRect) {\n    var display = cm.display;\n    if (!liberal) {\n      var target = e_target(e);\n      if (target == display.scrollbarH || target == display.scrollbarV ||\n          target == display.scrollbarFiller || target == display.gutterFiller) return null;\n    }\n    var x, y, space = display.lineSpace.getBoundingClientRect();\n    // Fails unpredictably on IE[67] when mouse is dragged around quickly.\n    try { x = e.clientX - space.left; y = e.clientY - space.top; }\n    catch (e) { return null; }\n    var coords = coordsChar(cm, x, y), line;\n    if (forRect && coords.xRel == 1 && (line = getLine(cm.doc, coords.line).text).length == coords.ch) {\n      var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length;\n      coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff));\n    }\n    return coords;\n  }\n\n  // A mouse down can be a single click, double click, triple click,\n  // start of selection drag, start of text drag, new cursor\n  // (ctrl-click), rectangle drag (alt-drag), or xwin\n  // middle-click-paste. Or it might be a click on something we should\n  // not interfere with, such as a scrollbar or widget.\n  function onMouseDown(e) {\n    if (signalDOMEvent(this, e)) return;\n    var cm = this, display = cm.display;\n    display.shift = e.shiftKey;\n\n    if (eventInWidget(display, e)) {\n      if (!webkit) {\n        // Briefly turn off draggability, to allow widgets to do\n        // normal dragging things.\n        display.scroller.draggable = false;\n        setTimeout(function(){display.scroller.draggable = true;}, 100);\n      }\n      return;\n    }\n    if (clickInGutter(cm, e)) return;\n    var start = posFromMouse(cm, e);\n    window.focus();\n\n    switch (e_button(e)) {\n    case 1:\n      if (start)\n        leftButtonDown(cm, e, start);\n      else if (e_target(e) == display.scroller)\n        e_preventDefault(e);\n      break;\n    case 2:\n      if (webkit) cm.state.lastMiddleDown = +new Date;\n      if (start) extendSelection(cm.doc, start);\n      setTimeout(bind(focusInput, cm), 20);\n      e_preventDefault(e);\n      break;\n    case 3:\n      if (captureRightClick) onContextMenu(cm, e);\n      break;\n    }\n  }\n\n  var lastClick, lastDoubleClick;\n  function leftButtonDown(cm, e, start) {\n    setTimeout(bind(ensureFocus, cm), 0);\n\n    var now = +new Date, type;\n    if (lastDoubleClick && lastDoubleClick.time > now - 400 && cmp(lastDoubleClick.pos, start) == 0) {\n      type = \"triple\";\n    } else if (lastClick && lastClick.time > now - 400 && cmp(lastClick.pos, start) == 0) {\n      type = \"double\";\n      lastDoubleClick = {time: now, pos: start};\n    } else {\n      type = \"single\";\n      lastClick = {time: now, pos: start};\n    }\n\n    var sel = cm.doc.sel, modifier = mac ? e.metaKey : e.ctrlKey;\n    if (cm.options.dragDrop && dragAndDrop && !isReadOnly(cm) &&\n        type == \"single\" && sel.contains(start) > -1 && sel.somethingSelected())\n      leftButtonStartDrag(cm, e, start, modifier);\n    else\n      leftButtonSelect(cm, e, start, type, modifier);\n  }\n\n  // Start a text drag. When it ends, see if any dragging actually\n  // happen, and treat as a click if it didn't.\n  function leftButtonStartDrag(cm, e, start, modifier) {\n    var display = cm.display;\n    var dragEnd = operation(cm, function(e2) {\n      if (webkit) display.scroller.draggable = false;\n      cm.state.draggingText = false;\n      off(document, \"mouseup\", dragEnd);\n      off(display.scroller, \"drop\", dragEnd);\n      if (Math.abs(e.clientX - e2.clientX) + Math.abs(e.clientY - e2.clientY) < 10) {\n        e_preventDefault(e2);\n        if (!modifier)\n          extendSelection(cm.doc, start);\n        focusInput(cm);\n        // Work around unexplainable focus problem in IE9 (#2127)\n        if (ie && ie_version == 9)\n          setTimeout(function() {document.body.focus(); focusInput(cm);}, 20);\n      }\n    });\n    // Let the drag handler handle this.\n    if (webkit) display.scroller.draggable = true;\n    cm.state.draggingText = dragEnd;\n    // IE's approach to draggable\n    if (display.scroller.dragDrop) display.scroller.dragDrop();\n    on(document, \"mouseup\", dragEnd);\n    on(display.scroller, \"drop\", dragEnd);\n  }\n\n  // Normal selection, as opposed to text dragging.\n  function leftButtonSelect(cm, e, start, type, addNew) {\n    var display = cm.display, doc = cm.doc;\n    e_preventDefault(e);\n\n    var ourRange, ourIndex, startSel = doc.sel;\n    if (addNew && !e.shiftKey) {\n      ourIndex = doc.sel.contains(start);\n      if (ourIndex > -1)\n        ourRange = doc.sel.ranges[ourIndex];\n      else\n        ourRange = new Range(start, start);\n    } else {\n      ourRange = doc.sel.primary();\n    }\n\n    if (e.altKey) {\n      type = \"rect\";\n      if (!addNew) ourRange = new Range(start, start);\n      start = posFromMouse(cm, e, true, true);\n      ourIndex = -1;\n    } else if (type == \"double\") {\n      var word = cm.findWordAt(start);\n      if (cm.display.shift || doc.extend)\n        ourRange = extendRange(doc, ourRange, word.anchor, word.head);\n      else\n        ourRange = word;\n    } else if (type == \"triple\") {\n      var line = new Range(Pos(start.line, 0), clipPos(doc, Pos(start.line + 1, 0)));\n      if (cm.display.shift || doc.extend)\n        ourRange = extendRange(doc, ourRange, line.anchor, line.head);\n      else\n        ourRange = line;\n    } else {\n      ourRange = extendRange(doc, ourRange, start);\n    }\n\n    if (!addNew) {\n      ourIndex = 0;\n      setSelection(doc, new Selection([ourRange], 0), sel_mouse);\n      startSel = doc.sel;\n    } else if (ourIndex > -1) {\n      replaceOneSelection(doc, ourIndex, ourRange, sel_mouse);\n    } else {\n      ourIndex = doc.sel.ranges.length;\n      setSelection(doc, normalizeSelection(doc.sel.ranges.concat([ourRange]), ourIndex),\n                   {scroll: false, origin: \"*mouse\"});\n    }\n\n    var lastPos = start;\n    function extendTo(pos) {\n      if (cmp(lastPos, pos) == 0) return;\n      lastPos = pos;\n\n      if (type == \"rect\") {\n        var ranges = [], tabSize = cm.options.tabSize;\n        var startCol = countColumn(getLine(doc, start.line).text, start.ch, tabSize);\n        var posCol = countColumn(getLine(doc, pos.line).text, pos.ch, tabSize);\n        var left = Math.min(startCol, posCol), right = Math.max(startCol, posCol);\n        for (var line = Math.min(start.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start.line, pos.line));\n             line <= end; line++) {\n          var text = getLine(doc, line).text, leftPos = findColumn(text, left, tabSize);\n          if (left == right)\n            ranges.push(new Range(Pos(line, leftPos), Pos(line, leftPos)));\n          else if (text.length > leftPos)\n            ranges.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right, tabSize))));\n        }\n        if (!ranges.length) ranges.push(new Range(start, start));\n        setSelection(doc, normalizeSelection(startSel.ranges.slice(0, ourIndex).concat(ranges), ourIndex),\n                     {origin: \"*mouse\", scroll: false});\n        cm.scrollIntoView(pos);\n      } else {\n        var oldRange = ourRange;\n        var anchor = oldRange.anchor, head = pos;\n        if (type != \"single\") {\n          if (type == \"double\")\n            var range = cm.findWordAt(pos);\n          else\n            var range = new Range(Pos(pos.line, 0), clipPos(doc, Pos(pos.line + 1, 0)));\n          if (cmp(range.anchor, anchor) > 0) {\n            head = range.head;\n            anchor = minPos(oldRange.from(), range.anchor);\n          } else {\n            head = range.anchor;\n            anchor = maxPos(oldRange.to(), range.head);\n          }\n        }\n        var ranges = startSel.ranges.slice(0);\n        ranges[ourIndex] = new Range(clipPos(doc, anchor), head);\n        setSelection(doc, normalizeSelection(ranges, ourIndex), sel_mouse);\n      }\n    }\n\n    var editorSize = display.wrapper.getBoundingClientRect();\n    // Used to ensure timeout re-tries don't fire when another extend\n    // happened in the meantime (clearTimeout isn't reliable -- at\n    // least on Chrome, the timeouts still happen even when cleared,\n    // if the clear happens after their scheduled firing time).\n    var counter = 0;\n\n    function extend(e) {\n      var curCount = ++counter;\n      var cur = posFromMouse(cm, e, true, type == \"rect\");\n      if (!cur) return;\n      if (cmp(cur, lastPos) != 0) {\n        ensureFocus(cm);\n        extendTo(cur);\n        var visible = visibleLines(display, doc);\n        if (cur.line >= visible.to || cur.line < visible.from)\n          setTimeout(operation(cm, function(){if (counter == curCount) extend(e);}), 150);\n      } else {\n        var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;\n        if (outside) setTimeout(operation(cm, function() {\n          if (counter != curCount) return;\n          display.scroller.scrollTop += outside;\n          extend(e);\n        }), 50);\n      }\n    }\n\n    function done(e) {\n      counter = Infinity;\n      e_preventDefault(e);\n      focusInput(cm);\n      off(document, \"mousemove\", move);\n      off(document, \"mouseup\", up);\n      doc.history.lastSelOrigin = null;\n    }\n\n    var move = operation(cm, function(e) {\n      if (!e_button(e)) done(e);\n      else extend(e);\n    });\n    var up = operation(cm, done);\n    on(document, \"mousemove\", move);\n    on(document, \"mouseup\", up);\n  }\n\n  // Determines whether an event happened in the gutter, and fires the\n  // handlers for the corresponding event.\n  function gutterEvent(cm, e, type, prevent, signalfn) {\n    try { var mX = e.clientX, mY = e.clientY; }\n    catch(e) { return false; }\n    if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right)) return false;\n    if (prevent) e_preventDefault(e);\n\n    var display = cm.display;\n    var lineBox = display.lineDiv.getBoundingClientRect();\n\n    if (mY > lineBox.bottom || !hasHandler(cm, type)) return e_defaultPrevented(e);\n    mY -= lineBox.top - display.viewOffset;\n\n    for (var i = 0; i < cm.options.gutters.length; ++i) {\n      var g = display.gutters.childNodes[i];\n      if (g && g.getBoundingClientRect().right >= mX) {\n        var line = lineAtHeight(cm.doc, mY);\n        var gutter = cm.options.gutters[i];\n        signalfn(cm, type, cm, line, gutter, e);\n        return e_defaultPrevented(e);\n      }\n    }\n  }\n\n  function clickInGutter(cm, e) {\n    return gutterEvent(cm, e, \"gutterClick\", true, signalLater);\n  }\n\n  // Kludge to work around strange IE behavior where it'll sometimes\n  // re-fire a series of drag-related events right after the drop (#1551)\n  var lastDrop = 0;\n\n  function onDrop(e) {\n    var cm = this;\n    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e))\n      return;\n    e_preventDefault(e);\n    if (ie) lastDrop = +new Date;\n    var pos = posFromMouse(cm, e, true), files = e.dataTransfer.files;\n    if (!pos || isReadOnly(cm)) return;\n    // Might be a file drop, in which case we simply extract the text\n    // and insert it.\n    if (files && files.length && window.FileReader && window.File) {\n      var n = files.length, text = Array(n), read = 0;\n      var loadFile = function(file, i) {\n        var reader = new FileReader;\n        reader.onload = operation(cm, function() {\n          text[i] = reader.result;\n          if (++read == n) {\n            pos = clipPos(cm.doc, pos);\n            var change = {from: pos, to: pos, text: splitLines(text.join(\"\\n\")), origin: \"paste\"};\n            makeChange(cm.doc, change);\n            setSelectionReplaceHistory(cm.doc, simpleSelection(pos, changeEnd(change)));\n          }\n        });\n        reader.readAsText(file);\n      };\n      for (var i = 0; i < n; ++i) loadFile(files[i], i);\n    } else { // Normal drop\n      // Don't do a replace if the drop happened inside of the selected text.\n      if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) {\n        cm.state.draggingText(e);\n        // Ensure the editor is re-focused\n        setTimeout(bind(focusInput, cm), 20);\n        return;\n      }\n      try {\n        var text = e.dataTransfer.getData(\"Text\");\n        if (text) {\n          if (cm.state.draggingText && !(mac ? e.metaKey : e.ctrlKey))\n            var selected = cm.listSelections();\n          setSelectionNoUndo(cm.doc, simpleSelection(pos, pos));\n          if (selected) for (var i = 0; i < selected.length; ++i)\n            replaceRange(cm.doc, \"\", selected[i].anchor, selected[i].head, \"drag\");\n          cm.replaceSelection(text, \"around\", \"paste\");\n          focusInput(cm);\n        }\n      }\n      catch(e){}\n    }\n  }\n\n  function onDragStart(cm, e) {\n    if (ie && (!cm.state.draggingText || +new Date - lastDrop < 100)) { e_stop(e); return; }\n    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) return;\n\n    e.dataTransfer.setData(\"Text\", cm.getSelection());\n\n    // Use dummy image instead of default browsers image.\n    // Recent Safari (~6.0.2) have a tendency to segfault when this happens, so we don't do it there.\n    if (e.dataTransfer.setDragImage && !safari) {\n      var img = elt(\"img\", null, null, \"position: fixed; left: 0; top: 0;\");\n      img.src = \"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\";\n      if (presto) {\n        img.width = img.height = 1;\n        cm.display.wrapper.appendChild(img);\n        // Force a relayout, or Opera won't use our image for some obscure reason\n        img._top = img.offsetTop;\n      }\n      e.dataTransfer.setDragImage(img, 0, 0);\n      if (presto) img.parentNode.removeChild(img);\n    }\n  }\n\n  // SCROLL EVENTS\n\n  // Sync the scrollable area and scrollbars, ensure the viewport\n  // covers the visible area.\n  function setScrollTop(cm, val) {\n    if (Math.abs(cm.doc.scrollTop - val) < 2) return;\n    cm.doc.scrollTop = val;\n    if (!gecko) updateDisplaySimple(cm, {top: val});\n    if (cm.display.scroller.scrollTop != val) cm.display.scroller.scrollTop = val;\n    if (cm.display.scrollbarV.scrollTop != val) cm.display.scrollbarV.scrollTop = val;\n    if (gecko) updateDisplaySimple(cm);\n    startWorker(cm, 100);\n  }\n  // Sync scroller and scrollbar, ensure the gutter elements are\n  // aligned.\n  function setScrollLeft(cm, val, isScroller) {\n    if (isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) return;\n    val = Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth);\n    cm.doc.scrollLeft = val;\n    alignHorizontally(cm);\n    if (cm.display.scroller.scrollLeft != val) cm.display.scroller.scrollLeft = val;\n    if (cm.display.scrollbarH.scrollLeft != val) cm.display.scrollbarH.scrollLeft = val;\n  }\n\n  // Since the delta values reported on mouse wheel events are\n  // unstandardized between browsers and even browser versions, and\n  // generally horribly unpredictable, this code starts by measuring\n  // the scroll effect that the first few mouse wheel events have,\n  // and, from that, detects the way it can convert deltas to pixel\n  // offsets afterwards.\n  //\n  // The reason we want to know the amount a wheel event will scroll\n  // is that it gives us a chance to update the display before the\n  // actual scrolling happens, reducing flickering.\n\n  var wheelSamples = 0, wheelPixelsPerUnit = null;\n  // Fill in a browser-detected starting value on browsers where we\n  // know one. These don't have to be accurate -- the result of them\n  // being wrong would just be a slight flicker on the first wheel\n  // scroll (if it is large enough).\n  if (ie) wheelPixelsPerUnit = -.53;\n  else if (gecko) wheelPixelsPerUnit = 15;\n  else if (chrome) wheelPixelsPerUnit = -.7;\n  else if (safari) wheelPixelsPerUnit = -1/3;\n\n  function onScrollWheel(cm, e) {\n    var dx = e.wheelDeltaX, dy = e.wheelDeltaY;\n    if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) dx = e.detail;\n    if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) dy = e.detail;\n    else if (dy == null) dy = e.wheelDelta;\n\n    var display = cm.display, scroll = display.scroller;\n    // Quit if there's nothing to scroll here\n    if (!(dx && scroll.scrollWidth > scroll.clientWidth ||\n          dy && scroll.scrollHeight > scroll.clientHeight)) return;\n\n    // Webkit browsers on OS X abort momentum scrolls when the target\n    // of the scroll event is removed from the scrollable element.\n    // This hack (see related code in patchDisplay) makes sure the\n    // element is kept around.\n    if (dy && mac && webkit) {\n      outer: for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) {\n        for (var i = 0; i < view.length; i++) {\n          if (view[i].node == cur) {\n            cm.display.currentWheelTarget = cur;\n            break outer;\n          }\n        }\n      }\n    }\n\n    // On some browsers, horizontal scrolling will cause redraws to\n    // happen before the gutter has been realigned, causing it to\n    // wriggle around in a most unseemly way. When we have an\n    // estimated pixels/delta value, we just handle horizontal\n    // scrolling entirely here. It'll be slightly off from native, but\n    // better than glitching out.\n    if (dx && !gecko && !presto && wheelPixelsPerUnit != null) {\n      if (dy)\n        setScrollTop(cm, Math.max(0, Math.min(scroll.scrollTop + dy * wheelPixelsPerUnit, scroll.scrollHeight - scroll.clientHeight)));\n      setScrollLeft(cm, Math.max(0, Math.min(scroll.scrollLeft + dx * wheelPixelsPerUnit, scroll.scrollWidth - scroll.clientWidth)));\n      e_preventDefault(e);\n      display.wheelStartX = null; // Abort measurement, if in progress\n      return;\n    }\n\n    // 'Project' the visible viewport to cover the area that is being\n    // scrolled into view (if we know enough to estimate it).\n    if (dy && wheelPixelsPerUnit != null) {\n      var pixels = dy * wheelPixelsPerUnit;\n      var top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight;\n      if (pixels < 0) top = Math.max(0, top + pixels - 50);\n      else bot = Math.min(cm.doc.height, bot + pixels + 50);\n      updateDisplaySimple(cm, {top: top, bottom: bot});\n    }\n\n    if (wheelSamples < 20) {\n      if (display.wheelStartX == null) {\n        display.wheelStartX = scroll.scrollLeft; display.wheelStartY = scroll.scrollTop;\n        display.wheelDX = dx; display.wheelDY = dy;\n        setTimeout(function() {\n          if (display.wheelStartX == null) return;\n          var movedX = scroll.scrollLeft - display.wheelStartX;\n          var movedY = scroll.scrollTop - display.wheelStartY;\n          var sample = (movedY && display.wheelDY && movedY / display.wheelDY) ||\n            (movedX && display.wheelDX && movedX / display.wheelDX);\n          display.wheelStartX = display.wheelStartY = null;\n          if (!sample) return;\n          wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);\n          ++wheelSamples;\n        }, 200);\n      } else {\n        display.wheelDX += dx; display.wheelDY += dy;\n      }\n    }\n  }\n\n  // KEY EVENTS\n\n  // Run a handler that was bound to a key.\n  function doHandleBinding(cm, bound, dropShift) {\n    if (typeof bound == \"string\") {\n      bound = commands[bound];\n      if (!bound) return false;\n    }\n    // Ensure previous input has been read, so that the handler sees a\n    // consistent view of the document\n    if (cm.display.pollingFast && readInput(cm)) cm.display.pollingFast = false;\n    var prevShift = cm.display.shift, done = false;\n    try {\n      if (isReadOnly(cm)) cm.state.suppressEdits = true;\n      if (dropShift) cm.display.shift = false;\n      done = bound(cm) != Pass;\n    } finally {\n      cm.display.shift = prevShift;\n      cm.state.suppressEdits = false;\n    }\n    return done;\n  }\n\n  // Collect the currently active keymaps.\n  function allKeyMaps(cm) {\n    var maps = cm.state.keyMaps.slice(0);\n    if (cm.options.extraKeys) maps.push(cm.options.extraKeys);\n    maps.push(cm.options.keyMap);\n    return maps;\n  }\n\n  var maybeTransition;\n  // Handle a key from the keydown event.\n  function handleKeyBinding(cm, e) {\n    // Handle automatic keymap transitions\n    var startMap = getKeyMap(cm.options.keyMap), next = startMap.auto;\n    clearTimeout(maybeTransition);\n    if (next && !isModifierKey(e)) maybeTransition = setTimeout(function() {\n      if (getKeyMap(cm.options.keyMap) == startMap) {\n        cm.options.keyMap = (next.call ? next.call(null, cm) : next);\n        keyMapChanged(cm);\n      }\n    }, 50);\n\n    var name = keyName(e, true), handled = false;\n    if (!name) return false;\n    var keymaps = allKeyMaps(cm);\n\n    if (e.shiftKey) {\n      // First try to resolve full name (including 'Shift-'). Failing\n      // that, see if there is a cursor-motion command (starting with\n      // 'go') bound to the keyname without 'Shift-'.\n      handled = lookupKey(\"Shift-\" + name, keymaps, function(b) {return doHandleBinding(cm, b, true);})\n             || lookupKey(name, keymaps, function(b) {\n                  if (typeof b == \"string\" ? /^go[A-Z]/.test(b) : b.motion)\n                    return doHandleBinding(cm, b);\n                });\n    } else {\n      handled = lookupKey(name, keymaps, function(b) { return doHandleBinding(cm, b); });\n    }\n\n    if (handled) {\n      e_preventDefault(e);\n      restartBlink(cm);\n      signalLater(cm, \"keyHandled\", cm, name, e);\n    }\n    return handled;\n  }\n\n  // Handle a key from the keypress event\n  function handleCharBinding(cm, e, ch) {\n    var handled = lookupKey(\"'\" + ch + \"'\", allKeyMaps(cm),\n                            function(b) { return doHandleBinding(cm, b, true); });\n    if (handled) {\n      e_preventDefault(e);\n      restartBlink(cm);\n      signalLater(cm, \"keyHandled\", cm, \"'\" + ch + \"'\", e);\n    }\n    return handled;\n  }\n\n  var lastStoppedKey = null;\n  function onKeyDown(e) {\n    var cm = this;\n    ensureFocus(cm);\n    if (signalDOMEvent(cm, e)) return;\n    // IE does strange things with escape.\n    if (ie && ie_version < 11 && e.keyCode == 27) e.returnValue = false;\n    var code = e.keyCode;\n    cm.display.shift = code == 16 || e.shiftKey;\n    var handled = handleKeyBinding(cm, e);\n    if (presto) {\n      lastStoppedKey = handled ? code : null;\n      // Opera has no cut event... we try to at least catch the key combo\n      if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey))\n        cm.replaceSelection(\"\", null, \"cut\");\n    }\n\n    // Turn mouse into crosshair when Alt is held on Mac.\n    if (code == 18 && !/\\bCodeMirror-crosshair\\b/.test(cm.display.lineDiv.className))\n      showCrossHair(cm);\n  }\n\n  function showCrossHair(cm) {\n    var lineDiv = cm.display.lineDiv;\n    addClass(lineDiv, \"CodeMirror-crosshair\");\n\n    function up(e) {\n      if (e.keyCode == 18 || !e.altKey) {\n        rmClass(lineDiv, \"CodeMirror-crosshair\");\n        off(document, \"keyup\", up);\n        off(document, \"mouseover\", up);\n      }\n    }\n    on(document, \"keyup\", up);\n    on(document, \"mouseover\", up);\n  }\n\n  function onKeyUp(e) {\n    if (e.keyCode == 16) this.doc.sel.shift = false;\n    signalDOMEvent(this, e);\n  }\n\n  function onKeyPress(e) {\n    var cm = this;\n    if (signalDOMEvent(cm, e) || e.ctrlKey && !e.altKey || mac && e.metaKey) return;\n    var keyCode = e.keyCode, charCode = e.charCode;\n    if (presto && keyCode == lastStoppedKey) {lastStoppedKey = null; e_preventDefault(e); return;}\n    if (((presto && (!e.which || e.which < 10)) || khtml) && handleKeyBinding(cm, e)) return;\n    var ch = String.fromCharCode(charCode == null ? keyCode : charCode);\n    if (handleCharBinding(cm, e, ch)) return;\n    if (ie && ie_version >= 9) cm.display.inputHasSelection = null;\n    fastPoll(cm);\n  }\n\n  // FOCUS/BLUR EVENTS\n\n  function onFocus(cm) {\n    if (cm.options.readOnly == \"nocursor\") return;\n    if (!cm.state.focused) {\n      signal(cm, \"focus\", cm);\n      cm.state.focused = true;\n      addClass(cm.display.wrapper, \"CodeMirror-focused\");\n      // The prevInput test prevents this from firing when a context\n      // menu is closed (since the resetInput would kill the\n      // select-all detection hack)\n      if (!cm.curOp && cm.display.selForContextMenu != cm.doc.sel) {\n        resetInput(cm);\n        if (webkit) setTimeout(bind(resetInput, cm, true), 0); // Issue #1730\n      }\n    }\n    slowPoll(cm);\n    restartBlink(cm);\n  }\n  function onBlur(cm) {\n    if (cm.state.focused) {\n      signal(cm, \"blur\", cm);\n      cm.state.focused = false;\n      rmClass(cm.display.wrapper, \"CodeMirror-focused\");\n    }\n    clearInterval(cm.display.blinker);\n    setTimeout(function() {if (!cm.state.focused) cm.display.shift = false;}, 150);\n  }\n\n  // CONTEXT MENU HANDLING\n\n  // To make the context menu work, we need to briefly unhide the\n  // textarea (making it as unobtrusive as possible) to let the\n  // right-click take effect on it.\n  function onContextMenu(cm, e) {\n    if (signalDOMEvent(cm, e, \"contextmenu\")) return;\n    var display = cm.display;\n    if (eventInWidget(display, e) || contextMenuInGutter(cm, e)) return;\n\n    var pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop;\n    if (!pos || presto) return; // Opera is difficult.\n\n    // Reset the current text selection only if the click is done outside of the selection\n    // and 'resetSelectionOnContextMenu' option is true.\n    var reset = cm.options.resetSelectionOnContextMenu;\n    if (reset && cm.doc.sel.contains(pos) == -1)\n      operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll);\n\n    var oldCSS = display.input.style.cssText;\n    display.inputDiv.style.position = \"absolute\";\n    display.input.style.cssText = \"position: fixed; width: 30px; height: 30px; top: \" + (e.clientY - 5) +\n      \"px; left: \" + (e.clientX - 5) + \"px; z-index: 1000; background: \" +\n      (ie ? \"rgba(255, 255, 255, .05)\" : \"transparent\") +\n      \"; outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);\";\n    if (webkit) var oldScrollY = window.scrollY; // Work around Chrome issue (#2712)\n    focusInput(cm);\n    if (webkit) window.scrollTo(null, oldScrollY);\n    resetInput(cm);\n    // Adds \"Select all\" to context menu in FF\n    if (!cm.somethingSelected()) display.input.value = display.prevInput = \" \";\n    display.selForContextMenu = cm.doc.sel;\n    clearTimeout(display.detectingSelectAll);\n\n    // Select-all will be greyed out if there's nothing to select, so\n    // this adds a zero-width space so that we can later check whether\n    // it got selected.\n    function prepareSelectAllHack() {\n      if (display.input.selectionStart != null) {\n        var selected = cm.somethingSelected();\n        var extval = display.input.value = \"\\u200b\" + (selected ? display.input.value : \"\");\n        display.prevInput = selected ? \"\" : \"\\u200b\";\n        display.input.selectionStart = 1; display.input.selectionEnd = extval.length;\n        // Re-set this, in case some other handler touched the\n        // selection in the meantime.\n        display.selForContextMenu = cm.doc.sel;\n      }\n    }\n    function rehide() {\n      display.inputDiv.style.position = \"relative\";\n      display.input.style.cssText = oldCSS;\n      if (ie && ie_version < 9) display.scrollbarV.scrollTop = display.scroller.scrollTop = scrollPos;\n      slowPoll(cm);\n\n      // Try to detect the user choosing select-all\n      if (display.input.selectionStart != null) {\n        if (!ie || (ie && ie_version < 9)) prepareSelectAllHack();\n        var i = 0, poll = function() {\n          if (display.selForContextMenu == cm.doc.sel && display.input.selectionStart == 0)\n            operation(cm, commands.selectAll)(cm);\n          else if (i++ < 10) display.detectingSelectAll = setTimeout(poll, 500);\n          else resetInput(cm);\n        };\n        display.detectingSelectAll = setTimeout(poll, 200);\n      }\n    }\n\n    if (ie && ie_version >= 9) prepareSelectAllHack();\n    if (captureRightClick) {\n      e_stop(e);\n      var mouseup = function() {\n        off(window, \"mouseup\", mouseup);\n        setTimeout(rehide, 20);\n      };\n      on(window, \"mouseup\", mouseup);\n    } else {\n      setTimeout(rehide, 50);\n    }\n  }\n\n  function contextMenuInGutter(cm, e) {\n    if (!hasHandler(cm, \"gutterContextMenu\")) return false;\n    return gutterEvent(cm, e, \"gutterContextMenu\", false, signal);\n  }\n\n  // UPDATING\n\n  // Compute the position of the end of a change (its 'to' property\n  // refers to the pre-change end).\n  var changeEnd = CodeMirror.changeEnd = function(change) {\n    if (!change.text) return change.to;\n    return Pos(change.from.line + change.text.length - 1,\n               lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0));\n  };\n\n  // Adjust a position to refer to the post-change position of the\n  // same text, or the end of the change if the change covers it.\n  function adjustForChange(pos, change) {\n    if (cmp(pos, change.from) < 0) return pos;\n    if (cmp(pos, change.to) <= 0) return changeEnd(change);\n\n    var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;\n    if (pos.line == change.to.line) ch += changeEnd(change).ch - change.to.ch;\n    return Pos(line, ch);\n  }\n\n  function computeSelAfterChange(doc, change) {\n    var out = [];\n    for (var i = 0; i < doc.sel.ranges.length; i++) {\n      var range = doc.sel.ranges[i];\n      out.push(new Range(adjustForChange(range.anchor, change),\n                         adjustForChange(range.head, change)));\n    }\n    return normalizeSelection(out, doc.sel.primIndex);\n  }\n\n  function offsetPos(pos, old, nw) {\n    if (pos.line == old.line)\n      return Pos(nw.line, pos.ch - old.ch + nw.ch);\n    else\n      return Pos(nw.line + (pos.line - old.line), pos.ch);\n  }\n\n  // Used by replaceSelections to allow moving the selection to the\n  // start or around the replaced test. Hint may be \"start\" or \"around\".\n  function computeReplacedSel(doc, changes, hint) {\n    var out = [];\n    var oldPrev = Pos(doc.first, 0), newPrev = oldPrev;\n    for (var i = 0; i < changes.length; i++) {\n      var change = changes[i];\n      var from = offsetPos(change.from, oldPrev, newPrev);\n      var to = offsetPos(changeEnd(change), oldPrev, newPrev);\n      oldPrev = change.to;\n      newPrev = to;\n      if (hint == \"around\") {\n        var range = doc.sel.ranges[i], inv = cmp(range.head, range.anchor) < 0;\n        out[i] = new Range(inv ? to : from, inv ? from : to);\n      } else {\n        out[i] = new Range(from, from);\n      }\n    }\n    return new Selection(out, doc.sel.primIndex);\n  }\n\n  // Allow \"beforeChange\" event handlers to influence a change\n  function filterChange(doc, change, update) {\n    var obj = {\n      canceled: false,\n      from: change.from,\n      to: change.to,\n      text: change.text,\n      origin: change.origin,\n      cancel: function() { this.canceled = true; }\n    };\n    if (update) obj.update = function(from, to, text, origin) {\n      if (from) this.from = clipPos(doc, from);\n      if (to) this.to = clipPos(doc, to);\n      if (text) this.text = text;\n      if (origin !== undefined) this.origin = origin;\n    };\n    signal(doc, \"beforeChange\", doc, obj);\n    if (doc.cm) signal(doc.cm, \"beforeChange\", doc.cm, obj);\n\n    if (obj.canceled) return null;\n    return {from: obj.from, to: obj.to, text: obj.text, origin: obj.origin};\n  }\n\n  // Apply a change to a document, and add it to the document's\n  // history, and propagating it to all linked documents.\n  function makeChange(doc, change, ignoreReadOnly) {\n    if (doc.cm) {\n      if (!doc.cm.curOp) return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly);\n      if (doc.cm.state.suppressEdits) return;\n    }\n\n    if (hasHandler(doc, \"beforeChange\") || doc.cm && hasHandler(doc.cm, \"beforeChange\")) {\n      change = filterChange(doc, change, true);\n      if (!change) return;\n    }\n\n    // Possibly split or suppress the update based on the presence\n    // of read-only spans in its range.\n    var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);\n    if (split) {\n      for (var i = split.length - 1; i >= 0; --i)\n        makeChangeInner(doc, {from: split[i].from, to: split[i].to, text: i ? [\"\"] : change.text});\n    } else {\n      makeChangeInner(doc, change);\n    }\n  }\n\n  function makeChangeInner(doc, change) {\n    if (change.text.length == 1 && change.text[0] == \"\" && cmp(change.from, change.to) == 0) return;\n    var selAfter = computeSelAfterChange(doc, change);\n    addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);\n\n    makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));\n    var rebased = [];\n\n    linkedDocs(doc, function(doc, sharedHist) {\n      if (!sharedHist && indexOf(rebased, doc.history) == -1) {\n        rebaseHist(doc.history, change);\n        rebased.push(doc.history);\n      }\n      makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change));\n    });\n  }\n\n  // Revert a change stored in a document's history.\n  function makeChangeFromHistory(doc, type, allowSelectionOnly) {\n    if (doc.cm && doc.cm.state.suppressEdits) return;\n\n    var hist = doc.history, event, selAfter = doc.sel;\n    var source = type == \"undo\" ? hist.done : hist.undone, dest = type == \"undo\" ? hist.undone : hist.done;\n\n    // Verify that there is a useable event (so that ctrl-z won't\n    // needlessly clear selection events)\n    for (var i = 0; i < source.length; i++) {\n      event = source[i];\n      if (allowSelectionOnly ? event.ranges && !event.equals(doc.sel) : !event.ranges)\n        break;\n    }\n    if (i == source.length) return;\n    hist.lastOrigin = hist.lastSelOrigin = null;\n\n    for (;;) {\n      event = source.pop();\n      if (event.ranges) {\n        pushSelectionToHistory(event, dest);\n        if (allowSelectionOnly && !event.equals(doc.sel)) {\n          setSelection(doc, event, {clearRedo: false});\n          return;\n        }\n        selAfter = event;\n      }\n      else break;\n    }\n\n    // Build up a reverse change object to add to the opposite history\n    // stack (redo when undoing, and vice versa).\n    var antiChanges = [];\n    pushSelectionToHistory(selAfter, dest);\n    dest.push({changes: antiChanges, generation: hist.generation});\n    hist.generation = event.generation || ++hist.maxGeneration;\n\n    var filter = hasHandler(doc, \"beforeChange\") || doc.cm && hasHandler(doc.cm, \"beforeChange\");\n\n    for (var i = event.changes.length - 1; i >= 0; --i) {\n      var change = event.changes[i];\n      change.origin = type;\n      if (filter && !filterChange(doc, change, false)) {\n        source.length = 0;\n        return;\n      }\n\n      antiChanges.push(historyChangeFromChange(doc, change));\n\n      var after = i ? computeSelAfterChange(doc, change) : lst(source);\n      makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));\n      if (!i && doc.cm) doc.cm.scrollIntoView({from: change.from, to: changeEnd(change)});\n      var rebased = [];\n\n      // Propagate to the linked documents\n      linkedDocs(doc, function(doc, sharedHist) {\n        if (!sharedHist && indexOf(rebased, doc.history) == -1) {\n          rebaseHist(doc.history, change);\n          rebased.push(doc.history);\n        }\n        makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change));\n      });\n    }\n  }\n\n  // Sub-views need their line numbers shifted when text is added\n  // above or below them in the parent document.\n  function shiftDoc(doc, distance) {\n    if (distance == 0) return;\n    doc.first += distance;\n    doc.sel = new Selection(map(doc.sel.ranges, function(range) {\n      return new Range(Pos(range.anchor.line + distance, range.anchor.ch),\n                       Pos(range.head.line + distance, range.head.ch));\n    }), doc.sel.primIndex);\n    if (doc.cm) {\n      regChange(doc.cm, doc.first, doc.first - distance, distance);\n      for (var d = doc.cm.display, l = d.viewFrom; l < d.viewTo; l++)\n        regLineChange(doc.cm, l, \"gutter\");\n    }\n  }\n\n  // More lower-level change function, handling only a single document\n  // (not linked ones).\n  function makeChangeSingleDoc(doc, change, selAfter, spans) {\n    if (doc.cm && !doc.cm.curOp)\n      return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans);\n\n    if (change.to.line < doc.first) {\n      shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));\n      return;\n    }\n    if (change.from.line > doc.lastLine()) return;\n\n    // Clip the change to the size of this doc\n    if (change.from.line < doc.first) {\n      var shift = change.text.length - 1 - (doc.first - change.from.line);\n      shiftDoc(doc, shift);\n      change = {from: Pos(doc.first, 0), to: Pos(change.to.line + shift, change.to.ch),\n                text: [lst(change.text)], origin: change.origin};\n    }\n    var last = doc.lastLine();\n    if (change.to.line > last) {\n      change = {from: change.from, to: Pos(last, getLine(doc, last).text.length),\n                text: [change.text[0]], origin: change.origin};\n    }\n\n    change.removed = getBetween(doc, change.from, change.to);\n\n    if (!selAfter) selAfter = computeSelAfterChange(doc, change);\n    if (doc.cm) makeChangeSingleDocInEditor(doc.cm, change, spans);\n    else updateDoc(doc, change, spans);\n    setSelectionNoUndo(doc, selAfter, sel_dontScroll);\n  }\n\n  // Handle the interaction of a change to a document with the editor\n  // that this document is part of.\n  function makeChangeSingleDocInEditor(cm, change, spans) {\n    var doc = cm.doc, display = cm.display, from = change.from, to = change.to;\n\n    var recomputeMaxLength = false, checkWidthStart = from.line;\n    if (!cm.options.lineWrapping) {\n      checkWidthStart = lineNo(visualLine(getLine(doc, from.line)));\n      doc.iter(checkWidthStart, to.line + 1, function(line) {\n        if (line == display.maxLine) {\n          recomputeMaxLength = true;\n          return true;\n        }\n      });\n    }\n\n    if (doc.sel.contains(change.from, change.to) > -1)\n      signalCursorActivity(cm);\n\n    updateDoc(doc, change, spans, estimateHeight(cm));\n\n    if (!cm.options.lineWrapping) {\n      doc.iter(checkWidthStart, from.line + change.text.length, function(line) {\n        var len = lineLength(line);\n        if (len > display.maxLineLength) {\n          display.maxLine = line;\n          display.maxLineLength = len;\n          display.maxLineChanged = true;\n          recomputeMaxLength = false;\n        }\n      });\n      if (recomputeMaxLength) cm.curOp.updateMaxLine = true;\n    }\n\n    // Adjust frontier, schedule worker\n    doc.frontier = Math.min(doc.frontier, from.line);\n    startWorker(cm, 400);\n\n    var lendiff = change.text.length - (to.line - from.line) - 1;\n    // Remember that these lines changed, for updating the display\n    if (from.line == to.line && change.text.length == 1 && !isWholeLineUpdate(cm.doc, change))\n      regLineChange(cm, from.line, \"text\");\n    else\n      regChange(cm, from.line, to.line + 1, lendiff);\n\n    var changesHandler = hasHandler(cm, \"changes\"), changeHandler = hasHandler(cm, \"change\");\n    if (changeHandler || changesHandler) {\n      var obj = {\n        from: from, to: to,\n        text: change.text,\n        removed: change.removed,\n        origin: change.origin\n      };\n      if (changeHandler) signalLater(cm, \"change\", cm, obj);\n      if (changesHandler) (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj);\n    }\n    cm.display.selForContextMenu = null;\n  }\n\n  function replaceRange(doc, code, from, to, origin) {\n    if (!to) to = from;\n    if (cmp(to, from) < 0) { var tmp = to; to = from; from = tmp; }\n    if (typeof code == \"string\") code = splitLines(code);\n    makeChange(doc, {from: from, to: to, text: code, origin: origin});\n  }\n\n  // SCROLLING THINGS INTO VIEW\n\n  // If an editor sits on the top or bottom of the window, partially\n  // scrolled out of view, this ensures that the cursor is visible.\n  function maybeScrollWindow(cm, coords) {\n    var display = cm.display, box = display.sizer.getBoundingClientRect(), doScroll = null;\n    if (coords.top + box.top < 0) doScroll = true;\n    else if (coords.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight)) doScroll = false;\n    if (doScroll != null && !phantom) {\n      var scrollNode = elt(\"div\", \"\\u200b\", null, \"position: absolute; top: \" +\n                           (coords.top - display.viewOffset - paddingTop(cm.display)) + \"px; height: \" +\n                           (coords.bottom - coords.top + scrollerCutOff) + \"px; left: \" +\n                           coords.left + \"px; width: 2px;\");\n      cm.display.lineSpace.appendChild(scrollNode);\n      scrollNode.scrollIntoView(doScroll);\n      cm.display.lineSpace.removeChild(scrollNode);\n    }\n  }\n\n  // Scroll a given position into view (immediately), verifying that\n  // it actually became visible (as line heights are accurately\n  // measured, the position of something may 'drift' during drawing).\n  function scrollPosIntoView(cm, pos, end, margin) {\n    if (margin == null) margin = 0;\n    for (var limit = 0; limit < 5; limit++) {\n      var changed = false, coords = cursorCoords(cm, pos);\n      var endCoords = !end || end == pos ? coords : cursorCoords(cm, end);\n      var scrollPos = calculateScrollPos(cm, Math.min(coords.left, endCoords.left),\n                                         Math.min(coords.top, endCoords.top) - margin,\n                                         Math.max(coords.left, endCoords.left),\n                                         Math.max(coords.bottom, endCoords.bottom) + margin);\n      var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;\n      if (scrollPos.scrollTop != null) {\n        setScrollTop(cm, scrollPos.scrollTop);\n        if (Math.abs(cm.doc.scrollTop - startTop) > 1) changed = true;\n      }\n      if (scrollPos.scrollLeft != null) {\n        setScrollLeft(cm, scrollPos.scrollLeft);\n        if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) changed = true;\n      }\n      if (!changed) return coords;\n    }\n  }\n\n  // Scroll a given set of coordinates into view (immediately).\n  function scrollIntoView(cm, x1, y1, x2, y2) {\n    var scrollPos = calculateScrollPos(cm, x1, y1, x2, y2);\n    if (scrollPos.scrollTop != null) setScrollTop(cm, scrollPos.scrollTop);\n    if (scrollPos.scrollLeft != null) setScrollLeft(cm, scrollPos.scrollLeft);\n  }\n\n  // Calculate a new scroll position needed to scroll the given\n  // rectangle into view. Returns an object with scrollTop and\n  // scrollLeft properties. When these are undefined, the\n  // vertical/horizontal position does not need to be adjusted.\n  function calculateScrollPos(cm, x1, y1, x2, y2) {\n    var display = cm.display, snapMargin = textHeight(cm.display);\n    if (y1 < 0) y1 = 0;\n    var screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop;\n    var screen = display.scroller.clientHeight - scrollerCutOff, result = {};\n    if (y2 - y1 > screen) y2 = y1 + screen;\n    var docBottom = cm.doc.height + paddingVert(display);\n    var atTop = y1 < snapMargin, atBottom = y2 > docBottom - snapMargin;\n    if (y1 < screentop) {\n      result.scrollTop = atTop ? 0 : y1;\n    } else if (y2 > screentop + screen) {\n      var newTop = Math.min(y1, (atBottom ? docBottom : y2) - screen);\n      if (newTop != screentop) result.scrollTop = newTop;\n    }\n\n    var screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft;\n    var screenw = display.scroller.clientWidth - scrollerCutOff - display.gutters.offsetWidth;\n    var tooWide = x2 - x1 > screenw;\n    if (tooWide) x2 = x1 + screenw;\n    if (x1 < 10)\n      result.scrollLeft = 0;\n    else if (x1 < screenleft)\n      result.scrollLeft = Math.max(0, x1 - (tooWide ? 0 : 10));\n    else if (x2 > screenw + screenleft - 3)\n      result.scrollLeft = x2 + (tooWide ? 0 : 10) - screenw;\n\n    return result;\n  }\n\n  // Store a relative adjustment to the scroll position in the current\n  // operation (to be applied when the operation finishes).\n  function addToScrollPos(cm, left, top) {\n    if (left != null || top != null) resolveScrollToPos(cm);\n    if (left != null)\n      cm.curOp.scrollLeft = (cm.curOp.scrollLeft == null ? cm.doc.scrollLeft : cm.curOp.scrollLeft) + left;\n    if (top != null)\n      cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top;\n  }\n\n  // Make sure that at the end of the operation the current cursor is\n  // shown.\n  function ensureCursorVisible(cm) {\n    resolveScrollToPos(cm);\n    var cur = cm.getCursor(), from = cur, to = cur;\n    if (!cm.options.lineWrapping) {\n      from = cur.ch ? Pos(cur.line, cur.ch - 1) : cur;\n      to = Pos(cur.line, cur.ch + 1);\n    }\n    cm.curOp.scrollToPos = {from: from, to: to, margin: cm.options.cursorScrollMargin, isCursor: true};\n  }\n\n  // When an operation has its scrollToPos property set, and another\n  // scroll action is applied before the end of the operation, this\n  // 'simulates' scrolling that position into view in a cheap way, so\n  // that the effect of intermediate scroll commands is not ignored.\n  function resolveScrollToPos(cm) {\n    var range = cm.curOp.scrollToPos;\n    if (range) {\n      cm.curOp.scrollToPos = null;\n      var from = estimateCoords(cm, range.from), to = estimateCoords(cm, range.to);\n      var sPos = calculateScrollPos(cm, Math.min(from.left, to.left),\n                                    Math.min(from.top, to.top) - range.margin,\n                                    Math.max(from.right, to.right),\n                                    Math.max(from.bottom, to.bottom) + range.margin);\n      cm.scrollTo(sPos.scrollLeft, sPos.scrollTop);\n    }\n  }\n\n  // API UTILITIES\n\n  // Indent the given line. The how parameter can be \"smart\",\n  // \"add\"/null, \"subtract\", or \"prev\". When aggressive is false\n  // (typically set to true for forced single-line indents), empty\n  // lines are not indented, and places where the mode returns Pass\n  // are left alone.\n  function indentLine(cm, n, how, aggressive) {\n    var doc = cm.doc, state;\n    if (how == null) how = \"add\";\n    if (how == \"smart\") {\n      // Fall back to \"prev\" when the mode doesn't have an indentation\n      // method.\n      if (!doc.mode.indent) how = \"prev\";\n      else state = getStateBefore(cm, n);\n    }\n\n    var tabSize = cm.options.tabSize;\n    var line = getLine(doc, n), curSpace = countColumn(line.text, null, tabSize);\n    if (line.stateAfter) line.stateAfter = null;\n    var curSpaceString = line.text.match(/^\\s*/)[0], indentation;\n    if (!aggressive && !/\\S/.test(line.text)) {\n      indentation = 0;\n      how = \"not\";\n    } else if (how == \"smart\") {\n      indentation = doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);\n      if (indentation == Pass || indentation > 150) {\n        if (!aggressive) return;\n        how = \"prev\";\n      }\n    }\n    if (how == \"prev\") {\n      if (n > doc.first) indentation = countColumn(getLine(doc, n-1).text, null, tabSize);\n      else indentation = 0;\n    } else if (how == \"add\") {\n      indentation = curSpace + cm.options.indentUnit;\n    } else if (how == \"subtract\") {\n      indentation = curSpace - cm.options.indentUnit;\n    } else if (typeof how == \"number\") {\n      indentation = curSpace + how;\n    }\n    indentation = Math.max(0, indentation);\n\n    var indentString = \"\", pos = 0;\n    if (cm.options.indentWithTabs)\n      for (var i = Math.floor(indentation / tabSize); i; --i) {pos += tabSize; indentString += \"\\t\";}\n    if (pos < indentation) indentString += spaceStr(indentation - pos);\n\n    if (indentString != curSpaceString) {\n      replaceRange(doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), \"+input\");\n    } else {\n      // Ensure that, if the cursor was in the whitespace at the start\n      // of the line, it is moved to the end of that space.\n      for (var i = 0; i < doc.sel.ranges.length; i++) {\n        var range = doc.sel.ranges[i];\n        if (range.head.line == n && range.head.ch < curSpaceString.length) {\n          var pos = Pos(n, curSpaceString.length);\n          replaceOneSelection(doc, i, new Range(pos, pos));\n          break;\n        }\n      }\n    }\n    line.stateAfter = null;\n  }\n\n  // Utility for applying a change to a line by handle or number,\n  // returning the number and optionally registering the line as\n  // changed.\n  function changeLine(doc, handle, changeType, op) {\n    var no = handle, line = handle;\n    if (typeof handle == \"number\") line = getLine(doc, clipLine(doc, handle));\n    else no = lineNo(handle);\n    if (no == null) return null;\n    if (op(line, no) && doc.cm) regLineChange(doc.cm, no, changeType);\n    return line;\n  }\n\n  // Helper for deleting text near the selection(s), used to implement\n  // backspace, delete, and similar functionality.\n  function deleteNearSelection(cm, compute) {\n    var ranges = cm.doc.sel.ranges, kill = [];\n    // Build up a set of ranges to kill first, merging overlapping\n    // ranges.\n    for (var i = 0; i < ranges.length; i++) {\n      var toKill = compute(ranges[i]);\n      while (kill.length && cmp(toKill.from, lst(kill).to) <= 0) {\n        var replaced = kill.pop();\n        if (cmp(replaced.from, toKill.from) < 0) {\n          toKill.from = replaced.from;\n          break;\n        }\n      }\n      kill.push(toKill);\n    }\n    // Next, remove those actual ranges.\n    runInOp(cm, function() {\n      for (var i = kill.length - 1; i >= 0; i--)\n        replaceRange(cm.doc, \"\", kill[i].from, kill[i].to, \"+delete\");\n      ensureCursorVisible(cm);\n    });\n  }\n\n  // Used for horizontal relative motion. Dir is -1 or 1 (left or\n  // right), unit can be \"char\", \"column\" (like char, but doesn't\n  // cross line boundaries), \"word\" (across next word), or \"group\" (to\n  // the start of next group of word or non-word-non-whitespace\n  // chars). The visually param controls whether, in right-to-left\n  // text, direction 1 means to move towards the next index in the\n  // string, or towards the character to the right of the current\n  // position. The resulting position will have a hitSide=true\n  // property if it reached the end of the document.\n  function findPosH(doc, pos, dir, unit, visually) {\n    var line = pos.line, ch = pos.ch, origDir = dir;\n    var lineObj = getLine(doc, line);\n    var possible = true;\n    function findNextLine() {\n      var l = line + dir;\n      if (l < doc.first || l >= doc.first + doc.size) return (possible = false);\n      line = l;\n      return lineObj = getLine(doc, l);\n    }\n    function moveOnce(boundToLine) {\n      var next = (visually ? moveVisually : moveLogically)(lineObj, ch, dir, true);\n      if (next == null) {\n        if (!boundToLine && findNextLine()) {\n          if (visually) ch = (dir < 0 ? lineRight : lineLeft)(lineObj);\n          else ch = dir < 0 ? lineObj.text.length : 0;\n        } else return (possible = false);\n      } else ch = next;\n      return true;\n    }\n\n    if (unit == \"char\") moveOnce();\n    else if (unit == \"column\") moveOnce(true);\n    else if (unit == \"word\" || unit == \"group\") {\n      var sawType = null, group = unit == \"group\";\n      var helper = doc.cm && doc.cm.getHelper(pos, \"wordChars\");\n      for (var first = true;; first = false) {\n        if (dir < 0 && !moveOnce(!first)) break;\n        var cur = lineObj.text.charAt(ch) || \"\\n\";\n        var type = isWordChar(cur, helper) ? \"w\"\n          : group && cur == \"\\n\" ? \"n\"\n          : !group || /\\s/.test(cur) ? null\n          : \"p\";\n        if (group && !first && !type) type = \"s\";\n        if (sawType && sawType != type) {\n          if (dir < 0) {dir = 1; moveOnce();}\n          break;\n        }\n\n        if (type) sawType = type;\n        if (dir > 0 && !moveOnce(!first)) break;\n      }\n    }\n    var result = skipAtomic(doc, Pos(line, ch), origDir, true);\n    if (!possible) result.hitSide = true;\n    return result;\n  }\n\n  // For relative vertical movement. Dir may be -1 or 1. Unit can be\n  // \"page\" or \"line\". The resulting position will have a hitSide=true\n  // property if it reached the end of the document.\n  function findPosV(cm, pos, dir, unit) {\n    var doc = cm.doc, x = pos.left, y;\n    if (unit == \"page\") {\n      var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);\n      y = pos.top + dir * (pageSize - (dir < 0 ? 1.5 : .5) * textHeight(cm.display));\n    } else if (unit == \"line\") {\n      y = dir > 0 ? pos.bottom + 3 : pos.top - 3;\n    }\n    for (;;) {\n      var target = coordsChar(cm, x, y);\n      if (!target.outside) break;\n      if (dir < 0 ? y <= 0 : y >= doc.height) { target.hitSide = true; break; }\n      y += dir * 5;\n    }\n    return target;\n  }\n\n  // EDITOR METHODS\n\n  // The publicly visible API. Note that methodOp(f) means\n  // 'wrap f in an operation, performed on its `this` parameter'.\n\n  // This is not the complete set of editor methods. Most of the\n  // methods defined on the Doc type are also injected into\n  // CodeMirror.prototype, for backwards compatibility and\n  // convenience.\n\n  CodeMirror.prototype = {\n    constructor: CodeMirror,\n    focus: function(){window.focus(); focusInput(this); fastPoll(this);},\n\n    setOption: function(option, value) {\n      var options = this.options, old = options[option];\n      if (options[option] == value && option != \"mode\") return;\n      options[option] = value;\n      if (optionHandlers.hasOwnProperty(option))\n        operation(this, optionHandlers[option])(this, value, old);\n    },\n\n    getOption: function(option) {return this.options[option];},\n    getDoc: function() {return this.doc;},\n\n    addKeyMap: function(map, bottom) {\n      this.state.keyMaps[bottom ? \"push\" : \"unshift\"](map);\n    },\n    removeKeyMap: function(map) {\n      var maps = this.state.keyMaps;\n      for (var i = 0; i < maps.length; ++i)\n        if (maps[i] == map || (typeof maps[i] != \"string\" && maps[i].name == map)) {\n          maps.splice(i, 1);\n          return true;\n        }\n    },\n\n    addOverlay: methodOp(function(spec, options) {\n      var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);\n      if (mode.startState) throw new Error(\"Overlays may not be stateful.\");\n      this.state.overlays.push({mode: mode, modeSpec: spec, opaque: options && options.opaque});\n      this.state.modeGen++;\n      regChange(this);\n    }),\n    removeOverlay: methodOp(function(spec) {\n      var overlays = this.state.overlays;\n      for (var i = 0; i < overlays.length; ++i) {\n        var cur = overlays[i].modeSpec;\n        if (cur == spec || typeof spec == \"string\" && cur.name == spec) {\n          overlays.splice(i, 1);\n          this.state.modeGen++;\n          regChange(this);\n          return;\n        }\n      }\n    }),\n\n    indentLine: methodOp(function(n, dir, aggressive) {\n      if (typeof dir != \"string\" && typeof dir != \"number\") {\n        if (dir == null) dir = this.options.smartIndent ? \"smart\" : \"prev\";\n        else dir = dir ? \"add\" : \"subtract\";\n      }\n      if (isLine(this.doc, n)) indentLine(this, n, dir, aggressive);\n    }),\n    indentSelection: methodOp(function(how) {\n      var ranges = this.doc.sel.ranges, end = -1;\n      for (var i = 0; i < ranges.length; i++) {\n        var range = ranges[i];\n        if (!range.empty()) {\n          var from = range.from(), to = range.to();\n          var start = Math.max(end, from.line);\n          end = Math.min(this.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;\n          for (var j = start; j < end; ++j)\n            indentLine(this, j, how);\n          var newRanges = this.doc.sel.ranges;\n          if (from.ch == 0 && ranges.length == newRanges.length && newRanges[i].from().ch > 0)\n            replaceOneSelection(this.doc, i, new Range(from, newRanges[i].to()), sel_dontScroll);\n        } else if (range.head.line > end) {\n          indentLine(this, range.head.line, how, true);\n          end = range.head.line;\n          if (i == this.doc.sel.primIndex) ensureCursorVisible(this);\n        }\n      }\n    }),\n\n    // Fetch the parser token for a given character. Useful for hacks\n    // that want to inspect the mode state (say, for completion).\n    getTokenAt: function(pos, precise) {\n      var doc = this.doc;\n      pos = clipPos(doc, pos);\n      var state = getStateBefore(this, pos.line, precise), mode = this.doc.mode;\n      var line = getLine(doc, pos.line);\n      var stream = new StringStream(line.text, this.options.tabSize);\n      while (stream.pos < pos.ch && !stream.eol()) {\n        stream.start = stream.pos;\n        var style = readToken(mode, stream, state);\n      }\n      return {start: stream.start,\n              end: stream.pos,\n              string: stream.current(),\n              type: style || null,\n              state: state};\n    },\n\n    getTokenTypeAt: function(pos) {\n      pos = clipPos(this.doc, pos);\n      var styles = getLineStyles(this, getLine(this.doc, pos.line));\n      var before = 0, after = (styles.length - 1) / 2, ch = pos.ch;\n      var type;\n      if (ch == 0) type = styles[2];\n      else for (;;) {\n        var mid = (before + after) >> 1;\n        if ((mid ? styles[mid * 2 - 1] : 0) >= ch) after = mid;\n        else if (styles[mid * 2 + 1] < ch) before = mid + 1;\n        else { type = styles[mid * 2 + 2]; break; }\n      }\n      var cut = type ? type.indexOf(\"cm-overlay \") : -1;\n      return cut < 0 ? type : cut == 0 ? null : type.slice(0, cut - 1);\n    },\n\n    getModeAt: function(pos) {\n      var mode = this.doc.mode;\n      if (!mode.innerMode) return mode;\n      return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode;\n    },\n\n    getHelper: function(pos, type) {\n      return this.getHelpers(pos, type)[0];\n    },\n\n    getHelpers: function(pos, type) {\n      var found = [];\n      if (!helpers.hasOwnProperty(type)) return helpers;\n      var help = helpers[type], mode = this.getModeAt(pos);\n      if (typeof mode[type] == \"string\") {\n        if (help[mode[type]]) found.push(help[mode[type]]);\n      } else if (mode[type]) {\n        for (var i = 0; i < mode[type].length; i++) {\n          var val = help[mode[type][i]];\n          if (val) found.push(val);\n        }\n      } else if (mode.helperType && help[mode.helperType]) {\n        found.push(help[mode.helperType]);\n      } else if (help[mode.name]) {\n        found.push(help[mode.name]);\n      }\n      for (var i = 0; i < help._global.length; i++) {\n        var cur = help._global[i];\n        if (cur.pred(mode, this) && indexOf(found, cur.val) == -1)\n          found.push(cur.val);\n      }\n      return found;\n    },\n\n    getStateAfter: function(line, precise) {\n      var doc = this.doc;\n      line = clipLine(doc, line == null ? doc.first + doc.size - 1: line);\n      return getStateBefore(this, line + 1, precise);\n    },\n\n    cursorCoords: function(start, mode) {\n      var pos, range = this.doc.sel.primary();\n      if (start == null) pos = range.head;\n      else if (typeof start == \"object\") pos = clipPos(this.doc, start);\n      else pos = start ? range.from() : range.to();\n      return cursorCoords(this, pos, mode || \"page\");\n    },\n\n    charCoords: function(pos, mode) {\n      return charCoords(this, clipPos(this.doc, pos), mode || \"page\");\n    },\n\n    coordsChar: function(coords, mode) {\n      coords = fromCoordSystem(this, coords, mode || \"page\");\n      return coordsChar(this, coords.left, coords.top);\n    },\n\n    lineAtHeight: function(height, mode) {\n      height = fromCoordSystem(this, {top: height, left: 0}, mode || \"page\").top;\n      return lineAtHeight(this.doc, height + this.display.viewOffset);\n    },\n    heightAtLine: function(line, mode) {\n      var end = false, last = this.doc.first + this.doc.size - 1;\n      if (line < this.doc.first) line = this.doc.first;\n      else if (line > last) { line = last; end = true; }\n      var lineObj = getLine(this.doc, line);\n      return intoCoordSystem(this, lineObj, {top: 0, left: 0}, mode || \"page\").top +\n        (end ? this.doc.height - heightAtLine(lineObj) : 0);\n    },\n\n    defaultTextHeight: function() { return textHeight(this.display); },\n    defaultCharWidth: function() { return charWidth(this.display); },\n\n    setGutterMarker: methodOp(function(line, gutterID, value) {\n      return changeLine(this.doc, line, \"gutter\", function(line) {\n        var markers = line.gutterMarkers || (line.gutterMarkers = {});\n        markers[gutterID] = value;\n        if (!value && isEmpty(markers)) line.gutterMarkers = null;\n        return true;\n      });\n    }),\n\n    clearGutter: methodOp(function(gutterID) {\n      var cm = this, doc = cm.doc, i = doc.first;\n      doc.iter(function(line) {\n        if (line.gutterMarkers && line.gutterMarkers[gutterID]) {\n          line.gutterMarkers[gutterID] = null;\n          regLineChange(cm, i, \"gutter\");\n          if (isEmpty(line.gutterMarkers)) line.gutterMarkers = null;\n        }\n        ++i;\n      });\n    }),\n\n    addLineWidget: methodOp(function(handle, node, options) {\n      return addLineWidget(this, handle, node, options);\n    }),\n\n    removeLineWidget: function(widget) { widget.clear(); },\n\n    lineInfo: function(line) {\n      if (typeof line == \"number\") {\n        if (!isLine(this.doc, line)) return null;\n        var n = line;\n        line = getLine(this.doc, line);\n        if (!line) return null;\n      } else {\n        var n = lineNo(line);\n        if (n == null) return null;\n      }\n      return {line: n, handle: line, text: line.text, gutterMarkers: line.gutterMarkers,\n              textClass: line.textClass, bgClass: line.bgClass, wrapClass: line.wrapClass,\n              widgets: line.widgets};\n    },\n\n    getViewport: function() { return {from: this.display.viewFrom, to: this.display.viewTo};},\n\n    addWidget: function(pos, node, scroll, vert, horiz) {\n      var display = this.display;\n      pos = cursorCoords(this, clipPos(this.doc, pos));\n      var top = pos.bottom, left = pos.left;\n      node.style.position = \"absolute\";\n      display.sizer.appendChild(node);\n      if (vert == \"over\") {\n        top = pos.top;\n      } else if (vert == \"above\" || vert == \"near\") {\n        var vspace = Math.max(display.wrapper.clientHeight, this.doc.height),\n        hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);\n        // Default to positioning above (if specified and possible); otherwise default to positioning below\n        if ((vert == 'above' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight)\n          top = pos.top - node.offsetHeight;\n        else if (pos.bottom + node.offsetHeight <= vspace)\n          top = pos.bottom;\n        if (left + node.offsetWidth > hspace)\n          left = hspace - node.offsetWidth;\n      }\n      node.style.top = top + \"px\";\n      node.style.left = node.style.right = \"\";\n      if (horiz == \"right\") {\n        left = display.sizer.clientWidth - node.offsetWidth;\n        node.style.right = \"0px\";\n      } else {\n        if (horiz == \"left\") left = 0;\n        else if (horiz == \"middle\") left = (display.sizer.clientWidth - node.offsetWidth) / 2;\n        node.style.left = left + \"px\";\n      }\n      if (scroll)\n        scrollIntoView(this, left, top, left + node.offsetWidth, top + node.offsetHeight);\n    },\n\n    triggerOnKeyDown: methodOp(onKeyDown),\n    triggerOnKeyPress: methodOp(onKeyPress),\n    triggerOnKeyUp: onKeyUp,\n\n    execCommand: function(cmd) {\n      if (commands.hasOwnProperty(cmd))\n        return commands[cmd](this);\n    },\n\n    findPosH: function(from, amount, unit, visually) {\n      var dir = 1;\n      if (amount < 0) { dir = -1; amount = -amount; }\n      for (var i = 0, cur = clipPos(this.doc, from); i < amount; ++i) {\n        cur = findPosH(this.doc, cur, dir, unit, visually);\n        if (cur.hitSide) break;\n      }\n      return cur;\n    },\n\n    moveH: methodOp(function(dir, unit) {\n      var cm = this;\n      cm.extendSelectionsBy(function(range) {\n        if (cm.display.shift || cm.doc.extend || range.empty())\n          return findPosH(cm.doc, range.head, dir, unit, cm.options.rtlMoveVisually);\n        else\n          return dir < 0 ? range.from() : range.to();\n      }, sel_move);\n    }),\n\n    deleteH: methodOp(function(dir, unit) {\n      var sel = this.doc.sel, doc = this.doc;\n      if (sel.somethingSelected())\n        doc.replaceSelection(\"\", null, \"+delete\");\n      else\n        deleteNearSelection(this, function(range) {\n          var other = findPosH(doc, range.head, dir, unit, false);\n          return dir < 0 ? {from: other, to: range.head} : {from: range.head, to: other};\n        });\n    }),\n\n    findPosV: function(from, amount, unit, goalColumn) {\n      var dir = 1, x = goalColumn;\n      if (amount < 0) { dir = -1; amount = -amount; }\n      for (var i = 0, cur = clipPos(this.doc, from); i < amount; ++i) {\n        var coords = cursorCoords(this, cur, \"div\");\n        if (x == null) x = coords.left;\n        else coords.left = x;\n        cur = findPosV(this, coords, dir, unit);\n        if (cur.hitSide) break;\n      }\n      return cur;\n    },\n\n    moveV: methodOp(function(dir, unit) {\n      var cm = this, doc = this.doc, goals = [];\n      var collapse = !cm.display.shift && !doc.extend && doc.sel.somethingSelected();\n      doc.extendSelectionsBy(function(range) {\n        if (collapse)\n          return dir < 0 ? range.from() : range.to();\n        var headPos = cursorCoords(cm, range.head, \"div\");\n        if (range.goalColumn != null) headPos.left = range.goalColumn;\n        goals.push(headPos.left);\n        var pos = findPosV(cm, headPos, dir, unit);\n        if (unit == \"page\" && range == doc.sel.primary())\n          addToScrollPos(cm, null, charCoords(cm, pos, \"div\").top - headPos.top);\n        return pos;\n      }, sel_move);\n      if (goals.length) for (var i = 0; i < doc.sel.ranges.length; i++)\n        doc.sel.ranges[i].goalColumn = goals[i];\n    }),\n\n    // Find the word at the given position (as returned by coordsChar).\n    findWordAt: function(pos) {\n      var doc = this.doc, line = getLine(doc, pos.line).text;\n      var start = pos.ch, end = pos.ch;\n      if (line) {\n        var helper = this.getHelper(pos, \"wordChars\");\n        if ((pos.xRel < 0 || end == line.length) && start) --start; else ++end;\n        var startChar = line.charAt(start);\n        var check = isWordChar(startChar, helper)\n          ? function(ch) { return isWordChar(ch, helper); }\n          : /\\s/.test(startChar) ? function(ch) {return /\\s/.test(ch);}\n          : function(ch) {return !/\\s/.test(ch) && !isWordChar(ch);};\n        while (start > 0 && check(line.charAt(start - 1))) --start;\n        while (end < line.length && check(line.charAt(end))) ++end;\n      }\n      return new Range(Pos(pos.line, start), Pos(pos.line, end));\n    },\n\n    toggleOverwrite: function(value) {\n      if (value != null && value == this.state.overwrite) return;\n      if (this.state.overwrite = !this.state.overwrite)\n        addClass(this.display.cursorDiv, \"CodeMirror-overwrite\");\n      else\n        rmClass(this.display.cursorDiv, \"CodeMirror-overwrite\");\n\n      signal(this, \"overwriteToggle\", this, this.state.overwrite);\n    },\n    hasFocus: function() { return activeElt() == this.display.input; },\n\n    scrollTo: methodOp(function(x, y) {\n      if (x != null || y != null) resolveScrollToPos(this);\n      if (x != null) this.curOp.scrollLeft = x;\n      if (y != null) this.curOp.scrollTop = y;\n    }),\n    getScrollInfo: function() {\n      var scroller = this.display.scroller, co = scrollerCutOff;\n      return {left: scroller.scrollLeft, top: scroller.scrollTop,\n              height: scroller.scrollHeight - co, width: scroller.scrollWidth - co,\n              clientHeight: scroller.clientHeight - co, clientWidth: scroller.clientWidth - co};\n    },\n\n    scrollIntoView: methodOp(function(range, margin) {\n      if (range == null) {\n        range = {from: this.doc.sel.primary().head, to: null};\n        if (margin == null) margin = this.options.cursorScrollMargin;\n      } else if (typeof range == \"number\") {\n        range = {from: Pos(range, 0), to: null};\n      } else if (range.from == null) {\n        range = {from: range, to: null};\n      }\n      if (!range.to) range.to = range.from;\n      range.margin = margin || 0;\n\n      if (range.from.line != null) {\n        resolveScrollToPos(this);\n        this.curOp.scrollToPos = range;\n      } else {\n        var sPos = calculateScrollPos(this, Math.min(range.from.left, range.to.left),\n                                      Math.min(range.from.top, range.to.top) - range.margin,\n                                      Math.max(range.from.right, range.to.right),\n                                      Math.max(range.from.bottom, range.to.bottom) + range.margin);\n        this.scrollTo(sPos.scrollLeft, sPos.scrollTop);\n      }\n    }),\n\n    setSize: methodOp(function(width, height) {\n      var cm = this;\n      function interpret(val) {\n        return typeof val == \"number\" || /^\\d+$/.test(String(val)) ? val + \"px\" : val;\n      }\n      if (width != null) cm.display.wrapper.style.width = interpret(width);\n      if (height != null) cm.display.wrapper.style.height = interpret(height);\n      if (cm.options.lineWrapping) clearLineMeasurementCache(this);\n      var lineNo = cm.display.viewFrom;\n      cm.doc.iter(lineNo, cm.display.viewTo, function(line) {\n        if (line.widgets) for (var i = 0; i < line.widgets.length; i++)\n          if (line.widgets[i].noHScroll) { regLineChange(cm, lineNo, \"widget\"); break; }\n        ++lineNo;\n      });\n      cm.curOp.forceUpdate = true;\n      signal(cm, \"refresh\", this);\n    }),\n\n    operation: function(f){return runInOp(this, f);},\n\n    refresh: methodOp(function() {\n      var oldHeight = this.display.cachedTextHeight;\n      regChange(this);\n      this.curOp.forceUpdate = true;\n      clearCaches(this);\n      this.scrollTo(this.doc.scrollLeft, this.doc.scrollTop);\n      updateGutterSpace(this);\n      if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) > .5)\n        estimateLineHeights(this);\n      signal(this, \"refresh\", this);\n    }),\n\n    swapDoc: methodOp(function(doc) {\n      var old = this.doc;\n      old.cm = null;\n      attachDoc(this, doc);\n      clearCaches(this);\n      resetInput(this);\n      this.scrollTo(doc.scrollLeft, doc.scrollTop);\n      this.curOp.forceScroll = true;\n      signalLater(this, \"swapDoc\", this, old);\n      return old;\n    }),\n\n    getInputField: function(){return this.display.input;},\n    getWrapperElement: function(){return this.display.wrapper;},\n    getScrollerElement: function(){return this.display.scroller;},\n    getGutterElement: function(){return this.display.gutters;}\n  };\n  eventMixin(CodeMirror);\n\n  // OPTION DEFAULTS\n\n  // The default configuration options.\n  var defaults = CodeMirror.defaults = {};\n  // Functions to run when options are changed.\n  var optionHandlers = CodeMirror.optionHandlers = {};\n\n  function option(name, deflt, handle, notOnInit) {\n    CodeMirror.defaults[name] = deflt;\n    if (handle) optionHandlers[name] =\n      notOnInit ? function(cm, val, old) {if (old != Init) handle(cm, val, old);} : handle;\n  }\n\n  // Passed to option handlers when there is no old value.\n  var Init = CodeMirror.Init = {toString: function(){return \"CodeMirror.Init\";}};\n\n  // These two are, on init, called from the constructor because they\n  // have to be initialized before the editor can start at all.\n  option(\"value\", \"\", function(cm, val) {\n    cm.setValue(val);\n  }, true);\n  option(\"mode\", null, function(cm, val) {\n    cm.doc.modeOption = val;\n    loadMode(cm);\n  }, true);\n\n  option(\"indentUnit\", 2, loadMode, true);\n  option(\"indentWithTabs\", false);\n  option(\"smartIndent\", true);\n  option(\"tabSize\", 4, function(cm) {\n    resetModeState(cm);\n    clearCaches(cm);\n    regChange(cm);\n  }, true);\n  option(\"specialChars\", /[\\t\\u0000-\\u0019\\u00ad\\u200b-\\u200f\\u2028\\u2029\\ufeff]/g, function(cm, val) {\n    cm.options.specialChars = new RegExp(val.source + (val.test(\"\\t\") ? \"\" : \"|\\t\"), \"g\");\n    cm.refresh();\n  }, true);\n  option(\"specialCharPlaceholder\", defaultSpecialCharPlaceholder, function(cm) {cm.refresh();}, true);\n  option(\"electricChars\", true);\n  option(\"rtlMoveVisually\", !windows);\n  option(\"wholeLineUpdateBefore\", true);\n\n  option(\"theme\", \"default\", function(cm) {\n    themeChanged(cm);\n    guttersChanged(cm);\n  }, true);\n  option(\"keyMap\", \"default\", keyMapChanged);\n  option(\"extraKeys\", null);\n\n  option(\"lineWrapping\", false, wrappingChanged, true);\n  option(\"gutters\", [], function(cm) {\n    setGuttersForLineNumbers(cm.options);\n    guttersChanged(cm);\n  }, true);\n  option(\"fixedGutter\", true, function(cm, val) {\n    cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + \"px\" : \"0\";\n    cm.refresh();\n  }, true);\n  option(\"coverGutterNextToScrollbar\", false, updateScrollbars, true);\n  option(\"lineNumbers\", false, function(cm) {\n    setGuttersForLineNumbers(cm.options);\n    guttersChanged(cm);\n  }, true);\n  option(\"firstLineNumber\", 1, guttersChanged, true);\n  option(\"lineNumberFormatter\", function(integer) {return integer;}, guttersChanged, true);\n  option(\"showCursorWhenSelecting\", false, updateSelection, true);\n\n  option(\"resetSelectionOnContextMenu\", true);\n\n  option(\"readOnly\", false, function(cm, val) {\n    if (val == \"nocursor\") {\n      onBlur(cm);\n      cm.display.input.blur();\n      cm.display.disabled = true;\n    } else {\n      cm.display.disabled = false;\n      if (!val) resetInput(cm);\n    }\n  });\n  option(\"disableInput\", false, function(cm, val) {if (!val) resetInput(cm);}, true);\n  option(\"dragDrop\", true);\n\n  option(\"cursorBlinkRate\", 530);\n  option(\"cursorScrollMargin\", 0);\n  option(\"cursorHeight\", 1, updateSelection, true);\n  option(\"singleCursorHeightPerLine\", true, updateSelection, true);\n  option(\"workTime\", 100);\n  option(\"workDelay\", 100);\n  option(\"flattenSpans\", true, resetModeState, true);\n  option(\"addModeClass\", false, resetModeState, true);\n  option(\"pollInterval\", 100);\n  option(\"undoDepth\", 200, function(cm, val){cm.doc.history.undoDepth = val;});\n  option(\"historyEventDelay\", 1250);\n  option(\"viewportMargin\", 10, function(cm){cm.refresh();}, true);\n  option(\"maxHighlightLength\", 10000, resetModeState, true);\n  option(\"moveInputWithCursor\", true, function(cm, val) {\n    if (!val) cm.display.inputDiv.style.top = cm.display.inputDiv.style.left = 0;\n  });\n\n  option(\"tabindex\", null, function(cm, val) {\n    cm.display.input.tabIndex = val || \"\";\n  });\n  option(\"autofocus\", null);\n\n  // MODE DEFINITION AND QUERYING\n\n  // Known modes, by name and by MIME\n  var modes = CodeMirror.modes = {}, mimeModes = CodeMirror.mimeModes = {};\n\n  // Extra arguments are stored as the mode's dependencies, which is\n  // used by (legacy) mechanisms like loadmode.js to automatically\n  // load a mode. (Preferred mechanism is the require/define calls.)\n  CodeMirror.defineMode = function(name, mode) {\n    if (!CodeMirror.defaults.mode && name != \"null\") CodeMirror.defaults.mode = name;\n    if (arguments.length > 2)\n      mode.dependencies = Array.prototype.slice.call(arguments, 2);\n    modes[name] = mode;\n  };\n\n  CodeMirror.defineMIME = function(mime, spec) {\n    mimeModes[mime] = spec;\n  };\n\n  // Given a MIME type, a {name, ...options} config object, or a name\n  // string, return a mode config object.\n  CodeMirror.resolveMode = function(spec) {\n    if (typeof spec == \"string\" && mimeModes.hasOwnProperty(spec)) {\n      spec = mimeModes[spec];\n    } else if (spec && typeof spec.name == \"string\" && mimeModes.hasOwnProperty(spec.name)) {\n      var found = mimeModes[spec.name];\n      if (typeof found == \"string\") found = {name: found};\n      spec = createObj(found, spec);\n      spec.name = found.name;\n    } else if (typeof spec == \"string\" && /^[\\w\\-]+\\/[\\w\\-]+\\+xml$/.test(spec)) {\n      return CodeMirror.resolveMode(\"application/xml\");\n    }\n    if (typeof spec == \"string\") return {name: spec};\n    else return spec || {name: \"null\"};\n  };\n\n  // Given a mode spec (anything that resolveMode accepts), find and\n  // initialize an actual mode object.\n  CodeMirror.getMode = function(options, spec) {\n    var spec = CodeMirror.resolveMode(spec);\n    var mfactory = modes[spec.name];\n    if (!mfactory) return CodeMirror.getMode(options, \"text/plain\");\n    var modeObj = mfactory(options, spec);\n    if (modeExtensions.hasOwnProperty(spec.name)) {\n      var exts = modeExtensions[spec.name];\n      for (var prop in exts) {\n        if (!exts.hasOwnProperty(prop)) continue;\n        if (modeObj.hasOwnProperty(prop)) modeObj[\"_\" + prop] = modeObj[prop];\n        modeObj[prop] = exts[prop];\n      }\n    }\n    modeObj.name = spec.name;\n    if (spec.helperType) modeObj.helperType = spec.helperType;\n    if (spec.modeProps) for (var prop in spec.modeProps)\n      modeObj[prop] = spec.modeProps[prop];\n\n    return modeObj;\n  };\n\n  // Minimal default mode.\n  CodeMirror.defineMode(\"null\", function() {\n    return {token: function(stream) {stream.skipToEnd();}};\n  });\n  CodeMirror.defineMIME(\"text/plain\", \"null\");\n\n  // This can be used to attach properties to mode objects from\n  // outside the actual mode definition.\n  var modeExtensions = CodeMirror.modeExtensions = {};\n  CodeMirror.extendMode = function(mode, properties) {\n    var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : (modeExtensions[mode] = {});\n    copyObj(properties, exts);\n  };\n\n  // EXTENSIONS\n\n  CodeMirror.defineExtension = function(name, func) {\n    CodeMirror.prototype[name] = func;\n  };\n  CodeMirror.defineDocExtension = function(name, func) {\n    Doc.prototype[name] = func;\n  };\n  CodeMirror.defineOption = option;\n\n  var initHooks = [];\n  CodeMirror.defineInitHook = function(f) {initHooks.push(f);};\n\n  var helpers = CodeMirror.helpers = {};\n  CodeMirror.registerHelper = function(type, name, value) {\n    if (!helpers.hasOwnProperty(type)) helpers[type] = CodeMirror[type] = {_global: []};\n    helpers[type][name] = value;\n  };\n  CodeMirror.registerGlobalHelper = function(type, name, predicate, value) {\n    CodeMirror.registerHelper(type, name, value);\n    helpers[type]._global.push({pred: predicate, val: value});\n  };\n\n  // MODE STATE HANDLING\n\n  // Utility functions for working with state. Exported because nested\n  // modes need to do this for their inner modes.\n\n  var copyState = CodeMirror.copyState = function(mode, state) {\n    if (state === true) return state;\n    if (mode.copyState) return mode.copyState(state);\n    var nstate = {};\n    for (var n in state) {\n      var val = state[n];\n      if (val instanceof Array) val = val.concat([]);\n      nstate[n] = val;\n    }\n    return nstate;\n  };\n\n  var startState = CodeMirror.startState = function(mode, a1, a2) {\n    return mode.startState ? mode.startState(a1, a2) : true;\n  };\n\n  // Given a mode and a state (for that mode), find the inner mode and\n  // state at the position that the state refers to.\n  CodeMirror.innerMode = function(mode, state) {\n    while (mode.innerMode) {\n      var info = mode.innerMode(state);\n      if (!info || info.mode == mode) break;\n      state = info.state;\n      mode = info.mode;\n    }\n    return info || {mode: mode, state: state};\n  };\n\n  // STANDARD COMMANDS\n\n  // Commands are parameter-less actions that can be performed on an\n  // editor, mostly used for keybindings.\n  var commands = CodeMirror.commands = {\n    selectAll: function(cm) {cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll);},\n    singleSelection: function(cm) {\n      cm.setSelection(cm.getCursor(\"anchor\"), cm.getCursor(\"head\"), sel_dontScroll);\n    },\n    killLine: function(cm) {\n      deleteNearSelection(cm, function(range) {\n        if (range.empty()) {\n          var len = getLine(cm.doc, range.head.line).text.length;\n          if (range.head.ch == len && range.head.line < cm.lastLine())\n            return {from: range.head, to: Pos(range.head.line + 1, 0)};\n          else\n            return {from: range.head, to: Pos(range.head.line, len)};\n        } else {\n          return {from: range.from(), to: range.to()};\n        }\n      });\n    },\n    deleteLine: function(cm) {\n      deleteNearSelection(cm, function(range) {\n        return {from: Pos(range.from().line, 0),\n                to: clipPos(cm.doc, Pos(range.to().line + 1, 0))};\n      });\n    },\n    delLineLeft: function(cm) {\n      deleteNearSelection(cm, function(range) {\n        return {from: Pos(range.from().line, 0), to: range.from()};\n      });\n    },\n    delWrappedLineLeft: function(cm) {\n      deleteNearSelection(cm, function(range) {\n        var top = cm.charCoords(range.head, \"div\").top + 5;\n        var leftPos = cm.coordsChar({left: 0, top: top}, \"div\");\n        return {from: leftPos, to: range.from()};\n      });\n    },\n    delWrappedLineRight: function(cm) {\n      deleteNearSelection(cm, function(range) {\n        var top = cm.charCoords(range.head, \"div\").top + 5;\n        var rightPos = cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, \"div\");\n        return {from: range.from(), to: rightPos };\n      });\n    },\n    undo: function(cm) {cm.undo();},\n    redo: function(cm) {cm.redo();},\n    undoSelection: function(cm) {cm.undoSelection();},\n    redoSelection: function(cm) {cm.redoSelection();},\n    goDocStart: function(cm) {cm.extendSelection(Pos(cm.firstLine(), 0));},\n    goDocEnd: function(cm) {cm.extendSelection(Pos(cm.lastLine()));},\n    goLineStart: function(cm) {\n      cm.extendSelectionsBy(function(range) { return lineStart(cm, range.head.line); },\n                            {origin: \"+move\", bias: 1});\n    },\n    goLineStartSmart: function(cm) {\n      cm.extendSelectionsBy(function(range) {\n        return lineStartSmart(cm, range.head);\n      }, {origin: \"+move\", bias: 1});\n    },\n    goLineEnd: function(cm) {\n      cm.extendSelectionsBy(function(range) { return lineEnd(cm, range.head.line); },\n                            {origin: \"+move\", bias: -1});\n    },\n    goLineRight: function(cm) {\n      cm.extendSelectionsBy(function(range) {\n        var top = cm.charCoords(range.head, \"div\").top + 5;\n        return cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, \"div\");\n      }, sel_move);\n    },\n    goLineLeft: function(cm) {\n      cm.extendSelectionsBy(function(range) {\n        var top = cm.charCoords(range.head, \"div\").top + 5;\n        return cm.coordsChar({left: 0, top: top}, \"div\");\n      }, sel_move);\n    },\n    goLineLeftSmart: function(cm) {\n      cm.extendSelectionsBy(function(range) {\n        var top = cm.charCoords(range.head, \"div\").top + 5;\n        var pos = cm.coordsChar({left: 0, top: top}, \"div\");\n        if (pos.ch < cm.getLine(pos.line).search(/\\S/)) return lineStartSmart(cm, range.head);\n        return pos;\n      }, sel_move);\n    },\n    goLineUp: function(cm) {cm.moveV(-1, \"line\");},\n    goLineDown: function(cm) {cm.moveV(1, \"line\");},\n    goPageUp: function(cm) {cm.moveV(-1, \"page\");},\n    goPageDown: function(cm) {cm.moveV(1, \"page\");},\n    goCharLeft: function(cm) {cm.moveH(-1, \"char\");},\n    goCharRight: function(cm) {cm.moveH(1, \"char\");},\n    goColumnLeft: function(cm) {cm.moveH(-1, \"column\");},\n    goColumnRight: function(cm) {cm.moveH(1, \"column\");},\n    goWordLeft: function(cm) {cm.moveH(-1, \"word\");},\n    goGroupRight: function(cm) {cm.moveH(1, \"group\");},\n    goGroupLeft: function(cm) {cm.moveH(-1, \"group\");},\n    goWordRight: function(cm) {cm.moveH(1, \"word\");},\n    delCharBefore: function(cm) {cm.deleteH(-1, \"char\");},\n    delCharAfter: function(cm) {cm.deleteH(1, \"char\");},\n    delWordBefore: function(cm) {cm.deleteH(-1, \"word\");},\n    delWordAfter: function(cm) {cm.deleteH(1, \"word\");},\n    delGroupBefore: function(cm) {cm.deleteH(-1, \"group\");},\n    delGroupAfter: function(cm) {cm.deleteH(1, \"group\");},\n    indentAuto: function(cm) {cm.indentSelection(\"smart\");},\n    indentMore: function(cm) {cm.indentSelection(\"add\");},\n    indentLess: function(cm) {cm.indentSelection(\"subtract\");},\n    insertTab: function(cm) {cm.replaceSelection(\"\\t\");},\n    insertSoftTab: function(cm) {\n      var spaces = [], ranges = cm.listSelections(), tabSize = cm.options.tabSize;\n      for (var i = 0; i < ranges.length; i++) {\n        var pos = ranges[i].from();\n        var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);\n        spaces.push(new Array(tabSize - col % tabSize + 1).join(\" \"));\n      }\n      cm.replaceSelections(spaces);\n    },\n    defaultTab: function(cm) {\n      if (cm.somethingSelected()) cm.indentSelection(\"add\");\n      else cm.execCommand(\"insertTab\");\n    },\n    transposeChars: function(cm) {\n      runInOp(cm, function() {\n        var ranges = cm.listSelections(), newSel = [];\n        for (var i = 0; i < ranges.length; i++) {\n          var cur = ranges[i].head, line = getLine(cm.doc, cur.line).text;\n          if (line) {\n            if (cur.ch == line.length) cur = new Pos(cur.line, cur.ch - 1);\n            if (cur.ch > 0) {\n              cur = new Pos(cur.line, cur.ch + 1);\n              cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2),\n                              Pos(cur.line, cur.ch - 2), cur, \"+transpose\");\n            } else if (cur.line > cm.doc.first) {\n              var prev = getLine(cm.doc, cur.line - 1).text;\n              if (prev)\n                cm.replaceRange(line.charAt(0) + \"\\n\" + prev.charAt(prev.length - 1),\n                                Pos(cur.line - 1, prev.length - 1), Pos(cur.line, 1), \"+transpose\");\n            }\n          }\n          newSel.push(new Range(cur, cur));\n        }\n        cm.setSelections(newSel);\n      });\n    },\n    newlineAndIndent: function(cm) {\n      runInOp(cm, function() {\n        var len = cm.listSelections().length;\n        for (var i = 0; i < len; i++) {\n          var range = cm.listSelections()[i];\n          cm.replaceRange(\"\\n\", range.anchor, range.head, \"+input\");\n          cm.indentLine(range.from().line + 1, null, true);\n          ensureCursorVisible(cm);\n        }\n      });\n    },\n    toggleOverwrite: function(cm) {cm.toggleOverwrite();}\n  };\n\n  // STANDARD KEYMAPS\n\n  var keyMap = CodeMirror.keyMap = {};\n  keyMap.basic = {\n    \"Left\": \"goCharLeft\", \"Right\": \"goCharRight\", \"Up\": \"goLineUp\", \"Down\": \"goLineDown\",\n    \"End\": \"goLineEnd\", \"Home\": \"goLineStartSmart\", \"PageUp\": \"goPageUp\", \"PageDown\": \"goPageDown\",\n    \"Delete\": \"delCharAfter\", \"Backspace\": \"delCharBefore\", \"Shift-Backspace\": \"delCharBefore\",\n    \"Tab\": \"defaultTab\", \"Shift-Tab\": \"indentAuto\",\n    \"Enter\": \"newlineAndIndent\", \"Insert\": \"toggleOverwrite\",\n    \"Esc\": \"singleSelection\"\n  };\n  // Note that the save and find-related commands aren't defined by\n  // default. User code or addons can define them. Unknown commands\n  // are simply ignored.\n  keyMap.pcDefault = {\n    \"Ctrl-A\": \"selectAll\", \"Ctrl-D\": \"deleteLine\", \"Ctrl-Z\": \"undo\", \"Shift-Ctrl-Z\": \"redo\", \"Ctrl-Y\": \"redo\",\n    \"Ctrl-Home\": \"goDocStart\", \"Ctrl-End\": \"goDocEnd\", \"Ctrl-Up\": \"goLineUp\", \"Ctrl-Down\": \"goLineDown\",\n    \"Ctrl-Left\": \"goGroupLeft\", \"Ctrl-Right\": \"goGroupRight\", \"Alt-Left\": \"goLineStart\", \"Alt-Right\": \"goLineEnd\",\n    \"Ctrl-Backspace\": \"delGroupBefore\", \"Ctrl-Delete\": \"delGroupAfter\", \"Ctrl-S\": \"save\", \"Ctrl-F\": \"find\",\n    \"Ctrl-G\": \"findNext\", \"Shift-Ctrl-G\": \"findPrev\", \"Shift-Ctrl-F\": \"replace\", \"Shift-Ctrl-R\": \"replaceAll\",\n    \"Ctrl-[\": \"indentLess\", \"Ctrl-]\": \"indentMore\",\n    \"Ctrl-U\": \"undoSelection\", \"Shift-Ctrl-U\": \"redoSelection\", \"Alt-U\": \"redoSelection\",\n    fallthrough: \"basic\"\n  };\n  keyMap.macDefault = {\n    \"Cmd-A\": \"selectAll\", \"Cmd-D\": \"deleteLine\", \"Cmd-Z\": \"undo\", \"Shift-Cmd-Z\": \"redo\", \"Cmd-Y\": \"redo\",\n    \"Cmd-Home\": \"goDocStart\", \"Cmd-Up\": \"goDocStart\", \"Cmd-End\": \"goDocEnd\", \"Cmd-Down\": \"goDocEnd\", \"Alt-Left\": \"goGroupLeft\",\n    \"Alt-Right\": \"goGroupRight\", \"Cmd-Left\": \"goLineLeft\", \"Cmd-Right\": \"goLineRight\", \"Alt-Backspace\": \"delGroupBefore\",\n    \"Ctrl-Alt-Backspace\": \"delGroupAfter\", \"Alt-Delete\": \"delGroupAfter\", \"Cmd-S\": \"save\", \"Cmd-F\": \"find\",\n    \"Cmd-G\": \"findNext\", \"Shift-Cmd-G\": \"findPrev\", \"Cmd-Alt-F\": \"replace\", \"Shift-Cmd-Alt-F\": \"replaceAll\",\n    \"Cmd-[\": \"indentLess\", \"Cmd-]\": \"indentMore\", \"Cmd-Backspace\": \"delWrappedLineLeft\", \"Cmd-Delete\": \"delWrappedLineRight\",\n    \"Cmd-U\": \"undoSelection\", \"Shift-Cmd-U\": \"redoSelection\", \"Ctrl-Up\": \"goDocStart\", \"Ctrl-Down\": \"goDocEnd\",\n    fallthrough: [\"basic\", \"emacsy\"]\n  };\n  // Very basic readline/emacs-style bindings, which are standard on Mac.\n  keyMap.emacsy = {\n    \"Ctrl-F\": \"goCharRight\", \"Ctrl-B\": \"goCharLeft\", \"Ctrl-P\": \"goLineUp\", \"Ctrl-N\": \"goLineDown\",\n    \"Alt-F\": \"goWordRight\", \"Alt-B\": \"goWordLeft\", \"Ctrl-A\": \"goLineStart\", \"Ctrl-E\": \"goLineEnd\",\n    \"Ctrl-V\": \"goPageDown\", \"Shift-Ctrl-V\": \"goPageUp\", \"Ctrl-D\": \"delCharAfter\", \"Ctrl-H\": \"delCharBefore\",\n    \"Alt-D\": \"delWordAfter\", \"Alt-Backspace\": \"delWordBefore\", \"Ctrl-K\": \"killLine\", \"Ctrl-T\": \"transposeChars\"\n  };\n  keyMap[\"default\"] = mac ? keyMap.macDefault : keyMap.pcDefault;\n\n  // KEYMAP DISPATCH\n\n  function getKeyMap(val) {\n    if (typeof val == \"string\") return keyMap[val];\n    else return val;\n  }\n\n  // Given an array of keymaps and a key name, call handle on any\n  // bindings found, until that returns a truthy value, at which point\n  // we consider the key handled. Implements things like binding a key\n  // to false stopping further handling and keymap fallthrough.\n  var lookupKey = CodeMirror.lookupKey = function(name, maps, handle) {\n    function lookup(map) {\n      map = getKeyMap(map);\n      var found = map[name];\n      if (found === false) return \"stop\";\n      if (found != null && handle(found)) return true;\n      if (map.nofallthrough) return \"stop\";\n\n      var fallthrough = map.fallthrough;\n      if (fallthrough == null) return false;\n      if (Object.prototype.toString.call(fallthrough) != \"[object Array]\")\n        return lookup(fallthrough);\n      for (var i = 0; i < fallthrough.length; ++i) {\n        var done = lookup(fallthrough[i]);\n        if (done) return done;\n      }\n      return false;\n    }\n\n    for (var i = 0; i < maps.length; ++i) {\n      var done = lookup(maps[i]);\n      if (done) return done != \"stop\";\n    }\n  };\n\n  // Modifier key presses don't count as 'real' key presses for the\n  // purpose of keymap fallthrough.\n  var isModifierKey = CodeMirror.isModifierKey = function(event) {\n    var name = keyNames[event.keyCode];\n    return name == \"Ctrl\" || name == \"Alt\" || name == \"Shift\" || name == \"Mod\";\n  };\n\n  // Look up the name of a key as indicated by an event object.\n  var keyName = CodeMirror.keyName = function(event, noShift) {\n    if (presto && event.keyCode == 34 && event[\"char\"]) return false;\n    var name = keyNames[event.keyCode];\n    if (name == null || event.altGraphKey) return false;\n    if (event.altKey) name = \"Alt-\" + name;\n    if (flipCtrlCmd ? event.metaKey : event.ctrlKey) name = \"Ctrl-\" + name;\n    if (flipCtrlCmd ? event.ctrlKey : event.metaKey) name = \"Cmd-\" + name;\n    if (!noShift && event.shiftKey) name = \"Shift-\" + name;\n    return name;\n  };\n\n  // FROMTEXTAREA\n\n  CodeMirror.fromTextArea = function(textarea, options) {\n    if (!options) options = {};\n    options.value = textarea.value;\n    if (!options.tabindex && textarea.tabindex)\n      options.tabindex = textarea.tabindex;\n    if (!options.placeholder && textarea.placeholder)\n      options.placeholder = textarea.placeholder;\n    // Set autofocus to true if this textarea is focused, or if it has\n    // autofocus and no other element is focused.\n    if (options.autofocus == null) {\n      var hasFocus = activeElt();\n      options.autofocus = hasFocus == textarea ||\n        textarea.getAttribute(\"autofocus\") != null && hasFocus == document.body;\n    }\n\n    function save() {textarea.value = cm.getValue();}\n    if (textarea.form) {\n      on(textarea.form, \"submit\", save);\n      // Deplorable hack to make the submit method do the right thing.\n      if (!options.leaveSubmitMethodAlone) {\n        var form = textarea.form, realSubmit = form.submit;\n        try {\n          var wrappedSubmit = form.submit = function() {\n            save();\n            form.submit = realSubmit;\n            form.submit();\n            form.submit = wrappedSubmit;\n          };\n        } catch(e) {}\n      }\n    }\n\n    textarea.style.display = \"none\";\n    var cm = CodeMirror(function(node) {\n      textarea.parentNode.insertBefore(node, textarea.nextSibling);\n    }, options);\n    cm.save = save;\n    cm.getTextArea = function() { return textarea; };\n    cm.toTextArea = function() {\n      cm.toTextArea = isNaN; // Prevent this from being ran twice\n      save();\n      textarea.parentNode.removeChild(cm.getWrapperElement());\n      textarea.style.display = \"\";\n      if (textarea.form) {\n        off(textarea.form, \"submit\", save);\n        if (typeof textarea.form.submit == \"function\")\n          textarea.form.submit = realSubmit;\n      }\n    };\n    return cm;\n  };\n\n  // STRING STREAM\n\n  // Fed to the mode parsers, provides helper functions to make\n  // parsers more succinct.\n\n  var StringStream = CodeMirror.StringStream = function(string, tabSize) {\n    this.pos = this.start = 0;\n    this.string = string;\n    this.tabSize = tabSize || 8;\n    this.lastColumnPos = this.lastColumnValue = 0;\n    this.lineStart = 0;\n  };\n\n  StringStream.prototype = {\n    eol: function() {return this.pos >= this.string.length;},\n    sol: function() {return this.pos == this.lineStart;},\n    peek: function() {return this.string.charAt(this.pos) || undefined;},\n    next: function() {\n      if (this.pos < this.string.length)\n        return this.string.charAt(this.pos++);\n    },\n    eat: function(match) {\n      var ch = this.string.charAt(this.pos);\n      if (typeof match == \"string\") var ok = ch == match;\n      else var ok = ch && (match.test ? match.test(ch) : match(ch));\n      if (ok) {++this.pos; return ch;}\n    },\n    eatWhile: function(match) {\n      var start = this.pos;\n      while (this.eat(match)){}\n      return this.pos > start;\n    },\n    eatSpace: function() {\n      var start = this.pos;\n      while (/[\\s\\u00a0]/.test(this.string.charAt(this.pos))) ++this.pos;\n      return this.pos > start;\n    },\n    skipToEnd: function() {this.pos = this.string.length;},\n    skipTo: function(ch) {\n      var found = this.string.indexOf(ch, this.pos);\n      if (found > -1) {this.pos = found; return true;}\n    },\n    backUp: function(n) {this.pos -= n;},\n    column: function() {\n      if (this.lastColumnPos < this.start) {\n        this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);\n        this.lastColumnPos = this.start;\n      }\n      return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);\n    },\n    indentation: function() {\n      return countColumn(this.string, null, this.tabSize) -\n        (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);\n    },\n    match: function(pattern, consume, caseInsensitive) {\n      if (typeof pattern == \"string\") {\n        var cased = function(str) {return caseInsensitive ? str.toLowerCase() : str;};\n        var substr = this.string.substr(this.pos, pattern.length);\n        if (cased(substr) == cased(pattern)) {\n          if (consume !== false) this.pos += pattern.length;\n          return true;\n        }\n      } else {\n        var match = this.string.slice(this.pos).match(pattern);\n        if (match && match.index > 0) return null;\n        if (match && consume !== false) this.pos += match[0].length;\n        return match;\n      }\n    },\n    current: function(){return this.string.slice(this.start, this.pos);},\n    hideFirstChars: function(n, inner) {\n      this.lineStart += n;\n      try { return inner(); }\n      finally { this.lineStart -= n; }\n    }\n  };\n\n  // TEXTMARKERS\n\n  // Created with markText and setBookmark methods. A TextMarker is a\n  // handle that can be used to clear or find a marked position in the\n  // document. Line objects hold arrays (markedSpans) containing\n  // {from, to, marker} object pointing to such marker objects, and\n  // indicating that such a marker is present on that line. Multiple\n  // lines may point to the same marker when it spans across lines.\n  // The spans will have null for their from/to properties when the\n  // marker continues beyond the start/end of the line. Markers have\n  // links back to the lines they currently touch.\n\n  var TextMarker = CodeMirror.TextMarker = function(doc, type) {\n    this.lines = [];\n    this.type = type;\n    this.doc = doc;\n  };\n  eventMixin(TextMarker);\n\n  // Clear the marker.\n  TextMarker.prototype.clear = function() {\n    if (this.explicitlyCleared) return;\n    var cm = this.doc.cm, withOp = cm && !cm.curOp;\n    if (withOp) startOperation(cm);\n    if (hasHandler(this, \"clear\")) {\n      var found = this.find();\n      if (found) signalLater(this, \"clear\", found.from, found.to);\n    }\n    var min = null, max = null;\n    for (var i = 0; i < this.lines.length; ++i) {\n      var line = this.lines[i];\n      var span = getMarkedSpanFor(line.markedSpans, this);\n      if (cm && !this.collapsed) regLineChange(cm, lineNo(line), \"text\");\n      else if (cm) {\n        if (span.to != null) max = lineNo(line);\n        if (span.from != null) min = lineNo(line);\n      }\n      line.markedSpans = removeMarkedSpan(line.markedSpans, span);\n      if (span.from == null && this.collapsed && !lineIsHidden(this.doc, line) && cm)\n        updateLineHeight(line, textHeight(cm.display));\n    }\n    if (cm && this.collapsed && !cm.options.lineWrapping) for (var i = 0; i < this.lines.length; ++i) {\n      var visual = visualLine(this.lines[i]), len = lineLength(visual);\n      if (len > cm.display.maxLineLength) {\n        cm.display.maxLine = visual;\n        cm.display.maxLineLength = len;\n        cm.display.maxLineChanged = true;\n      }\n    }\n\n    if (min != null && cm && this.collapsed) regChange(cm, min, max + 1);\n    this.lines.length = 0;\n    this.explicitlyCleared = true;\n    if (this.atomic && this.doc.cantEdit) {\n      this.doc.cantEdit = false;\n      if (cm) reCheckSelection(cm.doc);\n    }\n    if (cm) signalLater(cm, \"markerCleared\", cm, this);\n    if (withOp) endOperation(cm);\n    if (this.parent) this.parent.clear();\n  };\n\n  // Find the position of the marker in the document. Returns a {from,\n  // to} object by default. Side can be passed to get a specific side\n  // -- 0 (both), -1 (left), or 1 (right). When lineObj is true, the\n  // Pos objects returned contain a line object, rather than a line\n  // number (used to prevent looking up the same line twice).\n  TextMarker.prototype.find = function(side, lineObj) {\n    if (side == null && this.type == \"bookmark\") side = 1;\n    var from, to;\n    for (var i = 0; i < this.lines.length; ++i) {\n      var line = this.lines[i];\n      var span = getMarkedSpanFor(line.markedSpans, this);\n      if (span.from != null) {\n        from = Pos(lineObj ? line : lineNo(line), span.from);\n        if (side == -1) return from;\n      }\n      if (span.to != null) {\n        to = Pos(lineObj ? line : lineNo(line), span.to);\n        if (side == 1) return to;\n      }\n    }\n    return from && {from: from, to: to};\n  };\n\n  // Signals that the marker's widget changed, and surrounding layout\n  // should be recomputed.\n  TextMarker.prototype.changed = function() {\n    var pos = this.find(-1, true), widget = this, cm = this.doc.cm;\n    if (!pos || !cm) return;\n    runInOp(cm, function() {\n      var line = pos.line, lineN = lineNo(pos.line);\n      var view = findViewForLine(cm, lineN);\n      if (view) {\n        clearLineMeasurementCacheFor(view);\n        cm.curOp.selectionChanged = cm.curOp.forceUpdate = true;\n      }\n      cm.curOp.updateMaxLine = true;\n      if (!lineIsHidden(widget.doc, line) && widget.height != null) {\n        var oldHeight = widget.height;\n        widget.height = null;\n        var dHeight = widgetHeight(widget) - oldHeight;\n        if (dHeight)\n          updateLineHeight(line, line.height + dHeight);\n      }\n    });\n  };\n\n  TextMarker.prototype.attachLine = function(line) {\n    if (!this.lines.length && this.doc.cm) {\n      var op = this.doc.cm.curOp;\n      if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1)\n        (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this);\n    }\n    this.lines.push(line);\n  };\n  TextMarker.prototype.detachLine = function(line) {\n    this.lines.splice(indexOf(this.lines, line), 1);\n    if (!this.lines.length && this.doc.cm) {\n      var op = this.doc.cm.curOp;\n      (op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);\n    }\n  };\n\n  // Collapsed markers have unique ids, in order to be able to order\n  // them, which is needed for uniquely determining an outer marker\n  // when they overlap (they may nest, but not partially overlap).\n  var nextMarkerId = 0;\n\n  // Create a marker, wire it up to the right lines, and\n  function markText(doc, from, to, options, type) {\n    // Shared markers (across linked documents) are handled separately\n    // (markTextShared will call out to this again, once per\n    // document).\n    if (options && options.shared) return markTextShared(doc, from, to, options, type);\n    // Ensure we are in an operation.\n    if (doc.cm && !doc.cm.curOp) return operation(doc.cm, markText)(doc, from, to, options, type);\n\n    var marker = new TextMarker(doc, type), diff = cmp(from, to);\n    if (options) copyObj(options, marker, false);\n    // Don't connect empty markers unless clearWhenEmpty is false\n    if (diff > 0 || diff == 0 && marker.clearWhenEmpty !== false)\n      return marker;\n    if (marker.replacedWith) {\n      // Showing up as a widget implies collapsed (widget replaces text)\n      marker.collapsed = true;\n      marker.widgetNode = elt(\"span\", [marker.replacedWith], \"CodeMirror-widget\");\n      if (!options.handleMouseEvents) marker.widgetNode.ignoreEvents = true;\n      if (options.insertLeft) marker.widgetNode.insertLeft = true;\n    }\n    if (marker.collapsed) {\n      if (conflictingCollapsedRange(doc, from.line, from, to, marker) ||\n          from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker))\n        throw new Error(\"Inserting collapsed marker partially overlapping an existing one\");\n      sawCollapsedSpans = true;\n    }\n\n    if (marker.addToHistory)\n      addChangeToHistory(doc, {from: from, to: to, origin: \"markText\"}, doc.sel, NaN);\n\n    var curLine = from.line, cm = doc.cm, updateMaxLine;\n    doc.iter(curLine, to.line + 1, function(line) {\n      if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine)\n        updateMaxLine = true;\n      if (marker.collapsed && curLine != from.line) updateLineHeight(line, 0);\n      addMarkedSpan(line, new MarkedSpan(marker,\n                                         curLine == from.line ? from.ch : null,\n                                         curLine == to.line ? to.ch : null));\n      ++curLine;\n    });\n    // lineIsHidden depends on the presence of the spans, so needs a second pass\n    if (marker.collapsed) doc.iter(from.line, to.line + 1, function(line) {\n      if (lineIsHidden(doc, line)) updateLineHeight(line, 0);\n    });\n\n    if (marker.clearOnEnter) on(marker, \"beforeCursorEnter\", function() { marker.clear(); });\n\n    if (marker.readOnly) {\n      sawReadOnlySpans = true;\n      if (doc.history.done.length || doc.history.undone.length)\n        doc.clearHistory();\n    }\n    if (marker.collapsed) {\n      marker.id = ++nextMarkerId;\n      marker.atomic = true;\n    }\n    if (cm) {\n      // Sync editor state\n      if (updateMaxLine) cm.curOp.updateMaxLine = true;\n      if (marker.collapsed)\n        regChange(cm, from.line, to.line + 1);\n      else if (marker.className || marker.title || marker.startStyle || marker.endStyle)\n        for (var i = from.line; i <= to.line; i++) regLineChange(cm, i, \"text\");\n      if (marker.atomic) reCheckSelection(cm.doc);\n      signalLater(cm, \"markerAdded\", cm, marker);\n    }\n    return marker;\n  }\n\n  // SHARED TEXTMARKERS\n\n  // A shared marker spans multiple linked documents. It is\n  // implemented as a meta-marker-object controlling multiple normal\n  // markers.\n  var SharedTextMarker = CodeMirror.SharedTextMarker = function(markers, primary) {\n    this.markers = markers;\n    this.primary = primary;\n    for (var i = 0; i < markers.length; ++i)\n      markers[i].parent = this;\n  };\n  eventMixin(SharedTextMarker);\n\n  SharedTextMarker.prototype.clear = function() {\n    if (this.explicitlyCleared) return;\n    this.explicitlyCleared = true;\n    for (var i = 0; i < this.markers.length; ++i)\n      this.markers[i].clear();\n    signalLater(this, \"clear\");\n  };\n  SharedTextMarker.prototype.find = function(side, lineObj) {\n    return this.primary.find(side, lineObj);\n  };\n\n  function markTextShared(doc, from, to, options, type) {\n    options = copyObj(options);\n    options.shared = false;\n    var markers = [markText(doc, from, to, options, type)], primary = markers[0];\n    var widget = options.widgetNode;\n    linkedDocs(doc, function(doc) {\n      if (widget) options.widgetNode = widget.cloneNode(true);\n      markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type));\n      for (var i = 0; i < doc.linked.length; ++i)\n        if (doc.linked[i].isParent) return;\n      primary = lst(markers);\n    });\n    return new SharedTextMarker(markers, primary);\n  }\n\n  function findSharedMarkers(doc) {\n    return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())),\n                         function(m) { return m.parent; });\n  }\n\n  function copySharedMarkers(doc, markers) {\n    for (var i = 0; i < markers.length; i++) {\n      var marker = markers[i], pos = marker.find();\n      var mFrom = doc.clipPos(pos.from), mTo = doc.clipPos(pos.to);\n      if (cmp(mFrom, mTo)) {\n        var subMark = markText(doc, mFrom, mTo, marker.primary, marker.primary.type);\n        marker.markers.push(subMark);\n        subMark.parent = marker;\n      }\n    }\n  }\n\n  function detachSharedMarkers(markers) {\n    for (var i = 0; i < markers.length; i++) {\n      var marker = markers[i], linked = [marker.primary.doc];;\n      linkedDocs(marker.primary.doc, function(d) { linked.push(d); });\n      for (var j = 0; j < marker.markers.length; j++) {\n        var subMarker = marker.markers[j];\n        if (indexOf(linked, subMarker.doc) == -1) {\n          subMarker.parent = null;\n          marker.markers.splice(j--, 1);\n        }\n      }\n    }\n  }\n\n  // TEXTMARKER SPANS\n\n  function MarkedSpan(marker, from, to) {\n    this.marker = marker;\n    this.from = from; this.to = to;\n  }\n\n  // Search an array of spans for a span matching the given marker.\n  function getMarkedSpanFor(spans, marker) {\n    if (spans) for (var i = 0; i < spans.length; ++i) {\n      var span = spans[i];\n      if (span.marker == marker) return span;\n    }\n  }\n  // Remove a span from an array, returning undefined if no spans are\n  // left (we don't store arrays for lines without spans).\n  function removeMarkedSpan(spans, span) {\n    for (var r, i = 0; i < spans.length; ++i)\n      if (spans[i] != span) (r || (r = [])).push(spans[i]);\n    return r;\n  }\n  // Add a span to a line.\n  function addMarkedSpan(line, span) {\n    line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];\n    span.marker.attachLine(line);\n  }\n\n  // Used for the algorithm that adjusts markers for a change in the\n  // document. These functions cut an array of spans at a given\n  // character position, returning an array of remaining chunks (or\n  // undefined if nothing remains).\n  function markedSpansBefore(old, startCh, isInsert) {\n    if (old) for (var i = 0, nw; i < old.length; ++i) {\n      var span = old[i], marker = span.marker;\n      var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);\n      if (startsBefore || span.from == startCh && marker.type == \"bookmark\" && (!isInsert || !span.marker.insertLeft)) {\n        var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh);\n        (nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to));\n      }\n    }\n    return nw;\n  }\n  function markedSpansAfter(old, endCh, isInsert) {\n    if (old) for (var i = 0, nw; i < old.length; ++i) {\n      var span = old[i], marker = span.marker;\n      var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);\n      if (endsAfter || span.from == endCh && marker.type == \"bookmark\" && (!isInsert || span.marker.insertLeft)) {\n        var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh);\n        (nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh,\n                                              span.to == null ? null : span.to - endCh));\n      }\n    }\n    return nw;\n  }\n\n  // Given a change object, compute the new set of marker spans that\n  // cover the line in which the change took place. Removes spans\n  // entirely within the change, reconnects spans belonging to the\n  // same marker that appear on both sides of the change, and cuts off\n  // spans partially within the change. Returns an array of span\n  // arrays with one element for each line in (after) the change.\n  function stretchSpansOverChange(doc, change) {\n    var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;\n    var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;\n    if (!oldFirst && !oldLast) return null;\n\n    var startCh = change.from.ch, endCh = change.to.ch, isInsert = cmp(change.from, change.to) == 0;\n    // Get the spans that 'stick out' on both sides\n    var first = markedSpansBefore(oldFirst, startCh, isInsert);\n    var last = markedSpansAfter(oldLast, endCh, isInsert);\n\n    // Next, merge those two ends\n    var sameLine = change.text.length == 1, offset = lst(change.text).length + (sameLine ? startCh : 0);\n    if (first) {\n      // Fix up .to properties of first\n      for (var i = 0; i < first.length; ++i) {\n        var span = first[i];\n        if (span.to == null) {\n          var found = getMarkedSpanFor(last, span.marker);\n          if (!found) span.to = startCh;\n          else if (sameLine) span.to = found.to == null ? null : found.to + offset;\n        }\n      }\n    }\n    if (last) {\n      // Fix up .from in last (or move them into first in case of sameLine)\n      for (var i = 0; i < last.length; ++i) {\n        var span = last[i];\n        if (span.to != null) span.to += offset;\n        if (span.from == null) {\n          var found = getMarkedSpanFor(first, span.marker);\n          if (!found) {\n            span.from = offset;\n            if (sameLine) (first || (first = [])).push(span);\n          }\n        } else {\n          span.from += offset;\n          if (sameLine) (first || (first = [])).push(span);\n        }\n      }\n    }\n    // Make sure we didn't create any zero-length spans\n    if (first) first = clearEmptySpans(first);\n    if (last && last != first) last = clearEmptySpans(last);\n\n    var newMarkers = [first];\n    if (!sameLine) {\n      // Fill gap with whole-line-spans\n      var gap = change.text.length - 2, gapMarkers;\n      if (gap > 0 && first)\n        for (var i = 0; i < first.length; ++i)\n          if (first[i].to == null)\n            (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i].marker, null, null));\n      for (var i = 0; i < gap; ++i)\n        newMarkers.push(gapMarkers);\n      newMarkers.push(last);\n    }\n    return newMarkers;\n  }\n\n  // Remove spans that are empty and don't have a clearWhenEmpty\n  // option of false.\n  function clearEmptySpans(spans) {\n    for (var i = 0; i < spans.length; ++i) {\n      var span = spans[i];\n      if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false)\n        spans.splice(i--, 1);\n    }\n    if (!spans.length) return null;\n    return spans;\n  }\n\n  // Used for un/re-doing changes from the history. Combines the\n  // result of computing the existing spans with the set of spans that\n  // existed in the history (so that deleting around a span and then\n  // undoing brings back the span).\n  function mergeOldSpans(doc, change) {\n    var old = getOldSpans(doc, change);\n    var stretched = stretchSpansOverChange(doc, change);\n    if (!old) return stretched;\n    if (!stretched) return old;\n\n    for (var i = 0; i < old.length; ++i) {\n      var oldCur = old[i], stretchCur = stretched[i];\n      if (oldCur && stretchCur) {\n        spans: for (var j = 0; j < stretchCur.length; ++j) {\n          var span = stretchCur[j];\n          for (var k = 0; k < oldCur.length; ++k)\n            if (oldCur[k].marker == span.marker) continue spans;\n          oldCur.push(span);\n        }\n      } else if (stretchCur) {\n        old[i] = stretchCur;\n      }\n    }\n    return old;\n  }\n\n  // Used to 'clip' out readOnly ranges when making a change.\n  function removeReadOnlyRanges(doc, from, to) {\n    var markers = null;\n    doc.iter(from.line, to.line + 1, function(line) {\n      if (line.markedSpans) for (var i = 0; i < line.markedSpans.length; ++i) {\n        var mark = line.markedSpans[i].marker;\n        if (mark.readOnly && (!markers || indexOf(markers, mark) == -1))\n          (markers || (markers = [])).push(mark);\n      }\n    });\n    if (!markers) return null;\n    var parts = [{from: from, to: to}];\n    for (var i = 0; i < markers.length; ++i) {\n      var mk = markers[i], m = mk.find(0);\n      for (var j = 0; j < parts.length; ++j) {\n        var p = parts[j];\n        if (cmp(p.to, m.from) < 0 || cmp(p.from, m.to) > 0) continue;\n        var newParts = [j, 1], dfrom = cmp(p.from, m.from), dto = cmp(p.to, m.to);\n        if (dfrom < 0 || !mk.inclusiveLeft && !dfrom)\n          newParts.push({from: p.from, to: m.from});\n        if (dto > 0 || !mk.inclusiveRight && !dto)\n          newParts.push({from: m.to, to: p.to});\n        parts.splice.apply(parts, newParts);\n        j += newParts.length - 1;\n      }\n    }\n    return parts;\n  }\n\n  // Connect or disconnect spans from a line.\n  function detachMarkedSpans(line) {\n    var spans = line.markedSpans;\n    if (!spans) return;\n    for (var i = 0; i < spans.length; ++i)\n      spans[i].marker.detachLine(line);\n    line.markedSpans = null;\n  }\n  function attachMarkedSpans(line, spans) {\n    if (!spans) return;\n    for (var i = 0; i < spans.length; ++i)\n      spans[i].marker.attachLine(line);\n    line.markedSpans = spans;\n  }\n\n  // Helpers used when computing which overlapping collapsed span\n  // counts as the larger one.\n  function extraLeft(marker) { return marker.inclusiveLeft ? -1 : 0; }\n  function extraRight(marker) { return marker.inclusiveRight ? 1 : 0; }\n\n  // Returns a number indicating which of two overlapping collapsed\n  // spans is larger (and thus includes the other). Falls back to\n  // comparing ids when the spans cover exactly the same range.\n  function compareCollapsedMarkers(a, b) {\n    var lenDiff = a.lines.length - b.lines.length;\n    if (lenDiff != 0) return lenDiff;\n    var aPos = a.find(), bPos = b.find();\n    var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);\n    if (fromCmp) return -fromCmp;\n    var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);\n    if (toCmp) return toCmp;\n    return b.id - a.id;\n  }\n\n  // Find out whether a line ends or starts in a collapsed span. If\n  // so, return the marker for that span.\n  function collapsedSpanAtSide(line, start) {\n    var sps = sawCollapsedSpans && line.markedSpans, found;\n    if (sps) for (var sp, i = 0; i < sps.length; ++i) {\n      sp = sps[i];\n      if (sp.marker.collapsed && (start ? sp.from : sp.to) == null &&\n          (!found || compareCollapsedMarkers(found, sp.marker) < 0))\n        found = sp.marker;\n    }\n    return found;\n  }\n  function collapsedSpanAtStart(line) { return collapsedSpanAtSide(line, true); }\n  function collapsedSpanAtEnd(line) { return collapsedSpanAtSide(line, false); }\n\n  // Test whether there exists a collapsed span that partially\n  // overlaps (covers the start or end, but not both) of a new span.\n  // Such overlap is not allowed.\n  function conflictingCollapsedRange(doc, lineNo, from, to, marker) {\n    var line = getLine(doc, lineNo);\n    var sps = sawCollapsedSpans && line.markedSpans;\n    if (sps) for (var i = 0; i < sps.length; ++i) {\n      var sp = sps[i];\n      if (!sp.marker.collapsed) continue;\n      var found = sp.marker.find(0);\n      var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);\n      var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);\n      if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) continue;\n      if (fromCmp <= 0 && (cmp(found.to, from) > 0 || (sp.marker.inclusiveRight && marker.inclusiveLeft)) ||\n          fromCmp >= 0 && (cmp(found.from, to) < 0 || (sp.marker.inclusiveLeft && marker.inclusiveRight)))\n        return true;\n    }\n  }\n\n  // A visual line is a line as drawn on the screen. Folding, for\n  // example, can cause multiple logical lines to appear on the same\n  // visual line. This finds the start of the visual line that the\n  // given line is part of (usually that is the line itself).\n  function visualLine(line) {\n    var merged;\n    while (merged = collapsedSpanAtStart(line))\n      line = merged.find(-1, true).line;\n    return line;\n  }\n\n  // Returns an array of logical lines that continue the visual line\n  // started by the argument, or undefined if there are no such lines.\n  function visualLineContinued(line) {\n    var merged, lines;\n    while (merged = collapsedSpanAtEnd(line)) {\n      line = merged.find(1, true).line;\n      (lines || (lines = [])).push(line);\n    }\n    return lines;\n  }\n\n  // Get the line number of the start of the visual line that the\n  // given line number is part of.\n  function visualLineNo(doc, lineN) {\n    var line = getLine(doc, lineN), vis = visualLine(line);\n    if (line == vis) return lineN;\n    return lineNo(vis);\n  }\n  // Get the line number of the start of the next visual line after\n  // the given line.\n  function visualLineEndNo(doc, lineN) {\n    if (lineN > doc.lastLine()) return lineN;\n    var line = getLine(doc, lineN), merged;\n    if (!lineIsHidden(doc, line)) return lineN;\n    while (merged = collapsedSpanAtEnd(line))\n      line = merged.find(1, true).line;\n    return lineNo(line) + 1;\n  }\n\n  // Compute whether a line is hidden. Lines count as hidden when they\n  // are part of a visual line that starts with another line, or when\n  // they are entirely covered by collapsed, non-widget span.\n  function lineIsHidden(doc, line) {\n    var sps = sawCollapsedSpans && line.markedSpans;\n    if (sps) for (var sp, i = 0; i < sps.length; ++i) {\n      sp = sps[i];\n      if (!sp.marker.collapsed) continue;\n      if (sp.from == null) return true;\n      if (sp.marker.widgetNode) continue;\n      if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp))\n        return true;\n    }\n  }\n  function lineIsHiddenInner(doc, line, span) {\n    if (span.to == null) {\n      var end = span.marker.find(1, true);\n      return lineIsHiddenInner(doc, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker));\n    }\n    if (span.marker.inclusiveRight && span.to == line.text.length)\n      return true;\n    for (var sp, i = 0; i < line.markedSpans.length; ++i) {\n      sp = line.markedSpans[i];\n      if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to &&\n          (sp.to == null || sp.to != span.from) &&\n          (sp.marker.inclusiveLeft || span.marker.inclusiveRight) &&\n          lineIsHiddenInner(doc, line, sp)) return true;\n    }\n  }\n\n  // LINE WIDGETS\n\n  // Line widgets are block elements displayed above or below a line.\n\n  var LineWidget = CodeMirror.LineWidget = function(cm, node, options) {\n    if (options) for (var opt in options) if (options.hasOwnProperty(opt))\n      this[opt] = options[opt];\n    this.cm = cm;\n    this.node = node;\n  };\n  eventMixin(LineWidget);\n\n  function adjustScrollWhenAboveVisible(cm, line, diff) {\n    if (heightAtLine(line) < ((cm.curOp && cm.curOp.scrollTop) || cm.doc.scrollTop))\n      addToScrollPos(cm, null, diff);\n  }\n\n  LineWidget.prototype.clear = function() {\n    var cm = this.cm, ws = this.line.widgets, line = this.line, no = lineNo(line);\n    if (no == null || !ws) return;\n    for (var i = 0; i < ws.length; ++i) if (ws[i] == this) ws.splice(i--, 1);\n    if (!ws.length) line.widgets = null;\n    var height = widgetHeight(this);\n    runInOp(cm, function() {\n      adjustScrollWhenAboveVisible(cm, line, -height);\n      regLineChange(cm, no, \"widget\");\n      updateLineHeight(line, Math.max(0, line.height - height));\n    });\n  };\n  LineWidget.prototype.changed = function() {\n    var oldH = this.height, cm = this.cm, line = this.line;\n    this.height = null;\n    var diff = widgetHeight(this) - oldH;\n    if (!diff) return;\n    runInOp(cm, function() {\n      cm.curOp.forceUpdate = true;\n      adjustScrollWhenAboveVisible(cm, line, diff);\n      updateLineHeight(line, line.height + diff);\n    });\n  };\n\n  function widgetHeight(widget) {\n    if (widget.height != null) return widget.height;\n    if (!contains(document.body, widget.node)) {\n      var parentStyle = \"position: relative;\";\n      if (widget.coverGutter)\n        parentStyle += \"margin-left: -\" + widget.cm.getGutterElement().offsetWidth + \"px;\";\n      removeChildrenAndAdd(widget.cm.display.measure, elt(\"div\", [widget.node], null, parentStyle));\n    }\n    return widget.height = widget.node.offsetHeight;\n  }\n\n  function addLineWidget(cm, handle, node, options) {\n    var widget = new LineWidget(cm, node, options);\n    if (widget.noHScroll) cm.display.alignWidgets = true;\n    changeLine(cm.doc, handle, \"widget\", function(line) {\n      var widgets = line.widgets || (line.widgets = []);\n      if (widget.insertAt == null) widgets.push(widget);\n      else widgets.splice(Math.min(widgets.length - 1, Math.max(0, widget.insertAt)), 0, widget);\n      widget.line = line;\n      if (!lineIsHidden(cm.doc, line)) {\n        var aboveVisible = heightAtLine(line) < cm.doc.scrollTop;\n        updateLineHeight(line, line.height + widgetHeight(widget));\n        if (aboveVisible) addToScrollPos(cm, null, widget.height);\n        cm.curOp.forceUpdate = true;\n      }\n      return true;\n    });\n    return widget;\n  }\n\n  // LINE DATA STRUCTURE\n\n  // Line objects. These hold state related to a line, including\n  // highlighting info (the styles array).\n  var Line = CodeMirror.Line = function(text, markedSpans, estimateHeight) {\n    this.text = text;\n    attachMarkedSpans(this, markedSpans);\n    this.height = estimateHeight ? estimateHeight(this) : 1;\n  };\n  eventMixin(Line);\n  Line.prototype.lineNo = function() { return lineNo(this); };\n\n  // Change the content (text, markers) of a line. Automatically\n  // invalidates cached information and tries to re-estimate the\n  // line's height.\n  function updateLine(line, text, markedSpans, estimateHeight) {\n    line.text = text;\n    if (line.stateAfter) line.stateAfter = null;\n    if (line.styles) line.styles = null;\n    if (line.order != null) line.order = null;\n    detachMarkedSpans(line);\n    attachMarkedSpans(line, markedSpans);\n    var estHeight = estimateHeight ? estimateHeight(line) : 1;\n    if (estHeight != line.height) updateLineHeight(line, estHeight);\n  }\n\n  // Detach a line from the document tree and its markers.\n  function cleanUpLine(line) {\n    line.parent = null;\n    detachMarkedSpans(line);\n  }\n\n  function extractLineClasses(type, output) {\n    if (type) for (;;) {\n      var lineClass = type.match(/(?:^|\\s+)line-(background-)?(\\S+)/);\n      if (!lineClass) break;\n      type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length);\n      var prop = lineClass[1] ? \"bgClass\" : \"textClass\";\n      if (output[prop] == null)\n        output[prop] = lineClass[2];\n      else if (!(new RegExp(\"(?:^|\\s)\" + lineClass[2] + \"(?:$|\\s)\")).test(output[prop]))\n        output[prop] += \" \" + lineClass[2];\n    }\n    return type;\n  }\n\n  function callBlankLine(mode, state) {\n    if (mode.blankLine) return mode.blankLine(state);\n    if (!mode.innerMode) return;\n    var inner = CodeMirror.innerMode(mode, state);\n    if (inner.mode.blankLine) return inner.mode.blankLine(inner.state);\n  }\n\n  function readToken(mode, stream, state) {\n    for (var i = 0; i < 10; i++) {\n      var style = mode.token(stream, state);\n      if (stream.pos > stream.start) return style;\n    }\n    throw new Error(\"Mode \" + mode.name + \" failed to advance stream.\");\n  }\n\n  // Run the given mode's parser over a line, calling f for each token.\n  function runMode(cm, text, mode, state, f, lineClasses, forceToEnd) {\n    var flattenSpans = mode.flattenSpans;\n    if (flattenSpans == null) flattenSpans = cm.options.flattenSpans;\n    var curStart = 0, curStyle = null;\n    var stream = new StringStream(text, cm.options.tabSize), style;\n    if (text == \"\") extractLineClasses(callBlankLine(mode, state), lineClasses);\n    while (!stream.eol()) {\n      if (stream.pos > cm.options.maxHighlightLength) {\n        flattenSpans = false;\n        if (forceToEnd) processLine(cm, text, state, stream.pos);\n        stream.pos = text.length;\n        style = null;\n      } else {\n        style = extractLineClasses(readToken(mode, stream, state), lineClasses);\n      }\n      if (cm.options.addModeClass) {\n        var mName = CodeMirror.innerMode(mode, state).mode.name;\n        if (mName) style = \"m-\" + (style ? mName + \" \" + style : mName);\n      }\n      if (!flattenSpans || curStyle != style) {\n        if (curStart < stream.start) f(stream.start, curStyle);\n        curStart = stream.start; curStyle = style;\n      }\n      stream.start = stream.pos;\n    }\n    while (curStart < stream.pos) {\n      // Webkit seems to refuse to render text nodes longer than 57444 characters\n      var pos = Math.min(stream.pos, curStart + 50000);\n      f(pos, curStyle);\n      curStart = pos;\n    }\n  }\n\n  // Compute a style array (an array starting with a mode generation\n  // -- for invalidation -- followed by pairs of end positions and\n  // style strings), which is used to highlight the tokens on the\n  // line.\n  function highlightLine(cm, line, state, forceToEnd) {\n    // A styles array always starts with a number identifying the\n    // mode/overlays that it is based on (for easy invalidation).\n    var st = [cm.state.modeGen], lineClasses = {};\n    // Compute the base array of styles\n    runMode(cm, line.text, cm.doc.mode, state, function(end, style) {\n      st.push(end, style);\n    }, lineClasses, forceToEnd);\n\n    // Run overlays, adjust style array.\n    for (var o = 0; o < cm.state.overlays.length; ++o) {\n      var overlay = cm.state.overlays[o], i = 1, at = 0;\n      runMode(cm, line.text, overlay.mode, true, function(end, style) {\n        var start = i;\n        // Ensure there's a token end at the current position, and that i points at it\n        while (at < end) {\n          var i_end = st[i];\n          if (i_end > end)\n            st.splice(i, 1, end, st[i+1], i_end);\n          i += 2;\n          at = Math.min(end, i_end);\n        }\n        if (!style) return;\n        if (overlay.opaque) {\n          st.splice(start, i - start, end, \"cm-overlay \" + style);\n          i = start + 2;\n        } else {\n          for (; start < i; start += 2) {\n            var cur = st[start+1];\n            st[start+1] = (cur ? cur + \" \" : \"\") + \"cm-overlay \" + style;\n          }\n        }\n      }, lineClasses);\n    }\n\n    return {styles: st, classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null};\n  }\n\n  function getLineStyles(cm, line) {\n    if (!line.styles || line.styles[0] != cm.state.modeGen) {\n      var result = highlightLine(cm, line, line.stateAfter = getStateBefore(cm, lineNo(line)));\n      line.styles = result.styles;\n      if (result.classes) line.styleClasses = result.classes;\n      else if (line.styleClasses) line.styleClasses = null;\n    }\n    return line.styles;\n  }\n\n  // Lightweight form of highlight -- proceed over this line and\n  // update state, but don't save a style array. Used for lines that\n  // aren't currently visible.\n  function processLine(cm, text, state, startAt) {\n    var mode = cm.doc.mode;\n    var stream = new StringStream(text, cm.options.tabSize);\n    stream.start = stream.pos = startAt || 0;\n    if (text == \"\") callBlankLine(mode, state);\n    while (!stream.eol() && stream.pos <= cm.options.maxHighlightLength) {\n      readToken(mode, stream, state);\n      stream.start = stream.pos;\n    }\n  }\n\n  // Convert a style as returned by a mode (either null, or a string\n  // containing one or more styles) to a CSS style. This is cached,\n  // and also looks for line-wide styles.\n  var styleToClassCache = {}, styleToClassCacheWithMode = {};\n  function interpretTokenStyle(style, options) {\n    if (!style || /^\\s*$/.test(style)) return null;\n    var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;\n    return cache[style] ||\n      (cache[style] = style.replace(/\\S+/g, \"cm-$&\"));\n  }\n\n  // Render the DOM representation of the text of a line. Also builds\n  // up a 'line map', which points at the DOM nodes that represent\n  // specific stretches of text, and is used by the measuring code.\n  // The returned object contains the DOM node, this map, and\n  // information about line-wide styles that were set by the mode.\n  function buildLineContent(cm, lineView) {\n    // The padding-right forces the element to have a 'border', which\n    // is needed on Webkit to be able to get line-level bounding\n    // rectangles for it (in measureChar).\n    var content = elt(\"span\", null, null, webkit ? \"padding-right: .1px\" : null);\n    var builder = {pre: elt(\"pre\", [content]), content: content, col: 0, pos: 0, cm: cm};\n    lineView.measure = {};\n\n    // Iterate over the logical lines that make up this visual line.\n    for (var i = 0; i <= (lineView.rest ? lineView.rest.length : 0); i++) {\n      var line = i ? lineView.rest[i - 1] : lineView.line, order;\n      builder.pos = 0;\n      builder.addToken = buildToken;\n      // Optionally wire in some hacks into the token-rendering\n      // algorithm, to deal with browser quirks.\n      if ((ie || webkit) && cm.getOption(\"lineWrapping\"))\n        builder.addToken = buildTokenSplitSpaces(builder.addToken);\n      if (hasBadBidiRects(cm.display.measure) && (order = getOrder(line)))\n        builder.addToken = buildTokenBadBidi(builder.addToken, order);\n      builder.map = [];\n      insertLineContent(line, builder, getLineStyles(cm, line));\n      if (line.styleClasses) {\n        if (line.styleClasses.bgClass)\n          builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || \"\");\n        if (line.styleClasses.textClass)\n          builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || \"\");\n      }\n\n      // Ensure at least a single node is present, for measuring.\n      if (builder.map.length == 0)\n        builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure)));\n\n      // Store the map and a cache object for the current logical line\n      if (i == 0) {\n        lineView.measure.map = builder.map;\n        lineView.measure.cache = {};\n      } else {\n        (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map);\n        (lineView.measure.caches || (lineView.measure.caches = [])).push({});\n      }\n    }\n\n    signal(cm, \"renderLine\", cm, lineView.line, builder.pre);\n    if (builder.pre.className)\n      builder.textClass = joinClasses(builder.pre.className, builder.textClass || \"\");\n    return builder;\n  }\n\n  function defaultSpecialCharPlaceholder(ch) {\n    var token = elt(\"span\", \"\\u2022\", \"cm-invalidchar\");\n    token.title = \"\\\\u\" + ch.charCodeAt(0).toString(16);\n    return token;\n  }\n\n  // Build up the DOM representation for a single token, and add it to\n  // the line map. Takes care to render special characters separately.\n  function buildToken(builder, text, style, startStyle, endStyle, title) {\n    if (!text) return;\n    var special = builder.cm.options.specialChars, mustWrap = false;\n    if (!special.test(text)) {\n      builder.col += text.length;\n      var content = document.createTextNode(text);\n      builder.map.push(builder.pos, builder.pos + text.length, content);\n      if (ie && ie_version < 9) mustWrap = true;\n      builder.pos += text.length;\n    } else {\n      var content = document.createDocumentFragment(), pos = 0;\n      while (true) {\n        special.lastIndex = pos;\n        var m = special.exec(text);\n        var skipped = m ? m.index - pos : text.length - pos;\n        if (skipped) {\n          var txt = document.createTextNode(text.slice(pos, pos + skipped));\n          if (ie && ie_version < 9) content.appendChild(elt(\"span\", [txt]));\n          else content.appendChild(txt);\n          builder.map.push(builder.pos, builder.pos + skipped, txt);\n          builder.col += skipped;\n          builder.pos += skipped;\n        }\n        if (!m) break;\n        pos += skipped + 1;\n        if (m[0] == \"\\t\") {\n          var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;\n          var txt = content.appendChild(elt(\"span\", spaceStr(tabWidth), \"cm-tab\"));\n          builder.col += tabWidth;\n        } else {\n          var txt = builder.cm.options.specialCharPlaceholder(m[0]);\n          if (ie && ie_version < 9) content.appendChild(elt(\"span\", [txt]));\n          else content.appendChild(txt);\n          builder.col += 1;\n        }\n        builder.map.push(builder.pos, builder.pos + 1, txt);\n        builder.pos++;\n      }\n    }\n    if (style || startStyle || endStyle || mustWrap) {\n      var fullStyle = style || \"\";\n      if (startStyle) fullStyle += startStyle;\n      if (endStyle) fullStyle += endStyle;\n      var token = elt(\"span\", [content], fullStyle);\n      if (title) token.title = title;\n      return builder.content.appendChild(token);\n    }\n    builder.content.appendChild(content);\n  }\n\n  function buildTokenSplitSpaces(inner) {\n    function split(old) {\n      var out = \" \";\n      for (var i = 0; i < old.length - 2; ++i) out += i % 2 ? \" \" : \"\\u00a0\";\n      out += \" \";\n      return out;\n    }\n    return function(builder, text, style, startStyle, endStyle, title) {\n      inner(builder, text.replace(/ {3,}/g, split), style, startStyle, endStyle, title);\n    };\n  }\n\n  // Work around nonsense dimensions being reported for stretches of\n  // right-to-left text.\n  function buildTokenBadBidi(inner, order) {\n    return function(builder, text, style, startStyle, endStyle, title) {\n      style = style ? style + \" cm-force-border\" : \"cm-force-border\";\n      var start = builder.pos, end = start + text.length;\n      for (;;) {\n        // Find the part that overlaps with the start of this text\n        for (var i = 0; i < order.length; i++) {\n          var part = order[i];\n          if (part.to > start && part.from <= start) break;\n        }\n        if (part.to >= end) return inner(builder, text, style, startStyle, endStyle, title);\n        inner(builder, text.slice(0, part.to - start), style, startStyle, null, title);\n        startStyle = null;\n        text = text.slice(part.to - start);\n        start = part.to;\n      }\n    };\n  }\n\n  function buildCollapsedSpan(builder, size, marker, ignoreWidget) {\n    var widget = !ignoreWidget && marker.widgetNode;\n    if (widget) {\n      builder.map.push(builder.pos, builder.pos + size, widget);\n      builder.content.appendChild(widget);\n    }\n    builder.pos += size;\n  }\n\n  // Outputs a number of spans to make up a line, taking highlighting\n  // and marked text into account.\n  function insertLineContent(line, builder, styles) {\n    var spans = line.markedSpans, allText = line.text, at = 0;\n    if (!spans) {\n      for (var i = 1; i < styles.length; i+=2)\n        builder.addToken(builder, allText.slice(at, at = styles[i]), interpretTokenStyle(styles[i+1], builder.cm.options));\n      return;\n    }\n\n    var len = allText.length, pos = 0, i = 1, text = \"\", style;\n    var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, title, collapsed;\n    for (;;) {\n      if (nextChange == pos) { // Update current marker set\n        spanStyle = spanEndStyle = spanStartStyle = title = \"\";\n        collapsed = null; nextChange = Infinity;\n        var foundBookmarks = [];\n        for (var j = 0; j < spans.length; ++j) {\n          var sp = spans[j], m = sp.marker;\n          if (sp.from <= pos && (sp.to == null || sp.to > pos)) {\n            if (sp.to != null && nextChange > sp.to) { nextChange = sp.to; spanEndStyle = \"\"; }\n            if (m.className) spanStyle += \" \" + m.className;\n            if (m.startStyle && sp.from == pos) spanStartStyle += \" \" + m.startStyle;\n            if (m.endStyle && sp.to == nextChange) spanEndStyle += \" \" + m.endStyle;\n            if (m.title && !title) title = m.title;\n            if (m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0))\n              collapsed = sp;\n          } else if (sp.from > pos && nextChange > sp.from) {\n            nextChange = sp.from;\n          }\n          if (m.type == \"bookmark\" && sp.from == pos && m.widgetNode) foundBookmarks.push(m);\n        }\n        if (collapsed && (collapsed.from || 0) == pos) {\n          buildCollapsedSpan(builder, (collapsed.to == null ? len + 1 : collapsed.to) - pos,\n                             collapsed.marker, collapsed.from == null);\n          if (collapsed.to == null) return;\n        }\n        if (!collapsed && foundBookmarks.length) for (var j = 0; j < foundBookmarks.length; ++j)\n          buildCollapsedSpan(builder, 0, foundBookmarks[j]);\n      }\n      if (pos >= len) break;\n\n      var upto = Math.min(len, nextChange);\n      while (true) {\n        if (text) {\n          var end = pos + text.length;\n          if (!collapsed) {\n            var tokenText = end > upto ? text.slice(0, upto - pos) : text;\n            builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle,\n                             spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : \"\", title);\n          }\n          if (end >= upto) {text = text.slice(upto - pos); pos = upto; break;}\n          pos = end;\n          spanStartStyle = \"\";\n        }\n        text = allText.slice(at, at = styles[i++]);\n        style = interpretTokenStyle(styles[i++], builder.cm.options);\n      }\n    }\n  }\n\n  // DOCUMENT DATA STRUCTURE\n\n  // By default, updates that start and end at the beginning of a line\n  // are treated specially, in order to make the association of line\n  // widgets and marker elements with the text behave more intuitive.\n  function isWholeLineUpdate(doc, change) {\n    return change.from.ch == 0 && change.to.ch == 0 && lst(change.text) == \"\" &&\n      (!doc.cm || doc.cm.options.wholeLineUpdateBefore);\n  }\n\n  // Perform a change on the document data structure.\n  function updateDoc(doc, change, markedSpans, estimateHeight) {\n    function spansFor(n) {return markedSpans ? markedSpans[n] : null;}\n    function update(line, text, spans) {\n      updateLine(line, text, spans, estimateHeight);\n      signalLater(line, \"change\", line, change);\n    }\n\n    var from = change.from, to = change.to, text = change.text;\n    var firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line);\n    var lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line;\n\n    // Adjust the line structure\n    if (isWholeLineUpdate(doc, change)) {\n      // This is a whole-line replace. Treated specially to make\n      // sure line objects move the way they are supposed to.\n      for (var i = 0, added = []; i < text.length - 1; ++i)\n        added.push(new Line(text[i], spansFor(i), estimateHeight));\n      update(lastLine, lastLine.text, lastSpans);\n      if (nlines) doc.remove(from.line, nlines);\n      if (added.length) doc.insert(from.line, added);\n    } else if (firstLine == lastLine) {\n      if (text.length == 1) {\n        update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);\n      } else {\n        for (var added = [], i = 1; i < text.length - 1; ++i)\n          added.push(new Line(text[i], spansFor(i), estimateHeight));\n        added.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight));\n        update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));\n        doc.insert(from.line + 1, added);\n      }\n    } else if (text.length == 1) {\n      update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));\n      doc.remove(from.line + 1, nlines);\n    } else {\n      update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));\n      update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);\n      for (var i = 1, added = []; i < text.length - 1; ++i)\n        added.push(new Line(text[i], spansFor(i), estimateHeight));\n      if (nlines > 1) doc.remove(from.line + 1, nlines - 1);\n      doc.insert(from.line + 1, added);\n    }\n\n    signalLater(doc, \"change\", doc, change);\n  }\n\n  // The document is represented as a BTree consisting of leaves, with\n  // chunk of lines in them, and branches, with up to ten leaves or\n  // other branch nodes below them. The top node is always a branch\n  // node, and is the document object itself (meaning it has\n  // additional methods and properties).\n  //\n  // All nodes have parent links. The tree is used both to go from\n  // line numbers to line objects, and to go from objects to numbers.\n  // It also indexes by height, and is used to convert between height\n  // and line object, and to find the total height of the document.\n  //\n  // See also http://marijnhaverbeke.nl/blog/codemirror-line-tree.html\n\n  function LeafChunk(lines) {\n    this.lines = lines;\n    this.parent = null;\n    for (var i = 0, height = 0; i < lines.length; ++i) {\n      lines[i].parent = this;\n      height += lines[i].height;\n    }\n    this.height = height;\n  }\n\n  LeafChunk.prototype = {\n    chunkSize: function() { return this.lines.length; },\n    // Remove the n lines at offset 'at'.\n    removeInner: function(at, n) {\n      for (var i = at, e = at + n; i < e; ++i) {\n        var line = this.lines[i];\n        this.height -= line.height;\n        cleanUpLine(line);\n        signalLater(line, \"delete\");\n      }\n      this.lines.splice(at, n);\n    },\n    // Helper used to collapse a small branch into a single leaf.\n    collapse: function(lines) {\n      lines.push.apply(lines, this.lines);\n    },\n    // Insert the given array of lines at offset 'at', count them as\n    // having the given height.\n    insertInner: function(at, lines, height) {\n      this.height += height;\n      this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));\n      for (var i = 0; i < lines.length; ++i) lines[i].parent = this;\n    },\n    // Used to iterate over a part of the tree.\n    iterN: function(at, n, op) {\n      for (var e = at + n; at < e; ++at)\n        if (op(this.lines[at])) return true;\n    }\n  };\n\n  function BranchChunk(children) {\n    this.children = children;\n    var size = 0, height = 0;\n    for (var i = 0; i < children.length; ++i) {\n      var ch = children[i];\n      size += ch.chunkSize(); height += ch.height;\n      ch.parent = this;\n    }\n    this.size = size;\n    this.height = height;\n    this.parent = null;\n  }\n\n  BranchChunk.prototype = {\n    chunkSize: function() { return this.size; },\n    removeInner: function(at, n) {\n      this.size -= n;\n      for (var i = 0; i < this.children.length; ++i) {\n        var child = this.children[i], sz = child.chunkSize();\n        if (at < sz) {\n          var rm = Math.min(n, sz - at), oldHeight = child.height;\n          child.removeInner(at, rm);\n          this.height -= oldHeight - child.height;\n          if (sz == rm) { this.children.splice(i--, 1); child.parent = null; }\n          if ((n -= rm) == 0) break;\n          at = 0;\n        } else at -= sz;\n      }\n      // If the result is smaller than 25 lines, ensure that it is a\n      // single leaf node.\n      if (this.size - n < 25 &&\n          (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {\n        var lines = [];\n        this.collapse(lines);\n        this.children = [new LeafChunk(lines)];\n        this.children[0].parent = this;\n      }\n    },\n    collapse: function(lines) {\n      for (var i = 0; i < this.children.length; ++i) this.children[i].collapse(lines);\n    },\n    insertInner: function(at, lines, height) {\n      this.size += lines.length;\n      this.height += height;\n      for (var i = 0; i < this.children.length; ++i) {\n        var child = this.children[i], sz = child.chunkSize();\n        if (at <= sz) {\n          child.insertInner(at, lines, height);\n          if (child.lines && child.lines.length > 50) {\n            while (child.lines.length > 50) {\n              var spilled = child.lines.splice(child.lines.length - 25, 25);\n              var newleaf = new LeafChunk(spilled);\n              child.height -= newleaf.height;\n              this.children.splice(i + 1, 0, newleaf);\n              newleaf.parent = this;\n            }\n            this.maybeSpill();\n          }\n          break;\n        }\n        at -= sz;\n      }\n    },\n    // When a node has grown, check whether it should be split.\n    maybeSpill: function() {\n      if (this.children.length <= 10) return;\n      var me = this;\n      do {\n        var spilled = me.children.splice(me.children.length - 5, 5);\n        var sibling = new BranchChunk(spilled);\n        if (!me.parent) { // Become the parent node\n          var copy = new BranchChunk(me.children);\n          copy.parent = me;\n          me.children = [copy, sibling];\n          me = copy;\n        } else {\n          me.size -= sibling.size;\n          me.height -= sibling.height;\n          var myIndex = indexOf(me.parent.children, me);\n          me.parent.children.splice(myIndex + 1, 0, sibling);\n        }\n        sibling.parent = me.parent;\n      } while (me.children.length > 10);\n      me.parent.maybeSpill();\n    },\n    iterN: function(at, n, op) {\n      for (var i = 0; i < this.children.length; ++i) {\n        var child = this.children[i], sz = child.chunkSize();\n        if (at < sz) {\n          var used = Math.min(n, sz - at);\n          if (child.iterN(at, used, op)) return true;\n          if ((n -= used) == 0) break;\n          at = 0;\n        } else at -= sz;\n      }\n    }\n  };\n\n  var nextDocId = 0;\n  var Doc = CodeMirror.Doc = function(text, mode, firstLine) {\n    if (!(this instanceof Doc)) return new Doc(text, mode, firstLine);\n    if (firstLine == null) firstLine = 0;\n\n    BranchChunk.call(this, [new LeafChunk([new Line(\"\", null)])]);\n    this.first = firstLine;\n    this.scrollTop = this.scrollLeft = 0;\n    this.cantEdit = false;\n    this.cleanGeneration = 1;\n    this.frontier = firstLine;\n    var start = Pos(firstLine, 0);\n    this.sel = simpleSelection(start);\n    this.history = new History(null);\n    this.id = ++nextDocId;\n    this.modeOption = mode;\n\n    if (typeof text == \"string\") text = splitLines(text);\n    updateDoc(this, {from: start, to: start, text: text});\n    setSelection(this, simpleSelection(start), sel_dontScroll);\n  };\n\n  Doc.prototype = createObj(BranchChunk.prototype, {\n    constructor: Doc,\n    // Iterate over the document. Supports two forms -- with only one\n    // argument, it calls that for each line in the document. With\n    // three, it iterates over the range given by the first two (with\n    // the second being non-inclusive).\n    iter: function(from, to, op) {\n      if (op) this.iterN(from - this.first, to - from, op);\n      else this.iterN(this.first, this.first + this.size, from);\n    },\n\n    // Non-public interface for adding and removing lines.\n    insert: function(at, lines) {\n      var height = 0;\n      for (var i = 0; i < lines.length; ++i) height += lines[i].height;\n      this.insertInner(at - this.first, lines, height);\n    },\n    remove: function(at, n) { this.removeInner(at - this.first, n); },\n\n    // From here, the methods are part of the public interface. Most\n    // are also available from CodeMirror (editor) instances.\n\n    getValue: function(lineSep) {\n      var lines = getLines(this, this.first, this.first + this.size);\n      if (lineSep === false) return lines;\n      return lines.join(lineSep || \"\\n\");\n    },\n    setValue: docMethodOp(function(code) {\n      var top = Pos(this.first, 0), last = this.first + this.size - 1;\n      makeChange(this, {from: top, to: Pos(last, getLine(this, last).text.length),\n                        text: splitLines(code), origin: \"setValue\"}, true);\n      setSelection(this, simpleSelection(top));\n    }),\n    replaceRange: function(code, from, to, origin) {\n      from = clipPos(this, from);\n      to = to ? clipPos(this, to) : from;\n      replaceRange(this, code, from, to, origin);\n    },\n    getRange: function(from, to, lineSep) {\n      var lines = getBetween(this, clipPos(this, from), clipPos(this, to));\n      if (lineSep === false) return lines;\n      return lines.join(lineSep || \"\\n\");\n    },\n\n    getLine: function(line) {var l = this.getLineHandle(line); return l && l.text;},\n\n    getLineHandle: function(line) {if (isLine(this, line)) return getLine(this, line);},\n    getLineNumber: function(line) {return lineNo(line);},\n\n    getLineHandleVisualStart: function(line) {\n      if (typeof line == \"number\") line = getLine(this, line);\n      return visualLine(line);\n    },\n\n    lineCount: function() {return this.size;},\n    firstLine: function() {return this.first;},\n    lastLine: function() {return this.first + this.size - 1;},\n\n    clipPos: function(pos) {return clipPos(this, pos);},\n\n    getCursor: function(start) {\n      var range = this.sel.primary(), pos;\n      if (start == null || start == \"head\") pos = range.head;\n      else if (start == \"anchor\") pos = range.anchor;\n      else if (start == \"end\" || start == \"to\" || start === false) pos = range.to();\n      else pos = range.from();\n      return pos;\n    },\n    listSelections: function() { return this.sel.ranges; },\n    somethingSelected: function() {return this.sel.somethingSelected();},\n\n    setCursor: docMethodOp(function(line, ch, options) {\n      setSimpleSelection(this, clipPos(this, typeof line == \"number\" ? Pos(line, ch || 0) : line), null, options);\n    }),\n    setSelection: docMethodOp(function(anchor, head, options) {\n      setSimpleSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), options);\n    }),\n    extendSelection: docMethodOp(function(head, other, options) {\n      extendSelection(this, clipPos(this, head), other && clipPos(this, other), options);\n    }),\n    extendSelections: docMethodOp(function(heads, options) {\n      extendSelections(this, clipPosArray(this, heads, options));\n    }),\n    extendSelectionsBy: docMethodOp(function(f, options) {\n      extendSelections(this, map(this.sel.ranges, f), options);\n    }),\n    setSelections: docMethodOp(function(ranges, primary, options) {\n      if (!ranges.length) return;\n      for (var i = 0, out = []; i < ranges.length; i++)\n        out[i] = new Range(clipPos(this, ranges[i].anchor),\n                           clipPos(this, ranges[i].head));\n      if (primary == null) primary = Math.min(ranges.length - 1, this.sel.primIndex);\n      setSelection(this, normalizeSelection(out, primary), options);\n    }),\n    addSelection: docMethodOp(function(anchor, head, options) {\n      var ranges = this.sel.ranges.slice(0);\n      ranges.push(new Range(clipPos(this, anchor), clipPos(this, head || anchor)));\n      setSelection(this, normalizeSelection(ranges, ranges.length - 1), options);\n    }),\n\n    getSelection: function(lineSep) {\n      var ranges = this.sel.ranges, lines;\n      for (var i = 0; i < ranges.length; i++) {\n        var sel = getBetween(this, ranges[i].from(), ranges[i].to());\n        lines = lines ? lines.concat(sel) : sel;\n      }\n      if (lineSep === false) return lines;\n      else return lines.join(lineSep || \"\\n\");\n    },\n    getSelections: function(lineSep) {\n      var parts = [], ranges = this.sel.ranges;\n      for (var i = 0; i < ranges.length; i++) {\n        var sel = getBetween(this, ranges[i].from(), ranges[i].to());\n        if (lineSep !== false) sel = sel.join(lineSep || \"\\n\");\n        parts[i] = sel;\n      }\n      return parts;\n    },\n    replaceSelection: function(code, collapse, origin) {\n      var dup = [];\n      for (var i = 0; i < this.sel.ranges.length; i++)\n        dup[i] = code;\n      this.replaceSelections(dup, collapse, origin || \"+input\");\n    },\n    replaceSelections: docMethodOp(function(code, collapse, origin) {\n      var changes = [], sel = this.sel;\n      for (var i = 0; i < sel.ranges.length; i++) {\n        var range = sel.ranges[i];\n        changes[i] = {from: range.from(), to: range.to(), text: splitLines(code[i]), origin: origin};\n      }\n      var newSel = collapse && collapse != \"end\" && computeReplacedSel(this, changes, collapse);\n      for (var i = changes.length - 1; i >= 0; i--)\n        makeChange(this, changes[i]);\n      if (newSel) setSelectionReplaceHistory(this, newSel);\n      else if (this.cm) ensureCursorVisible(this.cm);\n    }),\n    undo: docMethodOp(function() {makeChangeFromHistory(this, \"undo\");}),\n    redo: docMethodOp(function() {makeChangeFromHistory(this, \"redo\");}),\n    undoSelection: docMethodOp(function() {makeChangeFromHistory(this, \"undo\", true);}),\n    redoSelection: docMethodOp(function() {makeChangeFromHistory(this, \"redo\", true);}),\n\n    setExtending: function(val) {this.extend = val;},\n    getExtending: function() {return this.extend;},\n\n    historySize: function() {\n      var hist = this.history, done = 0, undone = 0;\n      for (var i = 0; i < hist.done.length; i++) if (!hist.done[i].ranges) ++done;\n      for (var i = 0; i < hist.undone.length; i++) if (!hist.undone[i].ranges) ++undone;\n      return {undo: done, redo: undone};\n    },\n    clearHistory: function() {this.history = new History(this.history.maxGeneration);},\n\n    markClean: function() {\n      this.cleanGeneration = this.changeGeneration(true);\n    },\n    changeGeneration: function(forceSplit) {\n      if (forceSplit)\n        this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null;\n      return this.history.generation;\n    },\n    isClean: function (gen) {\n      return this.history.generation == (gen || this.cleanGeneration);\n    },\n\n    getHistory: function() {\n      return {done: copyHistoryArray(this.history.done),\n              undone: copyHistoryArray(this.history.undone)};\n    },\n    setHistory: function(histData) {\n      var hist = this.history = new History(this.history.maxGeneration);\n      hist.done = copyHistoryArray(histData.done.slice(0), null, true);\n      hist.undone = copyHistoryArray(histData.undone.slice(0), null, true);\n    },\n\n    addLineClass: docMethodOp(function(handle, where, cls) {\n      return changeLine(this, handle, \"class\", function(line) {\n        var prop = where == \"text\" ? \"textClass\" : where == \"background\" ? \"bgClass\" : \"wrapClass\";\n        if (!line[prop]) line[prop] = cls;\n        else if (new RegExp(\"(?:^|\\\\s)\" + cls + \"(?:$|\\\\s)\").test(line[prop])) return false;\n        else line[prop] += \" \" + cls;\n        return true;\n      });\n    }),\n    removeLineClass: docMethodOp(function(handle, where, cls) {\n      return changeLine(this, handle, \"class\", function(line) {\n        var prop = where == \"text\" ? \"textClass\" : where == \"background\" ? \"bgClass\" : \"wrapClass\";\n        var cur = line[prop];\n        if (!cur) return false;\n        else if (cls == null) line[prop] = null;\n        else {\n          var found = cur.match(new RegExp(\"(?:^|\\\\s+)\" + cls + \"(?:$|\\\\s+)\"));\n          if (!found) return false;\n          var end = found.index + found[0].length;\n          line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? \"\" : \" \") + cur.slice(end) || null;\n        }\n        return true;\n      });\n    }),\n\n    markText: function(from, to, options) {\n      return markText(this, clipPos(this, from), clipPos(this, to), options, \"range\");\n    },\n    setBookmark: function(pos, options) {\n      var realOpts = {replacedWith: options && (options.nodeType == null ? options.widget : options),\n                      insertLeft: options && options.insertLeft,\n                      clearWhenEmpty: false, shared: options && options.shared};\n      pos = clipPos(this, pos);\n      return markText(this, pos, pos, realOpts, \"bookmark\");\n    },\n    findMarksAt: function(pos) {\n      pos = clipPos(this, pos);\n      var markers = [], spans = getLine(this, pos.line).markedSpans;\n      if (spans) for (var i = 0; i < spans.length; ++i) {\n        var span = spans[i];\n        if ((span.from == null || span.from <= pos.ch) &&\n            (span.to == null || span.to >= pos.ch))\n          markers.push(span.marker.parent || span.marker);\n      }\n      return markers;\n    },\n    findMarks: function(from, to, filter) {\n      from = clipPos(this, from); to = clipPos(this, to);\n      var found = [], lineNo = from.line;\n      this.iter(from.line, to.line + 1, function(line) {\n        var spans = line.markedSpans;\n        if (spans) for (var i = 0; i < spans.length; i++) {\n          var span = spans[i];\n          if (!(lineNo == from.line && from.ch > span.to ||\n                span.from == null && lineNo != from.line||\n                lineNo == to.line && span.from > to.ch) &&\n              (!filter || filter(span.marker)))\n            found.push(span.marker.parent || span.marker);\n        }\n        ++lineNo;\n      });\n      return found;\n    },\n    getAllMarks: function() {\n      var markers = [];\n      this.iter(function(line) {\n        var sps = line.markedSpans;\n        if (sps) for (var i = 0; i < sps.length; ++i)\n          if (sps[i].from != null) markers.push(sps[i].marker);\n      });\n      return markers;\n    },\n\n    posFromIndex: function(off) {\n      var ch, lineNo = this.first;\n      this.iter(function(line) {\n        var sz = line.text.length + 1;\n        if (sz > off) { ch = off; return true; }\n        off -= sz;\n        ++lineNo;\n      });\n      return clipPos(this, Pos(lineNo, ch));\n    },\n    indexFromPos: function (coords) {\n      coords = clipPos(this, coords);\n      var index = coords.ch;\n      if (coords.line < this.first || coords.ch < 0) return 0;\n      this.iter(this.first, coords.line, function (line) {\n        index += line.text.length + 1;\n      });\n      return index;\n    },\n\n    copy: function(copyHistory) {\n      var doc = new Doc(getLines(this, this.first, this.first + this.size), this.modeOption, this.first);\n      doc.scrollTop = this.scrollTop; doc.scrollLeft = this.scrollLeft;\n      doc.sel = this.sel;\n      doc.extend = false;\n      if (copyHistory) {\n        doc.history.undoDepth = this.history.undoDepth;\n        doc.setHistory(this.getHistory());\n      }\n      return doc;\n    },\n\n    linkedDoc: function(options) {\n      if (!options) options = {};\n      var from = this.first, to = this.first + this.size;\n      if (options.from != null && options.from > from) from = options.from;\n      if (options.to != null && options.to < to) to = options.to;\n      var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from);\n      if (options.sharedHist) copy.history = this.history;\n      (this.linked || (this.linked = [])).push({doc: copy, sharedHist: options.sharedHist});\n      copy.linked = [{doc: this, isParent: true, sharedHist: options.sharedHist}];\n      copySharedMarkers(copy, findSharedMarkers(this));\n      return copy;\n    },\n    unlinkDoc: function(other) {\n      if (other instanceof CodeMirror) other = other.doc;\n      if (this.linked) for (var i = 0; i < this.linked.length; ++i) {\n        var link = this.linked[i];\n        if (link.doc != other) continue;\n        this.linked.splice(i, 1);\n        other.unlinkDoc(this);\n        detachSharedMarkers(findSharedMarkers(this));\n        break;\n      }\n      // If the histories were shared, split them again\n      if (other.history == this.history) {\n        var splitIds = [other.id];\n        linkedDocs(other, function(doc) {splitIds.push(doc.id);}, true);\n        other.history = new History(null);\n        other.history.done = copyHistoryArray(this.history.done, splitIds);\n        other.history.undone = copyHistoryArray(this.history.undone, splitIds);\n      }\n    },\n    iterLinkedDocs: function(f) {linkedDocs(this, f);},\n\n    getMode: function() {return this.mode;},\n    getEditor: function() {return this.cm;}\n  });\n\n  // Public alias.\n  Doc.prototype.eachLine = Doc.prototype.iter;\n\n  // Set up methods on CodeMirror's prototype to redirect to the editor's document.\n  var dontDelegate = \"iter insert remove copy getEditor\".split(\" \");\n  for (var prop in Doc.prototype) if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0)\n    CodeMirror.prototype[prop] = (function(method) {\n      return function() {return method.apply(this.doc, arguments);};\n    })(Doc.prototype[prop]);\n\n  eventMixin(Doc);\n\n  // Call f for all linked documents.\n  function linkedDocs(doc, f, sharedHistOnly) {\n    function propagate(doc, skip, sharedHist) {\n      if (doc.linked) for (var i = 0; i < doc.linked.length; ++i) {\n        var rel = doc.linked[i];\n        if (rel.doc == skip) continue;\n        var shared = sharedHist && rel.sharedHist;\n        if (sharedHistOnly && !shared) continue;\n        f(rel.doc, shared);\n        propagate(rel.doc, doc, shared);\n      }\n    }\n    propagate(doc, null, true);\n  }\n\n  // Attach a document to an editor.\n  function attachDoc(cm, doc) {\n    if (doc.cm) throw new Error(\"This document is already in use.\");\n    cm.doc = doc;\n    doc.cm = cm;\n    estimateLineHeights(cm);\n    loadMode(cm);\n    if (!cm.options.lineWrapping) findMaxLine(cm);\n    cm.options.mode = doc.modeOption;\n    regChange(cm);\n  }\n\n  // LINE UTILITIES\n\n  // Find the line object corresponding to the given line number.\n  function getLine(doc, n) {\n    n -= doc.first;\n    if (n < 0 || n >= doc.size) throw new Error(\"There is no line \" + (n + doc.first) + \" in the document.\");\n    for (var chunk = doc; !chunk.lines;) {\n      for (var i = 0;; ++i) {\n        var child = chunk.children[i], sz = child.chunkSize();\n        if (n < sz) { chunk = child; break; }\n        n -= sz;\n      }\n    }\n    return chunk.lines[n];\n  }\n\n  // Get the part of a document between two positions, as an array of\n  // strings.\n  function getBetween(doc, start, end) {\n    var out = [], n = start.line;\n    doc.iter(start.line, end.line + 1, function(line) {\n      var text = line.text;\n      if (n == end.line) text = text.slice(0, end.ch);\n      if (n == start.line) text = text.slice(start.ch);\n      out.push(text);\n      ++n;\n    });\n    return out;\n  }\n  // Get the lines between from and to, as array of strings.\n  function getLines(doc, from, to) {\n    var out = [];\n    doc.iter(from, to, function(line) { out.push(line.text); });\n    return out;\n  }\n\n  // Update the height of a line, propagating the height change\n  // upwards to parent nodes.\n  function updateLineHeight(line, height) {\n    var diff = height - line.height;\n    if (diff) for (var n = line; n; n = n.parent) n.height += diff;\n  }\n\n  // Given a line object, find its line number by walking up through\n  // its parent links.\n  function lineNo(line) {\n    if (line.parent == null) return null;\n    var cur = line.parent, no = indexOf(cur.lines, line);\n    for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {\n      for (var i = 0;; ++i) {\n        if (chunk.children[i] == cur) break;\n        no += chunk.children[i].chunkSize();\n      }\n    }\n    return no + cur.first;\n  }\n\n  // Find the line at the given vertical position, using the height\n  // information in the document tree.\n  function lineAtHeight(chunk, h) {\n    var n = chunk.first;\n    outer: do {\n      for (var i = 0; i < chunk.children.length; ++i) {\n        var child = chunk.children[i], ch = child.height;\n        if (h < ch) { chunk = child; continue outer; }\n        h -= ch;\n        n += child.chunkSize();\n      }\n      return n;\n    } while (!chunk.lines);\n    for (var i = 0; i < chunk.lines.length; ++i) {\n      var line = chunk.lines[i], lh = line.height;\n      if (h < lh) break;\n      h -= lh;\n    }\n    return n + i;\n  }\n\n\n  // Find the height above the given line.\n  function heightAtLine(lineObj) {\n    lineObj = visualLine(lineObj);\n\n    var h = 0, chunk = lineObj.parent;\n    for (var i = 0; i < chunk.lines.length; ++i) {\n      var line = chunk.lines[i];\n      if (line == lineObj) break;\n      else h += line.height;\n    }\n    for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {\n      for (var i = 0; i < p.children.length; ++i) {\n        var cur = p.children[i];\n        if (cur == chunk) break;\n        else h += cur.height;\n      }\n    }\n    return h;\n  }\n\n  // Get the bidi ordering for the given line (and cache it). Returns\n  // false for lines that are fully left-to-right, and an array of\n  // BidiSpan objects otherwise.\n  function getOrder(line) {\n    var order = line.order;\n    if (order == null) order = line.order = bidiOrdering(line.text);\n    return order;\n  }\n\n  // HISTORY\n\n  function History(startGen) {\n    // Arrays of change events and selections. Doing something adds an\n    // event to done and clears undo. Undoing moves events from done\n    // to undone, redoing moves them in the other direction.\n    this.done = []; this.undone = [];\n    this.undoDepth = Infinity;\n    // Used to track when changes can be merged into a single undo\n    // event\n    this.lastModTime = this.lastSelTime = 0;\n    this.lastOp = this.lastSelOp = null;\n    this.lastOrigin = this.lastSelOrigin = null;\n    // Used by the isClean() method\n    this.generation = this.maxGeneration = startGen || 1;\n  }\n\n  // Create a history change event from an updateDoc-style change\n  // object.\n  function historyChangeFromChange(doc, change) {\n    var histChange = {from: copyPos(change.from), to: changeEnd(change), text: getBetween(doc, change.from, change.to)};\n    attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);\n    linkedDocs(doc, function(doc) {attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);}, true);\n    return histChange;\n  }\n\n  // Pop all selection events off the end of a history array. Stop at\n  // a change event.\n  function clearSelectionEvents(array) {\n    while (array.length) {\n      var last = lst(array);\n      if (last.ranges) array.pop();\n      else break;\n    }\n  }\n\n  // Find the top change event in the history. Pop off selection\n  // events that are in the way.\n  function lastChangeEvent(hist, force) {\n    if (force) {\n      clearSelectionEvents(hist.done);\n      return lst(hist.done);\n    } else if (hist.done.length && !lst(hist.done).ranges) {\n      return lst(hist.done);\n    } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {\n      hist.done.pop();\n      return lst(hist.done);\n    }\n  }\n\n  // Register a change in the history. Merges changes that are within\n  // a single operation, ore are close together with an origin that\n  // allows merging (starting with \"+\") into a single event.\n  function addChangeToHistory(doc, change, selAfter, opId) {\n    var hist = doc.history;\n    hist.undone.length = 0;\n    var time = +new Date, cur;\n\n    if ((hist.lastOp == opId ||\n         hist.lastOrigin == change.origin && change.origin &&\n         ((change.origin.charAt(0) == \"+\" && doc.cm && hist.lastModTime > time - doc.cm.options.historyEventDelay) ||\n          change.origin.charAt(0) == \"*\")) &&\n        (cur = lastChangeEvent(hist, hist.lastOp == opId))) {\n      // Merge this change into the last event\n      var last = lst(cur.changes);\n      if (cmp(change.from, change.to) == 0 && cmp(change.from, last.to) == 0) {\n        // Optimized case for simple insertion -- don't want to add\n        // new changesets for every character typed\n        last.to = changeEnd(change);\n      } else {\n        // Add new sub-event\n        cur.changes.push(historyChangeFromChange(doc, change));\n      }\n    } else {\n      // Can not be merged, start a new event.\n      var before = lst(hist.done);\n      if (!before || !before.ranges)\n        pushSelectionToHistory(doc.sel, hist.done);\n      cur = {changes: [historyChangeFromChange(doc, change)],\n             generation: hist.generation};\n      hist.done.push(cur);\n      while (hist.done.length > hist.undoDepth) {\n        hist.done.shift();\n        if (!hist.done[0].ranges) hist.done.shift();\n      }\n    }\n    hist.done.push(selAfter);\n    hist.generation = ++hist.maxGeneration;\n    hist.lastModTime = hist.lastSelTime = time;\n    hist.lastOp = hist.lastSelOp = opId;\n    hist.lastOrigin = hist.lastSelOrigin = change.origin;\n\n    if (!last) signal(doc, \"historyAdded\");\n  }\n\n  function selectionEventCanBeMerged(doc, origin, prev, sel) {\n    var ch = origin.charAt(0);\n    return ch == \"*\" ||\n      ch == \"+\" &&\n      prev.ranges.length == sel.ranges.length &&\n      prev.somethingSelected() == sel.somethingSelected() &&\n      new Date - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500);\n  }\n\n  // Called whenever the selection changes, sets the new selection as\n  // the pending selection in the history, and pushes the old pending\n  // selection into the 'done' array when it was significantly\n  // different (in number of selected ranges, emptiness, or time).\n  function addSelectionToHistory(doc, sel, opId, options) {\n    var hist = doc.history, origin = options && options.origin;\n\n    // A new event is started when the previous origin does not match\n    // the current, or the origins don't allow matching. Origins\n    // starting with * are always merged, those starting with + are\n    // merged when similar and close together in time.\n    if (opId == hist.lastSelOp ||\n        (origin && hist.lastSelOrigin == origin &&\n         (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin ||\n          selectionEventCanBeMerged(doc, origin, lst(hist.done), sel))))\n      hist.done[hist.done.length - 1] = sel;\n    else\n      pushSelectionToHistory(sel, hist.done);\n\n    hist.lastSelTime = +new Date;\n    hist.lastSelOrigin = origin;\n    hist.lastSelOp = opId;\n    if (options && options.clearRedo !== false)\n      clearSelectionEvents(hist.undone);\n  }\n\n  function pushSelectionToHistory(sel, dest) {\n    var top = lst(dest);\n    if (!(top && top.ranges && top.equals(sel)))\n      dest.push(sel);\n  }\n\n  // Used to store marked span information in the history.\n  function attachLocalSpans(doc, change, from, to) {\n    var existing = change[\"spans_\" + doc.id], n = 0;\n    doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function(line) {\n      if (line.markedSpans)\n        (existing || (existing = change[\"spans_\" + doc.id] = {}))[n] = line.markedSpans;\n      ++n;\n    });\n  }\n\n  // When un/re-doing restores text containing marked spans, those\n  // that have been explicitly cleared should not be restored.\n  function removeClearedSpans(spans) {\n    if (!spans) return null;\n    for (var i = 0, out; i < spans.length; ++i) {\n      if (spans[i].marker.explicitlyCleared) { if (!out) out = spans.slice(0, i); }\n      else if (out) out.push(spans[i]);\n    }\n    return !out ? spans : out.length ? out : null;\n  }\n\n  // Retrieve and filter the old marked spans stored in a change event.\n  function getOldSpans(doc, change) {\n    var found = change[\"spans_\" + doc.id];\n    if (!found) return null;\n    for (var i = 0, nw = []; i < change.text.length; ++i)\n      nw.push(removeClearedSpans(found[i]));\n    return nw;\n  }\n\n  // Used both to provide a JSON-safe object in .getHistory, and, when\n  // detaching a document, to split the history in two\n  function copyHistoryArray(events, newGroup, instantiateSel) {\n    for (var i = 0, copy = []; i < events.length; ++i) {\n      var event = events[i];\n      if (event.ranges) {\n        copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event);\n        continue;\n      }\n      var changes = event.changes, newChanges = [];\n      copy.push({changes: newChanges});\n      for (var j = 0; j < changes.length; ++j) {\n        var change = changes[j], m;\n        newChanges.push({from: change.from, to: change.to, text: change.text});\n        if (newGroup) for (var prop in change) if (m = prop.match(/^spans_(\\d+)$/)) {\n          if (indexOf(newGroup, Number(m[1])) > -1) {\n            lst(newChanges)[prop] = change[prop];\n            delete change[prop];\n          }\n        }\n      }\n    }\n    return copy;\n  }\n\n  // Rebasing/resetting history to deal with externally-sourced changes\n\n  function rebaseHistSelSingle(pos, from, to, diff) {\n    if (to < pos.line) {\n      pos.line += diff;\n    } else if (from < pos.line) {\n      pos.line = from;\n      pos.ch = 0;\n    }\n  }\n\n  // Tries to rebase an array of history events given a change in the\n  // document. If the change touches the same lines as the event, the\n  // event, and everything 'behind' it, is discarded. If the change is\n  // before the event, the event's positions are updated. Uses a\n  // copy-on-write scheme for the positions, to avoid having to\n  // reallocate them all on every rebase, but also avoid problems with\n  // shared position objects being unsafely updated.\n  function rebaseHistArray(array, from, to, diff) {\n    for (var i = 0; i < array.length; ++i) {\n      var sub = array[i], ok = true;\n      if (sub.ranges) {\n        if (!sub.copied) { sub = array[i] = sub.deepCopy(); sub.copied = true; }\n        for (var j = 0; j < sub.ranges.length; j++) {\n          rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff);\n          rebaseHistSelSingle(sub.ranges[j].head, from, to, diff);\n        }\n        continue;\n      }\n      for (var j = 0; j < sub.changes.length; ++j) {\n        var cur = sub.changes[j];\n        if (to < cur.from.line) {\n          cur.from = Pos(cur.from.line + diff, cur.from.ch);\n          cur.to = Pos(cur.to.line + diff, cur.to.ch);\n        } else if (from <= cur.to.line) {\n          ok = false;\n          break;\n        }\n      }\n      if (!ok) {\n        array.splice(0, i + 1);\n        i = 0;\n      }\n    }\n  }\n\n  function rebaseHist(hist, change) {\n    var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1;\n    rebaseHistArray(hist.done, from, to, diff);\n    rebaseHistArray(hist.undone, from, to, diff);\n  }\n\n  // EVENT UTILITIES\n\n  // Due to the fact that we still support jurassic IE versions, some\n  // compatibility wrappers are needed.\n\n  var e_preventDefault = CodeMirror.e_preventDefault = function(e) {\n    if (e.preventDefault) e.preventDefault();\n    else e.returnValue = false;\n  };\n  var e_stopPropagation = CodeMirror.e_stopPropagation = function(e) {\n    if (e.stopPropagation) e.stopPropagation();\n    else e.cancelBubble = true;\n  };\n  function e_defaultPrevented(e) {\n    return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false;\n  }\n  var e_stop = CodeMirror.e_stop = function(e) {e_preventDefault(e); e_stopPropagation(e);};\n\n  function e_target(e) {return e.target || e.srcElement;}\n  function e_button(e) {\n    var b = e.which;\n    if (b == null) {\n      if (e.button & 1) b = 1;\n      else if (e.button & 2) b = 3;\n      else if (e.button & 4) b = 2;\n    }\n    if (mac && e.ctrlKey && b == 1) b = 3;\n    return b;\n  }\n\n  // EVENT HANDLING\n\n  // Lightweight event framework. on/off also work on DOM nodes,\n  // registering native DOM handlers.\n\n  var on = CodeMirror.on = function(emitter, type, f) {\n    if (emitter.addEventListener)\n      emitter.addEventListener(type, f, false);\n    else if (emitter.attachEvent)\n      emitter.attachEvent(\"on\" + type, f);\n    else {\n      var map = emitter._handlers || (emitter._handlers = {});\n      var arr = map[type] || (map[type] = []);\n      arr.push(f);\n    }\n  };\n\n  var off = CodeMirror.off = function(emitter, type, f) {\n    if (emitter.removeEventListener)\n      emitter.removeEventListener(type, f, false);\n    else if (emitter.detachEvent)\n      emitter.detachEvent(\"on\" + type, f);\n    else {\n      var arr = emitter._handlers && emitter._handlers[type];\n      if (!arr) return;\n      for (var i = 0; i < arr.length; ++i)\n        if (arr[i] == f) { arr.splice(i, 1); break; }\n    }\n  };\n\n  var signal = CodeMirror.signal = function(emitter, type /*, values...*/) {\n    var arr = emitter._handlers && emitter._handlers[type];\n    if (!arr) return;\n    var args = Array.prototype.slice.call(arguments, 2);\n    for (var i = 0; i < arr.length; ++i) arr[i].apply(null, args);\n  };\n\n  var orphanDelayedCallbacks = null;\n\n  // Often, we want to signal events at a point where we are in the\n  // middle of some work, but don't want the handler to start calling\n  // other methods on the editor, which might be in an inconsistent\n  // state or simply not expect any other events to happen.\n  // signalLater looks whether there are any handlers, and schedules\n  // them to be executed when the last operation ends, or, if no\n  // operation is active, when a timeout fires.\n  function signalLater(emitter, type /*, values...*/) {\n    var arr = emitter._handlers && emitter._handlers[type];\n    if (!arr) return;\n    var args = Array.prototype.slice.call(arguments, 2), list;\n    if (operationGroup) {\n      list = operationGroup.delayedCallbacks;\n    } else if (orphanDelayedCallbacks) {\n      list = orphanDelayedCallbacks;\n    } else {\n      list = orphanDelayedCallbacks = [];\n      setTimeout(fireOrphanDelayed, 0);\n    }\n    function bnd(f) {return function(){f.apply(null, args);};};\n    for (var i = 0; i < arr.length; ++i)\n      list.push(bnd(arr[i]));\n  }\n\n  function fireOrphanDelayed() {\n    var delayed = orphanDelayedCallbacks;\n    orphanDelayedCallbacks = null;\n    for (var i = 0; i < delayed.length; ++i) delayed[i]();\n  }\n\n  // The DOM events that CodeMirror handles can be overridden by\n  // registering a (non-DOM) handler on the editor for the event name,\n  // and preventDefault-ing the event in that handler.\n  function signalDOMEvent(cm, e, override) {\n    signal(cm, override || e.type, cm, e);\n    return e_defaultPrevented(e) || e.codemirrorIgnore;\n  }\n\n  function signalCursorActivity(cm) {\n    var arr = cm._handlers && cm._handlers.cursorActivity;\n    if (!arr) return;\n    var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []);\n    for (var i = 0; i < arr.length; ++i) if (indexOf(set, arr[i]) == -1)\n      set.push(arr[i]);\n  }\n\n  function hasHandler(emitter, type) {\n    var arr = emitter._handlers && emitter._handlers[type];\n    return arr && arr.length > 0;\n  }\n\n  // Add on and off methods to a constructor's prototype, to make\n  // registering events on such objects more convenient.\n  function eventMixin(ctor) {\n    ctor.prototype.on = function(type, f) {on(this, type, f);};\n    ctor.prototype.off = function(type, f) {off(this, type, f);};\n  }\n\n  // MISC UTILITIES\n\n  // Number of pixels added to scroller and sizer to hide scrollbar\n  var scrollerCutOff = 30;\n\n  // Returned or thrown by various protocols to signal 'I'm not\n  // handling this'.\n  var Pass = CodeMirror.Pass = {toString: function(){return \"CodeMirror.Pass\";}};\n\n  // Reused option objects for setSelection & friends\n  var sel_dontScroll = {scroll: false}, sel_mouse = {origin: \"*mouse\"}, sel_move = {origin: \"+move\"};\n\n  function Delayed() {this.id = null;}\n  Delayed.prototype.set = function(ms, f) {\n    clearTimeout(this.id);\n    this.id = setTimeout(f, ms);\n  };\n\n  // Counts the column offset in a string, taking tabs into account.\n  // Used mostly to find indentation.\n  var countColumn = CodeMirror.countColumn = function(string, end, tabSize, startIndex, startValue) {\n    if (end == null) {\n      end = string.search(/[^\\s\\u00a0]/);\n      if (end == -1) end = string.length;\n    }\n    for (var i = startIndex || 0, n = startValue || 0;;) {\n      var nextTab = string.indexOf(\"\\t\", i);\n      if (nextTab < 0 || nextTab >= end)\n        return n + (end - i);\n      n += nextTab - i;\n      n += tabSize - (n % tabSize);\n      i = nextTab + 1;\n    }\n  };\n\n  // The inverse of countColumn -- find the offset that corresponds to\n  // a particular column.\n  function findColumn(string, goal, tabSize) {\n    for (var pos = 0, col = 0;;) {\n      var nextTab = string.indexOf(\"\\t\", pos);\n      if (nextTab == -1) nextTab = string.length;\n      var skipped = nextTab - pos;\n      if (nextTab == string.length || col + skipped >= goal)\n        return pos + Math.min(skipped, goal - col);\n      col += nextTab - pos;\n      col += tabSize - (col % tabSize);\n      pos = nextTab + 1;\n      if (col >= goal) return pos;\n    }\n  }\n\n  var spaceStrs = [\"\"];\n  function spaceStr(n) {\n    while (spaceStrs.length <= n)\n      spaceStrs.push(lst(spaceStrs) + \" \");\n    return spaceStrs[n];\n  }\n\n  function lst(arr) { return arr[arr.length-1]; }\n\n  var selectInput = function(node) { node.select(); };\n  if (ios) // Mobile Safari apparently has a bug where select() is broken.\n    selectInput = function(node) { node.selectionStart = 0; node.selectionEnd = node.value.length; };\n  else if (ie) // Suppress mysterious IE10 errors\n    selectInput = function(node) { try { node.select(); } catch(_e) {} };\n\n  function indexOf(array, elt) {\n    for (var i = 0; i < array.length; ++i)\n      if (array[i] == elt) return i;\n    return -1;\n  }\n  if ([].indexOf) indexOf = function(array, elt) { return array.indexOf(elt); };\n  function map(array, f) {\n    var out = [];\n    for (var i = 0; i < array.length; i++) out[i] = f(array[i], i);\n    return out;\n  }\n  if ([].map) map = function(array, f) { return array.map(f); };\n\n  function createObj(base, props) {\n    var inst;\n    if (Object.create) {\n      inst = Object.create(base);\n    } else {\n      var ctor = function() {};\n      ctor.prototype = base;\n      inst = new ctor();\n    }\n    if (props) copyObj(props, inst);\n    return inst;\n  };\n\n  function copyObj(obj, target, overwrite) {\n    if (!target) target = {};\n    for (var prop in obj)\n      if (obj.hasOwnProperty(prop) && (overwrite !== false || !target.hasOwnProperty(prop)))\n        target[prop] = obj[prop];\n    return target;\n  }\n\n  function bind(f) {\n    var args = Array.prototype.slice.call(arguments, 1);\n    return function(){return f.apply(null, args);};\n  }\n\n  var nonASCIISingleCaseWordChar = /[\\u00df\\u0590-\\u05f4\\u0600-\\u06ff\\u3040-\\u309f\\u30a0-\\u30ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\uac00-\\ud7af]/;\n  var isWordCharBasic = CodeMirror.isWordChar = function(ch) {\n    return /\\w/.test(ch) || ch > \"\\x80\" &&\n      (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch));\n  };\n  function isWordChar(ch, helper) {\n    if (!helper) return isWordCharBasic(ch);\n    if (helper.source.indexOf(\"\\\\w\") > -1 && isWordCharBasic(ch)) return true;\n    return helper.test(ch);\n  }\n\n  function isEmpty(obj) {\n    for (var n in obj) if (obj.hasOwnProperty(n) && obj[n]) return false;\n    return true;\n  }\n\n  // Extending unicode characters. A series of a non-extending char +\n  // any number of extending chars is treated as a single unit as far\n  // as editing and measuring is concerned. This is not fully correct,\n  // since some scripts/fonts/browsers also treat other configurations\n  // of code points as a group.\n  var extendingChars = /[\\u0300-\\u036f\\u0483-\\u0489\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u065e\\u0670\\u06d6-\\u06dc\\u06de-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07eb-\\u07f3\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0900-\\u0902\\u093c\\u0941-\\u0948\\u094d\\u0951-\\u0955\\u0962\\u0963\\u0981\\u09bc\\u09be\\u09c1-\\u09c4\\u09cd\\u09d7\\u09e2\\u09e3\\u0a01\\u0a02\\u0a3c\\u0a41\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a70\\u0a71\\u0a75\\u0a81\\u0a82\\u0abc\\u0ac1-\\u0ac5\\u0ac7\\u0ac8\\u0acd\\u0ae2\\u0ae3\\u0b01\\u0b3c\\u0b3e\\u0b3f\\u0b41-\\u0b44\\u0b4d\\u0b56\\u0b57\\u0b62\\u0b63\\u0b82\\u0bbe\\u0bc0\\u0bcd\\u0bd7\\u0c3e-\\u0c40\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0cbc\\u0cbf\\u0cc2\\u0cc6\\u0ccc\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0d3e\\u0d41-\\u0d44\\u0d4d\\u0d57\\u0d62\\u0d63\\u0dca\\u0dcf\\u0dd2-\\u0dd4\\u0dd6\\u0ddf\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0eb1\\u0eb4-\\u0eb9\\u0ebb\\u0ebc\\u0ec8-\\u0ecd\\u0f18\\u0f19\\u0f35\\u0f37\\u0f39\\u0f71-\\u0f7e\\u0f80-\\u0f84\\u0f86\\u0f87\\u0f90-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102d-\\u1030\\u1032-\\u1037\\u1039\\u103a\\u103d\\u103e\\u1058\\u1059\\u105e-\\u1060\\u1071-\\u1074\\u1082\\u1085\\u1086\\u108d\\u109d\\u135f\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b7-\\u17bd\\u17c6\\u17c9-\\u17d3\\u17dd\\u180b-\\u180d\\u18a9\\u1920-\\u1922\\u1927\\u1928\\u1932\\u1939-\\u193b\\u1a17\\u1a18\\u1a56\\u1a58-\\u1a5e\\u1a60\\u1a62\\u1a65-\\u1a6c\\u1a73-\\u1a7c\\u1a7f\\u1b00-\\u1b03\\u1b34\\u1b36-\\u1b3a\\u1b3c\\u1b42\\u1b6b-\\u1b73\\u1b80\\u1b81\\u1ba2-\\u1ba5\\u1ba8\\u1ba9\\u1c2c-\\u1c33\\u1c36\\u1c37\\u1cd0-\\u1cd2\\u1cd4-\\u1ce0\\u1ce2-\\u1ce8\\u1ced\\u1dc0-\\u1de6\\u1dfd-\\u1dff\\u200c\\u200d\\u20d0-\\u20f0\\u2cef-\\u2cf1\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\ua66f-\\ua672\\ua67c\\ua67d\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua825\\ua826\\ua8c4\\ua8e0-\\ua8f1\\ua926-\\ua92d\\ua947-\\ua951\\ua980-\\ua982\\ua9b3\\ua9b6-\\ua9b9\\ua9bc\\uaa29-\\uaa2e\\uaa31\\uaa32\\uaa35\\uaa36\\uaa43\\uaa4c\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uabe5\\uabe8\\uabed\\udc00-\\udfff\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe26\\uff9e\\uff9f]/;\n  function isExtendingChar(ch) { return ch.charCodeAt(0) >= 768 && extendingChars.test(ch); }\n\n  // DOM UTILITIES\n\n  function elt(tag, content, className, style) {\n    var e = document.createElement(tag);\n    if (className) e.className = className;\n    if (style) e.style.cssText = style;\n    if (typeof content == \"string\") e.appendChild(document.createTextNode(content));\n    else if (content) for (var i = 0; i < content.length; ++i) e.appendChild(content[i]);\n    return e;\n  }\n\n  var range;\n  if (document.createRange) range = function(node, start, end) {\n    var r = document.createRange();\n    r.setEnd(node, end);\n    r.setStart(node, start);\n    return r;\n  };\n  else range = function(node, start, end) {\n    var r = document.body.createTextRange();\n    r.moveToElementText(node.parentNode);\n    r.collapse(true);\n    r.moveEnd(\"character\", end);\n    r.moveStart(\"character\", start);\n    return r;\n  };\n\n  function removeChildren(e) {\n    for (var count = e.childNodes.length; count > 0; --count)\n      e.removeChild(e.firstChild);\n    return e;\n  }\n\n  function removeChildrenAndAdd(parent, e) {\n    return removeChildren(parent).appendChild(e);\n  }\n\n  function contains(parent, child) {\n    if (parent.contains)\n      return parent.contains(child);\n    while (child = child.parentNode)\n      if (child == parent) return true;\n  }\n\n  function activeElt() { return document.activeElement; }\n  // Older versions of IE throws unspecified error when touching\n  // document.activeElement in some cases (during loading, in iframe)\n  if (ie && ie_version < 11) activeElt = function() {\n    try { return document.activeElement; }\n    catch(e) { return document.body; }\n  };\n\n  function classTest(cls) { return new RegExp(\"\\\\b\" + cls + \"\\\\b\\\\s*\"); }\n  function rmClass(node, cls) {\n    var test = classTest(cls);\n    if (test.test(node.className)) node.className = node.className.replace(test, \"\");\n  }\n  function addClass(node, cls) {\n    if (!classTest(cls).test(node.className)) node.className += \" \" + cls;\n  }\n  function joinClasses(a, b) {\n    var as = a.split(\" \");\n    for (var i = 0; i < as.length; i++)\n      if (as[i] && !classTest(as[i]).test(b)) b += \" \" + as[i];\n    return b;\n  }\n\n  // WINDOW-WIDE EVENTS\n\n  // These must be handled carefully, because naively registering a\n  // handler for each editor will cause the editors to never be\n  // garbage collected.\n\n  function forEachCodeMirror(f) {\n    if (!document.body.getElementsByClassName) return;\n    var byClass = document.body.getElementsByClassName(\"CodeMirror\");\n    for (var i = 0; i < byClass.length; i++) {\n      var cm = byClass[i].CodeMirror;\n      if (cm) f(cm);\n    }\n  }\n\n  var globalsRegistered = false;\n  function ensureGlobalHandlers() {\n    if (globalsRegistered) return;\n    registerGlobalHandlers();\n    globalsRegistered = true;\n  }\n  function registerGlobalHandlers() {\n    // When the window resizes, we need to refresh active editors.\n    var resizeTimer;\n    on(window, \"resize\", function() {\n      if (resizeTimer == null) resizeTimer = setTimeout(function() {\n        resizeTimer = null;\n        knownScrollbarWidth = null;\n        forEachCodeMirror(onResize);\n      }, 100);\n    });\n    // When the window loses focus, we want to show the editor as blurred\n    on(window, \"blur\", function() {\n      forEachCodeMirror(onBlur);\n    });\n  }\n\n  // FEATURE DETECTION\n\n  // Detect drag-and-drop\n  var dragAndDrop = function() {\n    // There is *some* kind of drag-and-drop support in IE6-8, but I\n    // couldn't get it to work yet.\n    if (ie && ie_version < 9) return false;\n    var div = elt('div');\n    return \"draggable\" in div || \"dragDrop\" in div;\n  }();\n\n  var knownScrollbarWidth;\n  function scrollbarWidth(measure) {\n    if (knownScrollbarWidth != null) return knownScrollbarWidth;\n    var test = elt(\"div\", null, null, \"width: 50px; height: 50px; overflow-x: scroll\");\n    removeChildrenAndAdd(measure, test);\n    if (test.offsetWidth)\n      knownScrollbarWidth = test.offsetHeight - test.clientHeight;\n    return knownScrollbarWidth || 0;\n  }\n\n  var zwspSupported;\n  function zeroWidthElement(measure) {\n    if (zwspSupported == null) {\n      var test = elt(\"span\", \"\\u200b\");\n      removeChildrenAndAdd(measure, elt(\"span\", [test, document.createTextNode(\"x\")]));\n      if (measure.firstChild.offsetHeight != 0)\n        zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !(ie && ie_version < 8);\n    }\n    if (zwspSupported) return elt(\"span\", \"\\u200b\");\n    else return elt(\"span\", \"\\u00a0\", null, \"display: inline-block; width: 1px; margin-right: -1px\");\n  }\n\n  // Feature-detect IE's crummy client rect reporting for bidi text\n  var badBidiRects;\n  function hasBadBidiRects(measure) {\n    if (badBidiRects != null) return badBidiRects;\n    var txt = removeChildrenAndAdd(measure, document.createTextNode(\"A\\u062eA\"));\n    var r0 = range(txt, 0, 1).getBoundingClientRect();\n    if (!r0 || r0.left == r0.right) return false; // Safari returns null in some cases (#2780)\n    var r1 = range(txt, 1, 2).getBoundingClientRect();\n    return badBidiRects = (r1.right - r0.right < 3);\n  }\n\n  // See if \"\".split is the broken IE version, if so, provide an\n  // alternative way to split lines.\n  var splitLines = CodeMirror.splitLines = \"\\n\\nb\".split(/\\n/).length != 3 ? function(string) {\n    var pos = 0, result = [], l = string.length;\n    while (pos <= l) {\n      var nl = string.indexOf(\"\\n\", pos);\n      if (nl == -1) nl = string.length;\n      var line = string.slice(pos, string.charAt(nl - 1) == \"\\r\" ? nl - 1 : nl);\n      var rt = line.indexOf(\"\\r\");\n      if (rt != -1) {\n        result.push(line.slice(0, rt));\n        pos += rt + 1;\n      } else {\n        result.push(line);\n        pos = nl + 1;\n      }\n    }\n    return result;\n  } : function(string){return string.split(/\\r\\n?|\\n/);};\n\n  var hasSelection = window.getSelection ? function(te) {\n    try { return te.selectionStart != te.selectionEnd; }\n    catch(e) { return false; }\n  } : function(te) {\n    try {var range = te.ownerDocument.selection.createRange();}\n    catch(e) {}\n    if (!range || range.parentElement() != te) return false;\n    return range.compareEndPoints(\"StartToEnd\", range) != 0;\n  };\n\n  var hasCopyEvent = (function() {\n    var e = elt(\"div\");\n    if (\"oncopy\" in e) return true;\n    e.setAttribute(\"oncopy\", \"return;\");\n    return typeof e.oncopy == \"function\";\n  })();\n\n  var badZoomedRects = null;\n  function hasBadZoomedRects(measure) {\n    if (badZoomedRects != null) return badZoomedRects;\n    var node = removeChildrenAndAdd(measure, elt(\"span\", \"x\"));\n    var normal = node.getBoundingClientRect();\n    var fromRange = range(node, 0, 1).getBoundingClientRect();\n    return badZoomedRects = Math.abs(normal.left - fromRange.left) > 1;\n  }\n\n  // KEY NAMES\n\n  var keyNames = {3: \"Enter\", 8: \"Backspace\", 9: \"Tab\", 13: \"Enter\", 16: \"Shift\", 17: \"Ctrl\", 18: \"Alt\",\n                  19: \"Pause\", 20: \"CapsLock\", 27: \"Esc\", 32: \"Space\", 33: \"PageUp\", 34: \"PageDown\", 35: \"End\",\n                  36: \"Home\", 37: \"Left\", 38: \"Up\", 39: \"Right\", 40: \"Down\", 44: \"PrintScrn\", 45: \"Insert\",\n                  46: \"Delete\", 59: \";\", 61: \"=\", 91: \"Mod\", 92: \"Mod\", 93: \"Mod\", 107: \"=\", 109: \"-\", 127: \"Delete\",\n                  173: \"-\", 186: \";\", 187: \"=\", 188: \",\", 189: \"-\", 190: \".\", 191: \"/\", 192: \"`\", 219: \"[\", 220: \"\\\\\",\n                  221: \"]\", 222: \"'\", 63232: \"Up\", 63233: \"Down\", 63234: \"Left\", 63235: \"Right\", 63272: \"Delete\",\n                  63273: \"Home\", 63275: \"End\", 63276: \"PageUp\", 63277: \"PageDown\", 63302: \"Insert\"};\n  CodeMirror.keyNames = keyNames;\n  (function() {\n    // Number keys\n    for (var i = 0; i < 10; i++) keyNames[i + 48] = keyNames[i + 96] = String(i);\n    // Alphabetic keys\n    for (var i = 65; i <= 90; i++) keyNames[i] = String.fromCharCode(i);\n    // Function keys\n    for (var i = 1; i <= 12; i++) keyNames[i + 111] = keyNames[i + 63235] = \"F\" + i;\n  })();\n\n  // BIDI HELPERS\n\n  function iterateBidiSections(order, from, to, f) {\n    if (!order) return f(from, to, \"ltr\");\n    var found = false;\n    for (var i = 0; i < order.length; ++i) {\n      var part = order[i];\n      if (part.from < to && part.to > from || from == to && part.to == from) {\n        f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? \"rtl\" : \"ltr\");\n        found = true;\n      }\n    }\n    if (!found) f(from, to, \"ltr\");\n  }\n\n  function bidiLeft(part) { return part.level % 2 ? part.to : part.from; }\n  function bidiRight(part) { return part.level % 2 ? part.from : part.to; }\n\n  function lineLeft(line) { var order = getOrder(line); return order ? bidiLeft(order[0]) : 0; }\n  function lineRight(line) {\n    var order = getOrder(line);\n    if (!order) return line.text.length;\n    return bidiRight(lst(order));\n  }\n\n  function lineStart(cm, lineN) {\n    var line = getLine(cm.doc, lineN);\n    var visual = visualLine(line);\n    if (visual != line) lineN = lineNo(visual);\n    var order = getOrder(visual);\n    var ch = !order ? 0 : order[0].level % 2 ? lineRight(visual) : lineLeft(visual);\n    return Pos(lineN, ch);\n  }\n  function lineEnd(cm, lineN) {\n    var merged, line = getLine(cm.doc, lineN);\n    while (merged = collapsedSpanAtEnd(line)) {\n      line = merged.find(1, true).line;\n      lineN = null;\n    }\n    var order = getOrder(line);\n    var ch = !order ? line.text.length : order[0].level % 2 ? lineLeft(line) : lineRight(line);\n    return Pos(lineN == null ? lineNo(line) : lineN, ch);\n  }\n  function lineStartSmart(cm, pos) {\n    var start = lineStart(cm, pos.line);\n    var line = getLine(cm.doc, start.line);\n    var order = getOrder(line);\n    if (!order || order[0].level == 0) {\n      var firstNonWS = Math.max(0, line.text.search(/\\S/));\n      var inWS = pos.line == start.line && pos.ch <= firstNonWS && pos.ch;\n      return Pos(start.line, inWS ? 0 : firstNonWS);\n    }\n    return start;\n  }\n\n  function compareBidiLevel(order, a, b) {\n    var linedir = order[0].level;\n    if (a == linedir) return true;\n    if (b == linedir) return false;\n    return a < b;\n  }\n  var bidiOther;\n  function getBidiPartAt(order, pos) {\n    bidiOther = null;\n    for (var i = 0, found; i < order.length; ++i) {\n      var cur = order[i];\n      if (cur.from < pos && cur.to > pos) return i;\n      if ((cur.from == pos || cur.to == pos)) {\n        if (found == null) {\n          found = i;\n        } else if (compareBidiLevel(order, cur.level, order[found].level)) {\n          if (cur.from != cur.to) bidiOther = found;\n          return i;\n        } else {\n          if (cur.from != cur.to) bidiOther = i;\n          return found;\n        }\n      }\n    }\n    return found;\n  }\n\n  function moveInLine(line, pos, dir, byUnit) {\n    if (!byUnit) return pos + dir;\n    do pos += dir;\n    while (pos > 0 && isExtendingChar(line.text.charAt(pos)));\n    return pos;\n  }\n\n  // This is needed in order to move 'visually' through bi-directional\n  // text -- i.e., pressing left should make the cursor go left, even\n  // when in RTL text. The tricky part is the 'jumps', where RTL and\n  // LTR text touch each other. This often requires the cursor offset\n  // to move more than one unit, in order to visually move one unit.\n  function moveVisually(line, start, dir, byUnit) {\n    var bidi = getOrder(line);\n    if (!bidi) return moveLogically(line, start, dir, byUnit);\n    var pos = getBidiPartAt(bidi, start), part = bidi[pos];\n    var target = moveInLine(line, start, part.level % 2 ? -dir : dir, byUnit);\n\n    for (;;) {\n      if (target > part.from && target < part.to) return target;\n      if (target == part.from || target == part.to) {\n        if (getBidiPartAt(bidi, target) == pos) return target;\n        part = bidi[pos += dir];\n        return (dir > 0) == part.level % 2 ? part.to : part.from;\n      } else {\n        part = bidi[pos += dir];\n        if (!part) return null;\n        if ((dir > 0) == part.level % 2)\n          target = moveInLine(line, part.to, -1, byUnit);\n        else\n          target = moveInLine(line, part.from, 1, byUnit);\n      }\n    }\n  }\n\n  function moveLogically(line, start, dir, byUnit) {\n    var target = start + dir;\n    if (byUnit) while (target > 0 && isExtendingChar(line.text.charAt(target))) target += dir;\n    return target < 0 || target > line.text.length ? null : target;\n  }\n\n  // Bidirectional ordering algorithm\n  // See http://unicode.org/reports/tr9/tr9-13.html for the algorithm\n  // that this (partially) implements.\n\n  // One-char codes used for character types:\n  // L (L):   Left-to-Right\n  // R (R):   Right-to-Left\n  // r (AL):  Right-to-Left Arabic\n  // 1 (EN):  European Number\n  // + (ES):  European Number Separator\n  // % (ET):  European Number Terminator\n  // n (AN):  Arabic Number\n  // , (CS):  Common Number Separator\n  // m (NSM): Non-Spacing Mark\n  // b (BN):  Boundary Neutral\n  // s (B):   Paragraph Separator\n  // t (S):   Segment Separator\n  // w (WS):  Whitespace\n  // N (ON):  Other Neutrals\n\n  // Returns null if characters are ordered as they appear\n  // (left-to-right), or an array of sections ({from, to, level}\n  // objects) in the order in which they occur visually.\n  var bidiOrdering = (function() {\n    // Character types for codepoints 0 to 0xff\n    var lowTypes = \"bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN\";\n    // Character types for codepoints 0x600 to 0x6ff\n    var arabicTypes = \"rrrrrrrrrrrr,rNNmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmrrrrrrrnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmNmmmm\";\n    function charType(code) {\n      if (code <= 0xf7) return lowTypes.charAt(code);\n      else if (0x590 <= code && code <= 0x5f4) return \"R\";\n      else if (0x600 <= code && code <= 0x6ed) return arabicTypes.charAt(code - 0x600);\n      else if (0x6ee <= code && code <= 0x8ac) return \"r\";\n      else if (0x2000 <= code && code <= 0x200b) return \"w\";\n      else if (code == 0x200c) return \"b\";\n      else return \"L\";\n    }\n\n    var bidiRE = /[\\u0590-\\u05f4\\u0600-\\u06ff\\u0700-\\u08ac]/;\n    var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;\n    // Browsers seem to always treat the boundaries of block elements as being L.\n    var outerType = \"L\";\n\n    function BidiSpan(level, from, to) {\n      this.level = level;\n      this.from = from; this.to = to;\n    }\n\n    return function(str) {\n      if (!bidiRE.test(str)) return false;\n      var len = str.length, types = [];\n      for (var i = 0, type; i < len; ++i)\n        types.push(type = charType(str.charCodeAt(i)));\n\n      // W1. Examine each non-spacing mark (NSM) in the level run, and\n      // change the type of the NSM to the type of the previous\n      // character. If the NSM is at the start of the level run, it will\n      // get the type of sor.\n      for (var i = 0, prev = outerType; i < len; ++i) {\n        var type = types[i];\n        if (type == \"m\") types[i] = prev;\n        else prev = type;\n      }\n\n      // W2. Search backwards from each instance of a European number\n      // until the first strong type (R, L, AL, or sor) is found. If an\n      // AL is found, change the type of the European number to Arabic\n      // number.\n      // W3. Change all ALs to R.\n      for (var i = 0, cur = outerType; i < len; ++i) {\n        var type = types[i];\n        if (type == \"1\" && cur == \"r\") types[i] = \"n\";\n        else if (isStrong.test(type)) { cur = type; if (type == \"r\") types[i] = \"R\"; }\n      }\n\n      // W4. A single European separator between two European numbers\n      // changes to a European number. A single common separator between\n      // two numbers of the same type changes to that type.\n      for (var i = 1, prev = types[0]; i < len - 1; ++i) {\n        var type = types[i];\n        if (type == \"+\" && prev == \"1\" && types[i+1] == \"1\") types[i] = \"1\";\n        else if (type == \",\" && prev == types[i+1] &&\n                 (prev == \"1\" || prev == \"n\")) types[i] = prev;\n        prev = type;\n      }\n\n      // W5. A sequence of European terminators adjacent to European\n      // numbers changes to all European numbers.\n      // W6. Otherwise, separators and terminators change to Other\n      // Neutral.\n      for (var i = 0; i < len; ++i) {\n        var type = types[i];\n        if (type == \",\") types[i] = \"N\";\n        else if (type == \"%\") {\n          for (var end = i + 1; end < len && types[end] == \"%\"; ++end) {}\n          var replace = (i && types[i-1] == \"!\") || (end < len && types[end] == \"1\") ? \"1\" : \"N\";\n          for (var j = i; j < end; ++j) types[j] = replace;\n          i = end - 1;\n        }\n      }\n\n      // W7. Search backwards from each instance of a European number\n      // until the first strong type (R, L, or sor) is found. If an L is\n      // found, then change the type of the European number to L.\n      for (var i = 0, cur = outerType; i < len; ++i) {\n        var type = types[i];\n        if (cur == \"L\" && type == \"1\") types[i] = \"L\";\n        else if (isStrong.test(type)) cur = type;\n      }\n\n      // N1. A sequence of neutrals takes the direction of the\n      // surrounding strong text if the text on both sides has the same\n      // direction. European and Arabic numbers act as if they were R in\n      // terms of their influence on neutrals. Start-of-level-run (sor)\n      // and end-of-level-run (eor) are used at level run boundaries.\n      // N2. Any remaining neutrals take the embedding direction.\n      for (var i = 0; i < len; ++i) {\n        if (isNeutral.test(types[i])) {\n          for (var end = i + 1; end < len && isNeutral.test(types[end]); ++end) {}\n          var before = (i ? types[i-1] : outerType) == \"L\";\n          var after = (end < len ? types[end] : outerType) == \"L\";\n          var replace = before || after ? \"L\" : \"R\";\n          for (var j = i; j < end; ++j) types[j] = replace;\n          i = end - 1;\n        }\n      }\n\n      // Here we depart from the documented algorithm, in order to avoid\n      // building up an actual levels array. Since there are only three\n      // levels (0, 1, 2) in an implementation that doesn't take\n      // explicit embedding into account, we can build up the order on\n      // the fly, without following the level-based algorithm.\n      var order = [], m;\n      for (var i = 0; i < len;) {\n        if (countsAsLeft.test(types[i])) {\n          var start = i;\n          for (++i; i < len && countsAsLeft.test(types[i]); ++i) {}\n          order.push(new BidiSpan(0, start, i));\n        } else {\n          var pos = i, at = order.length;\n          for (++i; i < len && types[i] != \"L\"; ++i) {}\n          for (var j = pos; j < i;) {\n            if (countsAsNum.test(types[j])) {\n              if (pos < j) order.splice(at, 0, new BidiSpan(1, pos, j));\n              var nstart = j;\n              for (++j; j < i && countsAsNum.test(types[j]); ++j) {}\n              order.splice(at, 0, new BidiSpan(2, nstart, j));\n              pos = j;\n            } else ++j;\n          }\n          if (pos < i) order.splice(at, 0, new BidiSpan(1, pos, i));\n        }\n      }\n      if (order[0].level == 1 && (m = str.match(/^\\s+/))) {\n        order[0].from = m[0].length;\n        order.unshift(new BidiSpan(0, 0, m[0].length));\n      }\n      if (lst(order).level == 1 && (m = str.match(/\\s+$/))) {\n        lst(order).to -= m[0].length;\n        order.push(new BidiSpan(0, len - m[0].length, len));\n      }\n      if (order[0].level != lst(order).level)\n        order.push(new BidiSpan(order[0].level, len, len));\n\n      return order;\n    };\n  })();\n\n  // THE END\n\n  CodeMirror.version = \"4.7.0\";\n\n  return CodeMirror;\n});\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n// TODO actually recognize syntax of TypeScript constructs\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.defineMode(\"javascript\", function(config, parserConfig) {\n  var indentUnit = config.indentUnit;\n  var statementIndent = parserConfig.statementIndent;\n  var jsonldMode = parserConfig.jsonld;\n  var jsonMode = parserConfig.json || jsonldMode;\n  var isTS = parserConfig.typescript;\n  var wordRE = parserConfig.wordCharacters || /[\\w$\\xa1-\\uffff]/;\n\n  // Tokenizer\n\n  var keywords = function(){\n    function kw(type) {return {type: type, style: \"keyword\"};}\n    var A = kw(\"keyword a\"), B = kw(\"keyword b\"), C = kw(\"keyword c\");\n    var operator = kw(\"operator\"), atom = {type: \"atom\", style: \"atom\"};\n\n    var jsKeywords = {\n      \"if\": kw(\"if\"), \"while\": A, \"with\": A, \"else\": B, \"do\": B, \"try\": B, \"finally\": B,\n      \"return\": C, \"break\": C, \"continue\": C, \"new\": C, \"delete\": C, \"throw\": C, \"debugger\": C,\n      \"var\": kw(\"var\"), \"const\": kw(\"var\"), \"let\": kw(\"var\"),\n      \"function\": kw(\"function\"), \"catch\": kw(\"catch\"),\n      \"for\": kw(\"for\"), \"switch\": kw(\"switch\"), \"case\": kw(\"case\"), \"default\": kw(\"default\"),\n      \"in\": operator, \"typeof\": operator, \"instanceof\": operator,\n      \"true\": atom, \"false\": atom, \"null\": atom, \"undefined\": atom, \"NaN\": atom, \"Infinity\": atom,\n      \"this\": kw(\"this\"), \"module\": kw(\"module\"), \"class\": kw(\"class\"), \"super\": kw(\"atom\"),\n      \"yield\": C, \"export\": kw(\"export\"), \"import\": kw(\"import\"), \"extends\": C\n    };\n\n    // Extend the 'normal' keywords with the TypeScript language extensions\n    if (isTS) {\n      var type = {type: \"variable\", style: \"variable-3\"};\n      var tsKeywords = {\n        // object-like things\n        \"interface\": kw(\"interface\"),\n        \"extends\": kw(\"extends\"),\n        \"constructor\": kw(\"constructor\"),\n\n        // scope modifiers\n        \"public\": kw(\"public\"),\n        \"private\": kw(\"private\"),\n        \"protected\": kw(\"protected\"),\n        \"static\": kw(\"static\"),\n\n        // types\n        \"string\": type, \"number\": type, \"bool\": type, \"any\": type\n      };\n\n      for (var attr in tsKeywords) {\n        jsKeywords[attr] = tsKeywords[attr];\n      }\n    }\n\n    return jsKeywords;\n  }();\n\n  var isOperatorChar = /[+\\-*&%=<>!?|~^]/;\n  var isJsonldKeyword = /^@(context|id|value|language|type|container|list|set|reverse|index|base|vocab|graph)\"/;\n\n  function readRegexp(stream) {\n    var escaped = false, next, inSet = false;\n    while ((next = stream.next()) != null) {\n      if (!escaped) {\n        if (next == \"/\" && !inSet) return;\n        if (next == \"[\") inSet = true;\n        else if (inSet && next == \"]\") inSet = false;\n      }\n      escaped = !escaped && next == \"\\\\\";\n    }\n  }\n\n  // Used as scratch variables to communicate multiple values without\n  // consing up tons of objects.\n  var type, content;\n  function ret(tp, style, cont) {\n    type = tp; content = cont;\n    return style;\n  }\n  function tokenBase(stream, state) {\n    var ch = stream.next();\n    if (ch == '\"' || ch == \"'\") {\n      state.tokenize = tokenString(ch);\n      return state.tokenize(stream, state);\n    } else if (ch == \".\" && stream.match(/^\\d+(?:[eE][+\\-]?\\d+)?/)) {\n      return ret(\"number\", \"number\");\n    } else if (ch == \".\" && stream.match(\"..\")) {\n      return ret(\"spread\", \"meta\");\n    } else if (/[\\[\\]{}\\(\\),;\\:\\.]/.test(ch)) {\n      return ret(ch);\n    } else if (ch == \"=\" && stream.eat(\">\")) {\n      return ret(\"=>\", \"operator\");\n    } else if (ch == \"0\" && stream.eat(/x/i)) {\n      stream.eatWhile(/[\\da-f]/i);\n      return ret(\"number\", \"number\");\n    } else if (/\\d/.test(ch)) {\n      stream.match(/^\\d*(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/);\n      return ret(\"number\", \"number\");\n    } else if (ch == \"/\") {\n      if (stream.eat(\"*\")) {\n        state.tokenize = tokenComment;\n        return tokenComment(stream, state);\n      } else if (stream.eat(\"/\")) {\n        stream.skipToEnd();\n        return ret(\"comment\", \"comment\");\n      } else if (state.lastType == \"operator\" || state.lastType == \"keyword c\" ||\n               state.lastType == \"sof\" || /^[\\[{}\\(,;:]$/.test(state.lastType)) {\n        readRegexp(stream);\n        stream.eatWhile(/[gimy]/); // 'y' is \"sticky\" option in Mozilla\n        return ret(\"regexp\", \"string-2\");\n      } else {\n        stream.eatWhile(isOperatorChar);\n        return ret(\"operator\", \"operator\", stream.current());\n      }\n    } else if (ch == \"`\") {\n      state.tokenize = tokenQuasi;\n      return tokenQuasi(stream, state);\n    } else if (ch == \"#\") {\n      stream.skipToEnd();\n      return ret(\"error\", \"error\");\n    } else if (isOperatorChar.test(ch)) {\n      stream.eatWhile(isOperatorChar);\n      return ret(\"operator\", \"operator\", stream.current());\n    } else if (wordRE.test(ch)) {\n      stream.eatWhile(wordRE);\n      var word = stream.current(), known = keywords.propertyIsEnumerable(word) && keywords[word];\n      return (known && state.lastType != \".\") ? ret(known.type, known.style, word) :\n                     ret(\"variable\", \"variable\", word);\n    }\n  }\n\n  function tokenString(quote) {\n    return function(stream, state) {\n      var escaped = false, next;\n      if (jsonldMode && stream.peek() == \"@\" && stream.match(isJsonldKeyword)){\n        state.tokenize = tokenBase;\n        return ret(\"jsonld-keyword\", \"meta\");\n      }\n      while ((next = stream.next()) != null) {\n        if (next == quote && !escaped) break;\n        escaped = !escaped && next == \"\\\\\";\n      }\n      if (!escaped) state.tokenize = tokenBase;\n      return ret(\"string\", \"string\");\n    };\n  }\n\n  function tokenComment(stream, state) {\n    var maybeEnd = false, ch;\n    while (ch = stream.next()) {\n      if (ch == \"/\" && maybeEnd) {\n        state.tokenize = tokenBase;\n        break;\n      }\n      maybeEnd = (ch == \"*\");\n    }\n    return ret(\"comment\", \"comment\");\n  }\n\n  function tokenQuasi(stream, state) {\n    var escaped = false, next;\n    while ((next = stream.next()) != null) {\n      if (!escaped && (next == \"`\" || next == \"$\" && stream.eat(\"{\"))) {\n        state.tokenize = tokenBase;\n        break;\n      }\n      escaped = !escaped && next == \"\\\\\";\n    }\n    return ret(\"quasi\", \"string-2\", stream.current());\n  }\n\n  var brackets = \"([{}])\";\n  // This is a crude lookahead trick to try and notice that we're\n  // parsing the argument patterns for a fat-arrow function before we\n  // actually hit the arrow token. It only works if the arrow is on\n  // the same line as the arguments and there's no strange noise\n  // (comments) in between. Fallback is to only notice when we hit the\n  // arrow, and not declare the arguments as locals for the arrow\n  // body.\n  function findFatArrow(stream, state) {\n    if (state.fatArrowAt) state.fatArrowAt = null;\n    var arrow = stream.string.indexOf(\"=>\", stream.start);\n    if (arrow < 0) return;\n\n    var depth = 0, sawSomething = false;\n    for (var pos = arrow - 1; pos >= 0; --pos) {\n      var ch = stream.string.charAt(pos);\n      var bracket = brackets.indexOf(ch);\n      if (bracket >= 0 && bracket < 3) {\n        if (!depth) { ++pos; break; }\n        if (--depth == 0) break;\n      } else if (bracket >= 3 && bracket < 6) {\n        ++depth;\n      } else if (wordRE.test(ch)) {\n        sawSomething = true;\n      } else if (sawSomething && !depth) {\n        ++pos;\n        break;\n      }\n    }\n    if (sawSomething && !depth) state.fatArrowAt = pos;\n  }\n\n  // Parser\n\n  var atomicTypes = {\"atom\": true, \"number\": true, \"variable\": true, \"string\": true, \"regexp\": true, \"this\": true, \"jsonld-keyword\": true};\n\n  function JSLexical(indented, column, type, align, prev, info) {\n    this.indented = indented;\n    this.column = column;\n    this.type = type;\n    this.prev = prev;\n    this.info = info;\n    if (align != null) this.align = align;\n  }\n\n  function inScope(state, varname) {\n    for (var v = state.localVars; v; v = v.next)\n      if (v.name == varname) return true;\n    for (var cx = state.context; cx; cx = cx.prev) {\n      for (var v = cx.vars; v; v = v.next)\n        if (v.name == varname) return true;\n    }\n  }\n\n  function parseJS(state, style, type, content, stream) {\n    var cc = state.cc;\n    // Communicate our context to the combinators.\n    // (Less wasteful than consing up a hundred closures on every call.)\n    cx.state = state; cx.stream = stream; cx.marked = null, cx.cc = cc; cx.style = style;\n\n    if (!state.lexical.hasOwnProperty(\"align\"))\n      state.lexical.align = true;\n\n    while(true) {\n      var combinator = cc.length ? cc.pop() : jsonMode ? expression : statement;\n      if (combinator(type, content)) {\n        while(cc.length && cc[cc.length - 1].lex)\n          cc.pop()();\n        if (cx.marked) return cx.marked;\n        if (type == \"variable\" && inScope(state, content)) return \"variable-2\";\n        return style;\n      }\n    }\n  }\n\n  // Combinator utils\n\n  var cx = {state: null, column: null, marked: null, cc: null};\n  function pass() {\n    for (var i = arguments.length - 1; i >= 0; i--) cx.cc.push(arguments[i]);\n  }\n  function cont() {\n    pass.apply(null, arguments);\n    return true;\n  }\n  function register(varname) {\n    function inList(list) {\n      for (var v = list; v; v = v.next)\n        if (v.name == varname) return true;\n      return false;\n    }\n    var state = cx.state;\n    if (state.context) {\n      cx.marked = \"def\";\n      if (inList(state.localVars)) return;\n      state.localVars = {name: varname, next: state.localVars};\n    } else {\n      if (inList(state.globalVars)) return;\n      if (parserConfig.globalVars)\n        state.globalVars = {name: varname, next: state.globalVars};\n    }\n  }\n\n  // Combinators\n\n  var defaultVars = {name: \"this\", next: {name: \"arguments\"}};\n  function pushcontext() {\n    cx.state.context = {prev: cx.state.context, vars: cx.state.localVars};\n    cx.state.localVars = defaultVars;\n  }\n  function popcontext() {\n    cx.state.localVars = cx.state.context.vars;\n    cx.state.context = cx.state.context.prev;\n  }\n  function pushlex(type, info) {\n    var result = function() {\n      var state = cx.state, indent = state.indented;\n      if (state.lexical.type == \"stat\") indent = state.lexical.indented;\n      else for (var outer = state.lexical; outer && outer.type == \")\" && outer.align; outer = outer.prev)\n        indent = outer.indented;\n      state.lexical = new JSLexical(indent, cx.stream.column(), type, null, state.lexical, info);\n    };\n    result.lex = true;\n    return result;\n  }\n  function poplex() {\n    var state = cx.state;\n    if (state.lexical.prev) {\n      if (state.lexical.type == \")\")\n        state.indented = state.lexical.indented;\n      state.lexical = state.lexical.prev;\n    }\n  }\n  poplex.lex = true;\n\n  function expect(wanted) {\n    function exp(type) {\n      if (type == wanted) return cont();\n      else if (wanted == \";\") return pass();\n      else return cont(exp);\n    };\n    return exp;\n  }\n\n  function statement(type, value) {\n    if (type == \"var\") return cont(pushlex(\"vardef\", value.length), vardef, expect(\";\"), poplex);\n    if (type == \"keyword a\") return cont(pushlex(\"form\"), expression, statement, poplex);\n    if (type == \"keyword b\") return cont(pushlex(\"form\"), statement, poplex);\n    if (type == \"{\") return cont(pushlex(\"}\"), block, poplex);\n    if (type == \";\") return cont();\n    if (type == \"if\") {\n      if (cx.state.lexical.info == \"else\" && cx.state.cc[cx.state.cc.length - 1] == poplex)\n        cx.state.cc.pop()();\n      return cont(pushlex(\"form\"), expression, statement, poplex, maybeelse);\n    }\n    if (type == \"function\") return cont(functiondef);\n    if (type == \"for\") return cont(pushlex(\"form\"), forspec, statement, poplex);\n    if (type == \"variable\") return cont(pushlex(\"stat\"), maybelabel);\n    if (type == \"switch\") return cont(pushlex(\"form\"), expression, pushlex(\"}\", \"switch\"), expect(\"{\"),\n                                      block, poplex, poplex);\n    if (type == \"case\") return cont(expression, expect(\":\"));\n    if (type == \"default\") return cont(expect(\":\"));\n    if (type == \"catch\") return cont(pushlex(\"form\"), pushcontext, expect(\"(\"), funarg, expect(\")\"),\n                                     statement, poplex, popcontext);\n    if (type == \"module\") return cont(pushlex(\"form\"), pushcontext, afterModule, popcontext, poplex);\n    if (type == \"class\") return cont(pushlex(\"form\"), className, poplex);\n    if (type == \"export\") return cont(pushlex(\"form\"), afterExport, poplex);\n    if (type == \"import\") return cont(pushlex(\"form\"), afterImport, poplex);\n    return pass(pushlex(\"stat\"), expression, expect(\";\"), poplex);\n  }\n  function expression(type) {\n    return expressionInner(type, false);\n  }\n  function expressionNoComma(type) {\n    return expressionInner(type, true);\n  }\n  function expressionInner(type, noComma) {\n    if (cx.state.fatArrowAt == cx.stream.start) {\n      var body = noComma ? arrowBodyNoComma : arrowBody;\n      if (type == \"(\") return cont(pushcontext, pushlex(\")\"), commasep(pattern, \")\"), poplex, expect(\"=>\"), body, popcontext);\n      else if (type == \"variable\") return pass(pushcontext, pattern, expect(\"=>\"), body, popcontext);\n    }\n\n    var maybeop = noComma ? maybeoperatorNoComma : maybeoperatorComma;\n    if (atomicTypes.hasOwnProperty(type)) return cont(maybeop);\n    if (type == \"function\") return cont(functiondef, maybeop);\n    if (type == \"keyword c\") return cont(noComma ? maybeexpressionNoComma : maybeexpression);\n    if (type == \"(\") return cont(pushlex(\")\"), maybeexpression, comprehension, expect(\")\"), poplex, maybeop);\n    if (type == \"operator\" || type == \"spread\") return cont(noComma ? expressionNoComma : expression);\n    if (type == \"[\") return cont(pushlex(\"]\"), arrayLiteral, poplex, maybeop);\n    if (type == \"{\") return contCommasep(objprop, \"}\", null, maybeop);\n    if (type == \"quasi\") { return pass(quasi, maybeop); }\n    return cont();\n  }\n  function maybeexpression(type) {\n    if (type.match(/[;\\}\\)\\],]/)) return pass();\n    return pass(expression);\n  }\n  function maybeexpressionNoComma(type) {\n    if (type.match(/[;\\}\\)\\],]/)) return pass();\n    return pass(expressionNoComma);\n  }\n\n  function maybeoperatorComma(type, value) {\n    if (type == \",\") return cont(expression);\n    return maybeoperatorNoComma(type, value, false);\n  }\n  function maybeoperatorNoComma(type, value, noComma) {\n    var me = noComma == false ? maybeoperatorComma : maybeoperatorNoComma;\n    var expr = noComma == false ? expression : expressionNoComma;\n    if (type == \"=>\") return cont(pushcontext, noComma ? arrowBodyNoComma : arrowBody, popcontext);\n    if (type == \"operator\") {\n      if (/\\+\\+|--/.test(value)) return cont(me);\n      if (value == \"?\") return cont(expression, expect(\":\"), expr);\n      return cont(expr);\n    }\n    if (type == \"quasi\") { return pass(quasi, me); }\n    if (type == \";\") return;\n    if (type == \"(\") return contCommasep(expressionNoComma, \")\", \"call\", me);\n    if (type == \".\") return cont(property, me);\n    if (type == \"[\") return cont(pushlex(\"]\"), maybeexpression, expect(\"]\"), poplex, me);\n  }\n  function quasi(type, value) {\n    if (type != \"quasi\") return pass();\n    if (value.slice(value.length - 2) != \"${\") return cont(quasi);\n    return cont(expression, continueQuasi);\n  }\n  function continueQuasi(type) {\n    if (type == \"}\") {\n      cx.marked = \"string-2\";\n      cx.state.tokenize = tokenQuasi;\n      return cont(quasi);\n    }\n  }\n  function arrowBody(type) {\n    findFatArrow(cx.stream, cx.state);\n    return pass(type == \"{\" ? statement : expression);\n  }\n  function arrowBodyNoComma(type) {\n    findFatArrow(cx.stream, cx.state);\n    return pass(type == \"{\" ? statement : expressionNoComma);\n  }\n  function maybelabel(type) {\n    if (type == \":\") return cont(poplex, statement);\n    return pass(maybeoperatorComma, expect(\";\"), poplex);\n  }\n  function property(type) {\n    if (type == \"variable\") {cx.marked = \"property\"; return cont();}\n  }\n  function objprop(type, value) {\n    if (type == \"variable\" || cx.style == \"keyword\") {\n      cx.marked = \"property\";\n      if (value == \"get\" || value == \"set\") return cont(getterSetter);\n      return cont(afterprop);\n    } else if (type == \"number\" || type == \"string\") {\n      cx.marked = jsonldMode ? \"property\" : (cx.style + \" property\");\n      return cont(afterprop);\n    } else if (type == \"jsonld-keyword\") {\n      return cont(afterprop);\n    } else if (type == \"[\") {\n      return cont(expression, expect(\"]\"), afterprop);\n    }\n  }\n  function getterSetter(type) {\n    if (type != \"variable\") return pass(afterprop);\n    cx.marked = \"property\";\n    return cont(functiondef);\n  }\n  function afterprop(type) {\n    if (type == \":\") return cont(expressionNoComma);\n    if (type == \"(\") return pass(functiondef);\n  }\n  function commasep(what, end) {\n    function proceed(type) {\n      if (type == \",\") {\n        var lex = cx.state.lexical;\n        if (lex.info == \"call\") lex.pos = (lex.pos || 0) + 1;\n        return cont(what, proceed);\n      }\n      if (type == end) return cont();\n      return cont(expect(end));\n    }\n    return function(type) {\n      if (type == end) return cont();\n      return pass(what, proceed);\n    };\n  }\n  function contCommasep(what, end, info) {\n    for (var i = 3; i < arguments.length; i++)\n      cx.cc.push(arguments[i]);\n    return cont(pushlex(end, info), commasep(what, end), poplex);\n  }\n  function block(type) {\n    if (type == \"}\") return cont();\n    return pass(statement, block);\n  }\n  function maybetype(type) {\n    if (isTS && type == \":\") return cont(typedef);\n  }\n  function typedef(type) {\n    if (type == \"variable\"){cx.marked = \"variable-3\"; return cont();}\n  }\n  function vardef() {\n    return pass(pattern, maybetype, maybeAssign, vardefCont);\n  }\n  function pattern(type, value) {\n    if (type == \"variable\") { register(value); return cont(); }\n    if (type == \"[\") return contCommasep(pattern, \"]\");\n    if (type == \"{\") return contCommasep(proppattern, \"}\");\n  }\n  function proppattern(type, value) {\n    if (type == \"variable\" && !cx.stream.match(/^\\s*:/, false)) {\n      register(value);\n      return cont(maybeAssign);\n    }\n    if (type == \"variable\") cx.marked = \"property\";\n    return cont(expect(\":\"), pattern, maybeAssign);\n  }\n  function maybeAssign(_type, value) {\n    if (value == \"=\") return cont(expressionNoComma);\n  }\n  function vardefCont(type) {\n    if (type == \",\") return cont(vardef);\n  }\n  function maybeelse(type, value) {\n    if (type == \"keyword b\" && value == \"else\") return cont(pushlex(\"form\", \"else\"), statement, poplex);\n  }\n  function forspec(type) {\n    if (type == \"(\") return cont(pushlex(\")\"), forspec1, expect(\")\"), poplex);\n  }\n  function forspec1(type) {\n    if (type == \"var\") return cont(vardef, expect(\";\"), forspec2);\n    if (type == \";\") return cont(forspec2);\n    if (type == \"variable\") return cont(formaybeinof);\n    return pass(expression, expect(\";\"), forspec2);\n  }\n  function formaybeinof(_type, value) {\n    if (value == \"in\" || value == \"of\") { cx.marked = \"keyword\"; return cont(expression); }\n    return cont(maybeoperatorComma, forspec2);\n  }\n  function forspec2(type, value) {\n    if (type == \";\") return cont(forspec3);\n    if (value == \"in\" || value == \"of\") { cx.marked = \"keyword\"; return cont(expression); }\n    return pass(expression, expect(\";\"), forspec3);\n  }\n  function forspec3(type) {\n    if (type != \")\") cont(expression);\n  }\n  function functiondef(type, value) {\n    if (value == \"*\") {cx.marked = \"keyword\"; return cont(functiondef);}\n    if (type == \"variable\") {register(value); return cont(functiondef);}\n    if (type == \"(\") return cont(pushcontext, pushlex(\")\"), commasep(funarg, \")\"), poplex, statement, popcontext);\n  }\n  function funarg(type) {\n    if (type == \"spread\") return cont(funarg);\n    return pass(pattern, maybetype);\n  }\n  function className(type, value) {\n    if (type == \"variable\") {register(value); return cont(classNameAfter);}\n  }\n  function classNameAfter(type, value) {\n    if (value == \"extends\") return cont(expression, classNameAfter);\n    if (type == \"{\") return cont(pushlex(\"}\"), classBody, poplex);\n  }\n  function classBody(type, value) {\n    if (type == \"variable\" || cx.style == \"keyword\") {\n      cx.marked = \"property\";\n      if (value == \"get\" || value == \"set\") return cont(classGetterSetter, functiondef, classBody);\n      return cont(functiondef, classBody);\n    }\n    if (value == \"*\") {\n      cx.marked = \"keyword\";\n      return cont(classBody);\n    }\n    if (type == \";\") return cont(classBody);\n    if (type == \"}\") return cont();\n  }\n  function classGetterSetter(type) {\n    if (type != \"variable\") return pass();\n    cx.marked = \"property\";\n    return cont();\n  }\n  function afterModule(type, value) {\n    if (type == \"string\") return cont(statement);\n    if (type == \"variable\") { register(value); return cont(maybeFrom); }\n  }\n  function afterExport(_type, value) {\n    if (value == \"*\") { cx.marked = \"keyword\"; return cont(maybeFrom, expect(\";\")); }\n    if (value == \"default\") { cx.marked = \"keyword\"; return cont(expression, expect(\";\")); }\n    return pass(statement);\n  }\n  function afterImport(type) {\n    if (type == \"string\") return cont();\n    return pass(importSpec, maybeFrom);\n  }\n  function importSpec(type, value) {\n    if (type == \"{\") return contCommasep(importSpec, \"}\");\n    if (type == \"variable\") register(value);\n    return cont();\n  }\n  function maybeFrom(_type, value) {\n    if (value == \"from\") { cx.marked = \"keyword\"; return cont(expression); }\n  }\n  function arrayLiteral(type) {\n    if (type == \"]\") return cont();\n    return pass(expressionNoComma, maybeArrayComprehension);\n  }\n  function maybeArrayComprehension(type) {\n    if (type == \"for\") return pass(comprehension, expect(\"]\"));\n    if (type == \",\") return cont(commasep(maybeexpressionNoComma, \"]\"));\n    return pass(commasep(expressionNoComma, \"]\"));\n  }\n  function comprehension(type) {\n    if (type == \"for\") return cont(forspec, comprehension);\n    if (type == \"if\") return cont(expression, comprehension);\n  }\n\n  // Interface\n\n  return {\n    startState: function(basecolumn) {\n      var state = {\n        tokenize: tokenBase,\n        lastType: \"sof\",\n        cc: [],\n        lexical: new JSLexical((basecolumn || 0) - indentUnit, 0, \"block\", false),\n        localVars: parserConfig.localVars,\n        context: parserConfig.localVars && {vars: parserConfig.localVars},\n        indented: 0\n      };\n      if (parserConfig.globalVars && typeof parserConfig.globalVars == \"object\")\n        state.globalVars = parserConfig.globalVars;\n      return state;\n    },\n\n    token: function(stream, state) {\n      if (stream.sol()) {\n        if (!state.lexical.hasOwnProperty(\"align\"))\n          state.lexical.align = false;\n        state.indented = stream.indentation();\n        findFatArrow(stream, state);\n      }\n      if (state.tokenize != tokenComment && stream.eatSpace()) return null;\n      var style = state.tokenize(stream, state);\n      if (type == \"comment\") return style;\n      state.lastType = type == \"operator\" && (content == \"++\" || content == \"--\") ? \"incdec\" : type;\n      return parseJS(state, style, type, content, stream);\n    },\n\n    indent: function(state, textAfter) {\n      if (state.tokenize == tokenComment) return CodeMirror.Pass;\n      if (state.tokenize != tokenBase) return 0;\n      var firstChar = textAfter && textAfter.charAt(0), lexical = state.lexical;\n      // Kludge to prevent 'maybelse' from blocking lexical scope pops\n      if (!/^\\s*else\\b/.test(textAfter)) for (var i = state.cc.length - 1; i >= 0; --i) {\n        var c = state.cc[i];\n        if (c == poplex) lexical = lexical.prev;\n        else if (c != maybeelse) break;\n      }\n      if (lexical.type == \"stat\" && firstChar == \"}\") lexical = lexical.prev;\n      if (statementIndent && lexical.type == \")\" && lexical.prev.type == \"stat\")\n        lexical = lexical.prev;\n      var type = lexical.type, closing = firstChar == type;\n\n      if (type == \"vardef\") return lexical.indented + (state.lastType == \"operator\" || state.lastType == \",\" ? lexical.info + 1 : 0);\n      else if (type == \"form\" && firstChar == \"{\") return lexical.indented;\n      else if (type == \"form\") return lexical.indented + indentUnit;\n      else if (type == \"stat\")\n        return lexical.indented + (state.lastType == \"operator\" || state.lastType == \",\" ? statementIndent || indentUnit : 0);\n      else if (lexical.info == \"switch\" && !closing && parserConfig.doubleIndentSwitch != false)\n        return lexical.indented + (/^(?:case|default)\\b/.test(textAfter) ? indentUnit : 2 * indentUnit);\n      else if (lexical.align) return lexical.column + (closing ? 0 : 1);\n      else return lexical.indented + (closing ? 0 : indentUnit);\n    },\n\n    electricInput: /^\\s*(?:case .*?:|default:|\\{|\\})$/,\n    blockCommentStart: jsonMode ? null : \"/*\",\n    blockCommentEnd: jsonMode ? null : \"*/\",\n    lineComment: jsonMode ? null : \"//\",\n    fold: \"brace\",\n\n    helperType: jsonMode ? \"json\" : \"javascript\",\n    jsonldMode: jsonldMode,\n    jsonMode: jsonMode\n  };\n});\n\nCodeMirror.registerHelper(\"wordChars\", \"javascript\", /[\\w$]/);\n\nCodeMirror.defineMIME(\"text/javascript\", \"javascript\");\nCodeMirror.defineMIME(\"text/ecmascript\", \"javascript\");\nCodeMirror.defineMIME(\"application/javascript\", \"javascript\");\nCodeMirror.defineMIME(\"application/x-javascript\", \"javascript\");\nCodeMirror.defineMIME(\"application/ecmascript\", \"javascript\");\nCodeMirror.defineMIME(\"application/json\", {name: \"javascript\", json: true});\nCodeMirror.defineMIME(\"application/x-json\", {name: \"javascript\", json: true});\nCodeMirror.defineMIME(\"application/ld+json\", {name: \"javascript\", jsonld: true});\nCodeMirror.defineMIME(\"text/typescript\", { name: \"javascript\", typescript: true });\nCodeMirror.defineMIME(\"application/typescript\", { name: \"javascript\", typescript: true });\n\n});\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n  var GUTTER_ID = \"CodeMirror-lint-markers\";\n\n  function showTooltip(e, content) {\n    var tt = document.createElement(\"div\");\n    tt.className = \"CodeMirror-lint-tooltip\";\n    tt.appendChild(content.cloneNode(true));\n    document.body.appendChild(tt);\n\n    function position(e) {\n      if (!tt.parentNode) return CodeMirror.off(document, \"mousemove\", position);\n      tt.style.top = Math.max(0, e.clientY - tt.offsetHeight - 5) + \"px\";\n      tt.style.left = (e.clientX + 5) + \"px\";\n    }\n    CodeMirror.on(document, \"mousemove\", position);\n    position(e);\n    if (tt.style.opacity != null) tt.style.opacity = 1;\n    return tt;\n  }\n  function rm(elt) {\n    if (elt.parentNode) elt.parentNode.removeChild(elt);\n  }\n  function hideTooltip(tt) {\n    if (!tt.parentNode) return;\n    if (tt.style.opacity == null) rm(tt);\n    tt.style.opacity = 0;\n    setTimeout(function() { rm(tt); }, 600);\n  }\n\n  function showTooltipFor(e, content, node) {\n    var tooltip = showTooltip(e, content);\n    function hide() {\n      CodeMirror.off(node, \"mouseout\", hide);\n      if (tooltip) { hideTooltip(tooltip); tooltip = null; }\n    }\n    var poll = setInterval(function() {\n      if (tooltip) for (var n = node;; n = n.parentNode) {\n        if (n == document.body) return;\n        if (!n) { hide(); break; }\n      }\n      if (!tooltip) return clearInterval(poll);\n    }, 400);\n    CodeMirror.on(node, \"mouseout\", hide);\n  }\n\n  function LintState(cm, options, hasGutter) {\n    this.marked = [];\n    this.options = options;\n    this.timeout = null;\n    this.hasGutter = hasGutter;\n    this.onMouseOver = function(e) { onMouseOver(cm, e); };\n  }\n\n  function parseOptions(cm, options) {\n    if (options instanceof Function) return {getAnnotations: options};\n    if (!options || options === true) options = {};\n    if (!options.getAnnotations) options.getAnnotations = cm.getHelper(CodeMirror.Pos(0, 0), \"lint\");\n    if (!options.getAnnotations) throw new Error(\"Required option 'getAnnotations' missing (lint addon)\");\n    return options;\n  }\n\n  function clearMarks(cm) {\n    var state = cm.state.lint;\n    if (state.hasGutter) cm.clearGutter(GUTTER_ID);\n    for (var i = 0; i < state.marked.length; ++i)\n      state.marked[i].clear();\n    state.marked.length = 0;\n  }\n\n  function makeMarker(labels, severity, multiple, tooltips) {\n    var marker = document.createElement(\"div\"), inner = marker;\n    marker.className = \"CodeMirror-lint-marker-\" + severity;\n    if (multiple) {\n      inner = marker.appendChild(document.createElement(\"div\"));\n      inner.className = \"CodeMirror-lint-marker-multiple\";\n    }\n\n    if (tooltips != false) CodeMirror.on(inner, \"mouseover\", function(e) {\n      showTooltipFor(e, labels, inner);\n    });\n\n    return marker;\n  }\n\n  function getMaxSeverity(a, b) {\n    if (a == \"error\") return a;\n    else return b;\n  }\n\n  function groupByLine(annotations) {\n    var lines = [];\n    for (var i = 0; i < annotations.length; ++i) {\n      var ann = annotations[i], line = ann.from.line;\n      (lines[line] || (lines[line] = [])).push(ann);\n    }\n    return lines;\n  }\n\n  function annotationTooltip(ann) {\n    var severity = ann.severity;\n    if (!severity) severity = \"error\";\n    var tip = document.createElement(\"div\");\n    tip.className = \"CodeMirror-lint-message-\" + severity;\n    tip.appendChild(document.createTextNode(ann.message));\n    return tip;\n  }\n\n  function startLinting(cm) {\n    var state = cm.state.lint, options = state.options;\n    var passOptions = options.options || options; // Support deprecated passing of `options` property in options\n    if (options.async)\n      options.getAnnotations(cm.getValue(), updateLinting, passOptions, cm);\n    else\n      updateLinting(cm, options.getAnnotations(cm.getValue(), passOptions, cm));\n  }\n\n  function updateLinting(cm, annotationsNotSorted) {\n    clearMarks(cm);\n    var state = cm.state.lint, options = state.options;\n\n    var annotations = groupByLine(annotationsNotSorted);\n\n    for (var line = 0; line < annotations.length; ++line) {\n      var anns = annotations[line];\n      if (!anns) continue;\n\n      var maxSeverity = null;\n      var tipLabel = state.hasGutter && document.createDocumentFragment();\n\n      for (var i = 0; i < anns.length; ++i) {\n        var ann = anns[i];\n        var severity = ann.severity;\n        if (!severity) severity = \"error\";\n        maxSeverity = getMaxSeverity(maxSeverity, severity);\n\n        if (options.formatAnnotation) ann = options.formatAnnotation(ann);\n        if (state.hasGutter) tipLabel.appendChild(annotationTooltip(ann));\n\n        if (ann.to) state.marked.push(cm.markText(ann.from, ann.to, {\n          className: \"CodeMirror-lint-mark-\" + severity,\n          __annotation: ann\n        }));\n      }\n\n      if (state.hasGutter)\n        cm.setGutterMarker(line, GUTTER_ID, makeMarker(tipLabel, maxSeverity, anns.length > 1,\n                                                       state.options.tooltips));\n    }\n    if (options.onUpdateLinting) options.onUpdateLinting(annotationsNotSorted, annotations, cm);\n  }\n\n  function onChange(cm) {\n    var state = cm.state.lint;\n    clearTimeout(state.timeout);\n    state.timeout = setTimeout(function(){startLinting(cm);}, state.options.delay || 500);\n  }\n\n  function popupSpanTooltip(ann, e) {\n    var target = e.target || e.srcElement;\n    showTooltipFor(e, annotationTooltip(ann), target);\n  }\n\n  function onMouseOver(cm, e) {\n    var target = e.target || e.srcElement;\n    if (!/\\bCodeMirror-lint-mark-/.test(target.className)) return;\n    var box = target.getBoundingClientRect(), x = (box.left + box.right) / 2, y = (box.top + box.bottom) / 2;\n    var spans = cm.findMarksAt(cm.coordsChar({left: x, top: y}, \"client\"));\n    for (var i = 0; i < spans.length; ++i) {\n      var ann = spans[i].__annotation;\n      if (ann) return popupSpanTooltip(ann, e);\n    }\n  }\n\n  CodeMirror.defineOption(\"lint\", false, function(cm, val, old) {\n    if (old && old != CodeMirror.Init) {\n      clearMarks(cm);\n      cm.off(\"change\", onChange);\n      CodeMirror.off(cm.getWrapperElement(), \"mouseover\", cm.state.lint.onMouseOver);\n      delete cm.state.lint;\n    }\n\n    if (val) {\n      var gutters = cm.getOption(\"gutters\"), hasLintGutter = false;\n      for (var i = 0; i < gutters.length; ++i) if (gutters[i] == GUTTER_ID) hasLintGutter = true;\n      var state = cm.state.lint = new LintState(cm, parseOptions(cm, val), hasLintGutter);\n      cm.on(\"change\", onChange);\n      if (state.options.tooltips != false)\n        CodeMirror.on(cm.getWrapperElement(), \"mouseover\", state.onMouseOver);\n\n      startLinting(cm);\n    }\n  });\n});\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n// Depends on jsonlint.js from https://github.com/zaach/jsonlint\n\n// declare global: jsonlint\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.registerHelper(\"lint\", \"json\", function(text) {\n  var found = [];\n  jsonlint.parseError = function(str, hash) {\n    var loc = hash.loc;\n    found.push({from: CodeMirror.Pos(loc.first_line - 1, loc.first_column),\n                to: CodeMirror.Pos(loc.last_line - 1, loc.last_column),\n                message: str});\n  };\n  try { jsonlint.parse(text); }\n  catch(e) {}\n  return found;\n});\n\n});\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.registerHelper(\"fold\", \"brace\", function(cm, start) {\n  var line = start.line, lineText = cm.getLine(line);\n  var startCh, tokenType;\n\n  function findOpening(openCh) {\n    for (var at = start.ch, pass = 0;;) {\n      var found = at <= 0 ? -1 : lineText.lastIndexOf(openCh, at - 1);\n      if (found == -1) {\n        if (pass == 1) break;\n        pass = 1;\n        at = lineText.length;\n        continue;\n      }\n      if (pass == 1 && found < start.ch) break;\n      tokenType = cm.getTokenTypeAt(CodeMirror.Pos(line, found + 1));\n      if (!/^(comment|string)/.test(tokenType)) return found + 1;\n      at = found - 1;\n    }\n  }\n\n  var startToken = \"{\", endToken = \"}\", startCh = findOpening(\"{\");\n  if (startCh == null) {\n    startToken = \"[\", endToken = \"]\";\n    startCh = findOpening(\"[\");\n  }\n\n  if (startCh == null) return;\n  var count = 1, lastLine = cm.lastLine(), end, endCh;\n  outer: for (var i = line; i <= lastLine; ++i) {\n    var text = cm.getLine(i), pos = i == line ? startCh : 0;\n    for (;;) {\n      var nextOpen = text.indexOf(startToken, pos), nextClose = text.indexOf(endToken, pos);\n      if (nextOpen < 0) nextOpen = text.length;\n      if (nextClose < 0) nextClose = text.length;\n      pos = Math.min(nextOpen, nextClose);\n      if (pos == text.length) break;\n      if (cm.getTokenTypeAt(CodeMirror.Pos(i, pos + 1)) == tokenType) {\n        if (pos == nextOpen) ++count;\n        else if (!--count) { end = i; endCh = pos; break outer; }\n      }\n      ++pos;\n    }\n  }\n  if (end == null || line == end && endCh == startCh) return;\n  return {from: CodeMirror.Pos(line, startCh),\n          to: CodeMirror.Pos(end, endCh)};\n});\n\nCodeMirror.registerHelper(\"fold\", \"import\", function(cm, start) {\n  function hasImport(line) {\n    if (line < cm.firstLine() || line > cm.lastLine()) return null;\n    var start = cm.getTokenAt(CodeMirror.Pos(line, 1));\n    if (!/\\S/.test(start.string)) start = cm.getTokenAt(CodeMirror.Pos(line, start.end + 1));\n    if (start.type != \"keyword\" || start.string != \"import\") return null;\n    // Now find closing semicolon, return its position\n    for (var i = line, e = Math.min(cm.lastLine(), line + 10); i <= e; ++i) {\n      var text = cm.getLine(i), semi = text.indexOf(\";\");\n      if (semi != -1) return {startCh: start.end, end: CodeMirror.Pos(i, semi)};\n    }\n  }\n\n  var start = start.line, has = hasImport(start), prev;\n  if (!has || hasImport(start - 1) || ((prev = hasImport(start - 2)) && prev.end.line == start - 1))\n    return null;\n  for (var end = has.end;;) {\n    var next = hasImport(end.line + 1);\n    if (next == null) break;\n    end = next.end;\n  }\n  return {from: cm.clipPos(CodeMirror.Pos(start, has.startCh + 1)), to: end};\n});\n\nCodeMirror.registerHelper(\"fold\", \"include\", function(cm, start) {\n  function hasInclude(line) {\n    if (line < cm.firstLine() || line > cm.lastLine()) return null;\n    var start = cm.getTokenAt(CodeMirror.Pos(line, 1));\n    if (!/\\S/.test(start.string)) start = cm.getTokenAt(CodeMirror.Pos(line, start.end + 1));\n    if (start.type == \"meta\" && start.string.slice(0, 8) == \"#include\") return start.start + 8;\n  }\n\n  var start = start.line, has = hasInclude(start);\n  if (has == null || hasInclude(start - 1) != null) return null;\n  for (var end = start;;) {\n    var next = hasInclude(end + 1);\n    if (next == null) break;\n    ++end;\n  }\n  return {from: CodeMirror.Pos(start, has + 1),\n          to: cm.clipPos(CodeMirror.Pos(end))};\n});\n\n});\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  function doFold(cm, pos, options, force) {\n    if (options && options.call) {\n      var finder = options;\n      options = null;\n    } else {\n      var finder = getOption(cm, options, \"rangeFinder\");\n    }\n    if (typeof pos == \"number\") pos = CodeMirror.Pos(pos, 0);\n    var minSize = getOption(cm, options, \"minFoldSize\");\n\n    function getRange(allowFolded) {\n      var range = finder(cm, pos);\n      if (!range || range.to.line - range.from.line < minSize) return null;\n      var marks = cm.findMarksAt(range.from);\n      for (var i = 0; i < marks.length; ++i) {\n        if (marks[i].__isFold && force !== \"fold\") {\n          if (!allowFolded) return null;\n          range.cleared = true;\n          marks[i].clear();\n        }\n      }\n      return range;\n    }\n\n    var range = getRange(true);\n    if (getOption(cm, options, \"scanUp\")) while (!range && pos.line > cm.firstLine()) {\n      pos = CodeMirror.Pos(pos.line - 1, 0);\n      range = getRange(false);\n    }\n    if (!range || range.cleared || force === \"unfold\") return;\n\n    var myWidget = makeWidget(cm, options);\n    CodeMirror.on(myWidget, \"mousedown\", function(e) {\n      myRange.clear();\n      CodeMirror.e_preventDefault(e);\n    });\n    var myRange = cm.markText(range.from, range.to, {\n      replacedWith: myWidget,\n      clearOnEnter: true,\n      __isFold: true\n    });\n    myRange.on(\"clear\", function(from, to) {\n      CodeMirror.signal(cm, \"unfold\", cm, from, to);\n    });\n    CodeMirror.signal(cm, \"fold\", cm, range.from, range.to);\n  }\n\n  function makeWidget(cm, options) {\n    var widget = getOption(cm, options, \"widget\");\n    if (typeof widget == \"string\") {\n      var text = document.createTextNode(widget);\n      widget = document.createElement(\"span\");\n      widget.appendChild(text);\n      widget.className = \"CodeMirror-foldmarker\";\n    }\n    return widget;\n  }\n\n  // Clumsy backwards-compatible interface\n  CodeMirror.newFoldFunction = function(rangeFinder, widget) {\n    return function(cm, pos) { doFold(cm, pos, {rangeFinder: rangeFinder, widget: widget}); };\n  };\n\n  // New-style interface\n  CodeMirror.defineExtension(\"foldCode\", function(pos, options, force) {\n    doFold(this, pos, options, force);\n  });\n\n  CodeMirror.defineExtension(\"isFolded\", function(pos) {\n    var marks = this.findMarksAt(pos);\n    for (var i = 0; i < marks.length; ++i)\n      if (marks[i].__isFold) return true;\n  });\n\n  CodeMirror.commands.toggleFold = function(cm) {\n    cm.foldCode(cm.getCursor());\n  };\n  CodeMirror.commands.fold = function(cm) {\n    cm.foldCode(cm.getCursor(), null, \"fold\");\n  };\n  CodeMirror.commands.unfold = function(cm) {\n    cm.foldCode(cm.getCursor(), null, \"unfold\");\n  };\n  CodeMirror.commands.foldAll = function(cm) {\n    cm.operation(function() {\n      for (var i = cm.firstLine(), e = cm.lastLine(); i <= e; i++)\n        cm.foldCode(CodeMirror.Pos(i, 0), null, \"fold\");\n    });\n  };\n  CodeMirror.commands.unfoldAll = function(cm) {\n    cm.operation(function() {\n      for (var i = cm.firstLine(), e = cm.lastLine(); i <= e; i++)\n        cm.foldCode(CodeMirror.Pos(i, 0), null, \"unfold\");\n    });\n  };\n\n  CodeMirror.registerHelper(\"fold\", \"combine\", function() {\n    var funcs = Array.prototype.slice.call(arguments, 0);\n    return function(cm, start) {\n      for (var i = 0; i < funcs.length; ++i) {\n        var found = funcs[i](cm, start);\n        if (found) return found;\n      }\n    };\n  });\n\n  CodeMirror.registerHelper(\"fold\", \"auto\", function(cm, start) {\n    var helpers = cm.getHelpers(start, \"fold\");\n    for (var i = 0; i < helpers.length; i++) {\n      var cur = helpers[i](cm, start);\n      if (cur) return cur;\n    }\n  });\n\n  var defaultOptions = {\n    rangeFinder: CodeMirror.fold.auto,\n    widget: \"\\u2194\",\n    minFoldSize: 0,\n    scanUp: false\n  };\n\n  CodeMirror.defineOption(\"foldOptions\", null);\n\n  function getOption(cm, options, name) {\n    if (options && options[name] !== undefined)\n      return options[name];\n    var editorOptions = cm.options.foldOptions;\n    if (editorOptions && editorOptions[name] !== undefined)\n      return editorOptions[name];\n    return defaultOptions[name];\n  }\n});\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"), require(\"./foldcode\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\", \"./foldcode\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.defineOption(\"foldGutter\", false, function(cm, val, old) {\n    if (old && old != CodeMirror.Init) {\n      cm.clearGutter(cm.state.foldGutter.options.gutter);\n      cm.state.foldGutter = null;\n      cm.off(\"gutterClick\", onGutterClick);\n      cm.off(\"change\", onChange);\n      cm.off(\"viewportChange\", onViewportChange);\n      cm.off(\"fold\", onFold);\n      cm.off(\"unfold\", onFold);\n      cm.off(\"swapDoc\", updateInViewport);\n    }\n    if (val) {\n      cm.state.foldGutter = new State(parseOptions(val));\n      updateInViewport(cm);\n      cm.on(\"gutterClick\", onGutterClick);\n      cm.on(\"change\", onChange);\n      cm.on(\"viewportChange\", onViewportChange);\n      cm.on(\"fold\", onFold);\n      cm.on(\"unfold\", onFold);\n      cm.on(\"swapDoc\", updateInViewport);\n    }\n  });\n\n  var Pos = CodeMirror.Pos;\n\n  function State(options) {\n    this.options = options;\n    this.from = this.to = 0;\n  }\n\n  function parseOptions(opts) {\n    if (opts === true) opts = {};\n    if (opts.gutter == null) opts.gutter = \"CodeMirror-foldgutter\";\n    if (opts.indicatorOpen == null) opts.indicatorOpen = \"CodeMirror-foldgutter-open\";\n    if (opts.indicatorFolded == null) opts.indicatorFolded = \"CodeMirror-foldgutter-folded\";\n    return opts;\n  }\n\n  function isFolded(cm, line) {\n    var marks = cm.findMarksAt(Pos(line));\n    for (var i = 0; i < marks.length; ++i)\n      if (marks[i].__isFold && marks[i].find().from.line == line) return true;\n  }\n\n  function marker(spec) {\n    if (typeof spec == \"string\") {\n      var elt = document.createElement(\"div\");\n      elt.className = spec + \" CodeMirror-guttermarker-subtle\";\n      return elt;\n    } else {\n      return spec.cloneNode(true);\n    }\n  }\n\n  function updateFoldInfo(cm, from, to) {\n    var opts = cm.state.foldGutter.options, cur = from;\n    cm.eachLine(from, to, function(line) {\n      var mark = null;\n      if (isFolded(cm, cur)) {\n        mark = marker(opts.indicatorFolded);\n      } else {\n        var pos = Pos(cur, 0), func = opts.rangeFinder || CodeMirror.fold.auto;\n        var range = func && func(cm, pos);\n        if (range && range.from.line + 1 < range.to.line)\n          mark = marker(opts.indicatorOpen);\n      }\n      cm.setGutterMarker(line, opts.gutter, mark);\n      ++cur;\n    });\n  }\n\n  function updateInViewport(cm) {\n    var vp = cm.getViewport(), state = cm.state.foldGutter;\n    if (!state) return;\n    cm.operation(function() {\n      updateFoldInfo(cm, vp.from, vp.to);\n    });\n    state.from = vp.from; state.to = vp.to;\n  }\n\n  function onGutterClick(cm, line, gutter) {\n    var opts = cm.state.foldGutter.options;\n    if (gutter != opts.gutter) return;\n    cm.foldCode(Pos(line, 0), opts.rangeFinder);\n  }\n\n  function onChange(cm) {\n    var state = cm.state.foldGutter, opts = cm.state.foldGutter.options;\n    state.from = state.to = 0;\n    clearTimeout(state.changeUpdate);\n    state.changeUpdate = setTimeout(function() { updateInViewport(cm); }, opts.foldOnChangeTimeSpan || 600);\n  }\n\n  function onViewportChange(cm) {\n    var state = cm.state.foldGutter, opts = cm.state.foldGutter.options;\n    clearTimeout(state.changeUpdate);\n    state.changeUpdate = setTimeout(function() {\n      var vp = cm.getViewport();\n      if (state.from == state.to || vp.from - state.to > 20 || state.from - vp.to > 20) {\n        updateInViewport(cm);\n      } else {\n        cm.operation(function() {\n          if (vp.from < state.from) {\n            updateFoldInfo(cm, vp.from, state.from);\n            state.from = vp.from;\n          }\n          if (vp.to > state.to) {\n            updateFoldInfo(cm, state.to, vp.to);\n            state.to = vp.to;\n          }\n        });\n      }\n    }, opts.updateViewportTimeSpan || 400);\n  }\n\n  function onFold(cm, from) {\n    var state = cm.state.foldGutter, line = from.line;\n    if (line >= state.from && line < state.to)\n      updateFoldInfo(cm, line, line + 1);\n  }\n});\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  var ie_lt8 = /MSIE \\d/.test(navigator.userAgent) &&\n    (document.documentMode == null || document.documentMode < 8);\n\n  var Pos = CodeMirror.Pos;\n\n  var matching = {\"(\": \")>\", \")\": \"(<\", \"[\": \"]>\", \"]\": \"[<\", \"{\": \"}>\", \"}\": \"{<\"};\n\n  function findMatchingBracket(cm, where, strict, config) {\n    var line = cm.getLineHandle(where.line), pos = where.ch - 1;\n    var match = (pos >= 0 && matching[line.text.charAt(pos)]) || matching[line.text.charAt(++pos)];\n    if (!match) return null;\n    var dir = match.charAt(1) == \">\" ? 1 : -1;\n    if (strict && (dir > 0) != (pos == where.ch)) return null;\n    var style = cm.getTokenTypeAt(Pos(where.line, pos + 1));\n\n    var found = scanForBracket(cm, Pos(where.line, pos + (dir > 0 ? 1 : 0)), dir, style || null, config);\n    if (found == null) return null;\n    return {from: Pos(where.line, pos), to: found && found.pos,\n            match: found && found.ch == match.charAt(0), forward: dir > 0};\n  }\n\n  // bracketRegex is used to specify which type of bracket to scan\n  // should be a regexp, e.g. /[[\\]]/\n  //\n  // Note: If \"where\" is on an open bracket, then this bracket is ignored.\n  //\n  // Returns false when no bracket was found, null when it reached\n  // maxScanLines and gave up\n  function scanForBracket(cm, where, dir, style, config) {\n    var maxScanLen = (config && config.maxScanLineLength) || 10000;\n    var maxScanLines = (config && config.maxScanLines) || 1000;\n\n    var stack = [];\n    var re = config && config.bracketRegex ? config.bracketRegex : /[(){}[\\]]/;\n    var lineEnd = dir > 0 ? Math.min(where.line + maxScanLines, cm.lastLine() + 1)\n                          : Math.max(cm.firstLine() - 1, where.line - maxScanLines);\n    for (var lineNo = where.line; lineNo != lineEnd; lineNo += dir) {\n      var line = cm.getLine(lineNo);\n      if (!line) continue;\n      var pos = dir > 0 ? 0 : line.length - 1, end = dir > 0 ? line.length : -1;\n      if (line.length > maxScanLen) continue;\n      if (lineNo == where.line) pos = where.ch - (dir < 0 ? 1 : 0);\n      for (; pos != end; pos += dir) {\n        var ch = line.charAt(pos);\n        if (re.test(ch) && (style === undefined || cm.getTokenTypeAt(Pos(lineNo, pos + 1)) == style)) {\n          var match = matching[ch];\n          if ((match.charAt(1) == \">\") == (dir > 0)) stack.push(ch);\n          else if (!stack.length) return {pos: Pos(lineNo, pos), ch: ch};\n          else stack.pop();\n        }\n      }\n    }\n    return lineNo - dir == (dir > 0 ? cm.lastLine() : cm.firstLine()) ? false : null;\n  }\n\n  function matchBrackets(cm, autoclear, config) {\n    // Disable brace matching in long lines, since it'll cause hugely slow updates\n    var maxHighlightLen = cm.state.matchBrackets.maxHighlightLineLength || 1000;\n    var marks = [], ranges = cm.listSelections();\n    for (var i = 0; i < ranges.length; i++) {\n      var match = ranges[i].empty() && findMatchingBracket(cm, ranges[i].head, false, config);\n      if (match && cm.getLine(match.from.line).length <= maxHighlightLen) {\n        var style = match.match ? \"CodeMirror-matchingbracket\" : \"CodeMirror-nonmatchingbracket\";\n        marks.push(cm.markText(match.from, Pos(match.from.line, match.from.ch + 1), {className: style}));\n        if (match.to && cm.getLine(match.to.line).length <= maxHighlightLen)\n          marks.push(cm.markText(match.to, Pos(match.to.line, match.to.ch + 1), {className: style}));\n      }\n    }\n\n    if (marks.length) {\n      // Kludge to work around the IE bug from issue #1193, where text\n      // input stops going to the textare whever this fires.\n      if (ie_lt8 && cm.state.focused) cm.display.input.focus();\n\n      var clear = function() {\n        cm.operation(function() {\n          for (var i = 0; i < marks.length; i++) marks[i].clear();\n        });\n      };\n      if (autoclear) setTimeout(clear, 800);\n      else return clear;\n    }\n  }\n\n  var currentlyHighlighted = null;\n  function doMatchBrackets(cm) {\n    cm.operation(function() {\n      if (currentlyHighlighted) {currentlyHighlighted(); currentlyHighlighted = null;}\n      currentlyHighlighted = matchBrackets(cm, false, cm.state.matchBrackets);\n    });\n  }\n\n  CodeMirror.defineOption(\"matchBrackets\", false, function(cm, val, old) {\n    if (old && old != CodeMirror.Init)\n      cm.off(\"cursorActivity\", doMatchBrackets);\n    if (val) {\n      cm.state.matchBrackets = typeof val == \"object\" ? val : {};\n      cm.on(\"cursorActivity\", doMatchBrackets);\n    }\n  });\n\n  CodeMirror.defineExtension(\"matchBrackets\", function() {matchBrackets(this, true);});\n  CodeMirror.defineExtension(\"findMatchingBracket\", function(pos, strict, config){\n    return findMatchingBracket(this, pos, strict, config);\n  });\n  CodeMirror.defineExtension(\"scanForBracket\", function(pos, dir, style, config){\n    return scanForBracket(this, pos, dir, style, config);\n  });\n});\n"]}