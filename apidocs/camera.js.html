<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: camera.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: camera.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>(function () {
  'use strict';

  var inherit = require('./inherit');
  var object = require('./object');
  var util = require('./util');
  var mat4 = require('gl-mat4');
  var vec4 = require('gl-vec4');

  //////////////////////////////////////////////////////////////////////////////
  /**
   * This class defines the raw interface for a camera.  At a low level, the
   * camera provides a methods for converting between a map's coordinate system
   * to display pixel coordinates.
   *
   * For the moment, all camera transforms are assumed to be expressible as
   * 4x4 matrices.  More general cameras may follow that break this assumption.
   *
   * The interface for the camera is relatively stable for "map-like" views,
   * e.g. when the camera is pointing in the direction [0, 0, -1], and placed
   * above the z=0 plane.  More general view changes and events have not yet
   * been defined.
   *
   * The camera emits the following events when the view changes:
   *
   *   * {@link geo.event.camera.pan} when the camera is translated in the
   *       x/y plane
   *   * {@link geo.event.camera.zoom} when the camera is changed in a way
   *       that modifies the current zoom level
   *   * {@link geo.event.camera.view} when the visible bounds change for
   *       any reason
   *   * {@link geo.event.camera.projection} when the projection type changes
   *   * {@link geo.event.camera.viewport} when the viewport changes
   *
   * By convention, protected methods do not update the internal matrix state,
   * public methods do.  There are a few primary methods that are intended to
   * be used by external classes to mutate the internal state:
   *
   *   * bounds: Set the visible bounds (for initialization and zooming)
   *   * pan: Translate the camera in x/y by an offset (for panning)
   *   * viewFromCenterSizeRotation: set the camera view based on a center
   *        point, boundary size, and rotation angle.
   *
   * @class geo.camera
   * @extends geo.object
   * @param {object?} spec Options argument
   * @param {string} spec.projection One of the supported geo.camera.projection
   * @param {object} spec.viewport The initial camera viewport
   * @param {object} spec.viewport.width
   * @param {object} spec.viewport.height
   * @returns {geo.camera}
   */
  //////////////////////////////////////////////////////////////////////////////
  var camera = function (spec) {
    if (!(this instanceof camera)) {
      return new camera(spec);
    }

    var geo_event = require('./event');

    spec = spec || {};
    object.call(this, spec);

    /**
     * The view matrix
     * @protected
     */
    this._view = util.mat4AsArray();

    /**
     * The projection matrix
     * @protected
     */
    this._proj = util.mat4AsArray();

    /**
     * The projection type (one of `this.constructor.projection`)
     * @protected
     */
    this._projection = null;

    /**
     * The transform matrix (view * proj)
     * @protected
     */
    this._transform = util.mat4AsArray();

    /**
     * The inverse transform matrix (view * proj)^-1
     * @protected
     */
    this._inverse = util.mat4AsArray();

    /**
     * Cached bounds object recomputed on demand.
     * @protected
     */
    this._bounds = null;

    /**
     * Cached "display" matrix recomputed on demand.
     * @see {@link geo.camera.display}
     * @protected
     */
    this._display = null;

    /**
     * Cached "world" matrix recomputed on demand.
     * @see {@link geo.camera.world}
     * @protected
     */
    this._world = null;

    /**
     * The viewport parameters size and offset.
     * @property {number} height Viewport height in pixels
     * @property {number} width Viewport width in pixels
     * @protected
     */
    this._viewport = {width: 1, height: 1};

    /**
     * Set up the projection matrix for the current projection type.
     * @protected
     */
    this._createProj = function () {
      var s = this.constructor.bounds.near / this.constructor.bounds.far;

      // call mat4.frustum or mat4.ortho here
      if (this._projection === 'perspective') {
        mat4.frustum(
          this._proj,
          this.constructor.bounds.left * s,
          this.constructor.bounds.right * s,
          this.constructor.bounds.bottom * s,
          this.constructor.bounds.top * s,
          -this.constructor.bounds.near,
          -this.constructor.bounds.far
        );
      } else if (this._projection === 'parallel') {
        mat4.ortho(
          this._proj,
          this.constructor.bounds.left,
          this.constructor.bounds.right,
          this.constructor.bounds.bottom,
          this.constructor.bounds.top,
          this.constructor.bounds.near,
          this.constructor.bounds.far
        );
      }
    };

    /**
     * Update the internal state of the camera on change to camera
     * parameters.
     * @protected
     */
    this._update = function () {
      this._bounds = null;
      this._display = null;
      this._world = null;
      this._transform = camera.combine(this._proj, this._view);
      mat4.invert(this._inverse, this._transform);
      this.geoTrigger(geo_event.camera.view, {
        camera: this
      });
    };

    /**
     * Getter/setter for the view matrix.
     * @note copies the matrix value on set.
     */
    Object.defineProperty(this, 'view', {
      get: function () {
        return this._view;
      },
      set: function (view) {
        mat4.copy(this._view, view);
        this._update();
      }
    });

    /**
     * Getter/setter for the view bounds.
     *
     * If not provided, near and far bounds will be set to [-1, 1] by
     * default.  We will probably want to change this to a unit specific
     * value initialized by the map when drawing true 3D objects or
     * tilting the camera.
     *
     * Returned near/far bounds are also -1, 1 for the moment.
     */
    Object.defineProperty(this, 'bounds', {
      get: function () {
        if (this._bounds === null) {
          this._bounds = this._getBounds();
        }
        return this._bounds;
      },
      set: function (bounds) {
        this._setBounds(bounds);
        this._update();
      }
    });

    /**
     * Getter for the "display" matrix.  This matrix converts from
     * world coordinates into display coordinates.  This matrix exists to
     * generate matrix3d css transforms that can be used in layers that
     * render on the DOM.
     */
    Object.defineProperty(this, 'display', {
      get: function () {
        var mat;
        if (this._display === null) {
          mat = camera.affine(
            {x: 1, y: 1}, // translate to: [0, 2] x [0, 2]
            {
              x: this.viewport.width / 2,
              y: this.viewport.height / -2
            }             // scale to: [0, width] x [-height, 0]
          );

          // applies mat to the transform (world -> normalized)
          this._display = camera.combine(
            mat,
            this._transform
          );
        }
        return this._display;
      }
    });

    /**
     * Getter for the "world" matrix.  This matrix converts from
     * display coordinates into world coordinates.  This is constructed
     * by inverting the "display" matrix.
     */
    Object.defineProperty(this, 'world', {
      get: function () {
        if (this._world === null) {
          this._world = mat4.invert(
            util.mat4AsArray(),
            this.display
          );
        }
        return this._world;
      }
    });

    /**
     * Getter/setter for the projection type.
     */
    Object.defineProperty(this, 'projection', {
      get: function () {
        return this._projection;
      },
      set: function (type) {
        if (!this.constructor.projection[type]) {
          throw new Error('Unsupported projection type: ' + type);
        }
        if (type !== this._projection) {
          this._projection = type;
          this._createProj();
          this._update();
          this.geoTrigger(geo_event.camera.projection, {
            camera: this,
            projection: type
          });
        }
      }
    });

    /**
     * Getter for the projection matrix (when applicable).
     * This generally shouldn't be modified directly because
     * the rest of the code assumes that the clipping bounds
     * are [-1, -1, -1] to [1, 1, 1] in camera coordinates.
     */
    Object.defineProperty(this, 'projectionMatrix', {
      get: function () {
        return this._proj;
      }
    });

    /**
     * Getter for the transform matrix.
     */
    Object.defineProperty(this, 'transform', {
      get: function () {
        return this._transform;
      }
    });

    /**
     * Getter for the inverse transform matrix.
     */
    Object.defineProperty(this, 'inverse', {
      get: function () {
        return this._inverse;
      }
    });

    /**
     * Getter/setter for the viewport.
     */
    Object.defineProperty(this, 'viewport', {
      get: function () {
        return {width: this._viewport.width, height: this._viewport.height};
      },
      set: function (viewport) {
        if (!(viewport.width > 0 &amp;&amp;
              viewport.height > 0)) {
          throw new Error('Invalid viewport dimensions');
        }
        if (viewport.width === this._viewport.width &amp;&amp;
            viewport.height === this._viewport.height) {
          return;
        }

        // apply scaling to the view matrix to account for the new aspect ratio
        // without changing the apparent zoom level
        if (this._viewport.width &amp;&amp; this._viewport.height) {
          this._scale([
            this._viewport.width / viewport.width,
            this._viewport.height / viewport.height,
            1
          ]);

          // translate by half the difference to keep the center the same
          this._translate([
            (viewport.width - this._viewport.width) / 2,
            (viewport.height - this._viewport.height) / 2,
            0
          ]);
        }

        this._viewport = {width: viewport.width, height: viewport.height};
        this._update();
        this.geoTrigger(geo_event.camera.viewport, {
          camera: this,
          viewport: this.viewport
        });
      }
    });

    /**
     * Reset the view matrix to its initial (identity) state.
     * @protected
     * @returns {this} Chainable
     */
    this._resetView = function () {
      mat4.identity(this._view);
      return this;
    };

    /**
     * Uses `mat4.translate` to translate the camera by the given vector amount.
     * @protected
     * @param {vec3|Array} offset The camera translation vector
     * @returns {this} Chainable
     */
    this._translate = function (offset) {
      mat4.translate(this._view, this._view, offset);
    };

    /**
     * Uses `mat4.scale` to scale the camera by the given vector amount.
     * @protected
     * @param {vec3|Array} scale The scaling vector
     * @returns {this} Chainable
     */
    this._scale = function (scale) {
      mat4.scale(this._view, this._view, scale);
    };

    /**
     * Project a vec4 from world space into clipped space [-1, 1] in place
     * @protected
     * @param {vec4} point The point in world coordinates (mutated)
     * @returns {vec4} The point in clip space coordinates
     */
    this._worldToClip4 = function (point) {
      return camera.applyTransform(this._transform, point);
    };

    /**
     * Project a vec4 from clipped space into world space in place
     * @protected
     * @param {vec4} point The point in clipped coordinates (mutated)
     * @returns {vec4} The point in world space coordinates
     */
    this._clipToWorld4 = function (point) {
      return camera.applyTransform(this._inverse, point);
    };

    /**
     * Apply the camera's projection transform to the given point.
     * @param {vec4} pt a point in clipped coordinates
     * @returns {vec4} the point in normalized coordinates
     */
    this.applyProjection = function (pt) {
      var w;
      if (this._projection === 'perspective') {
        w = 1 / (pt[3] || 1);
        pt[0] = w * pt[0];
        pt[1] = w * pt[1];
        pt[2] = w * pt[2];
        pt[3] = w;
      } else {
        pt[3] = 1;
      }
      return pt;
    };

    /**
     * Unapply the camera's projection transform from the given point.
     * @param {vec4} pt a point in normalized coordinates
     * @returns {vec4} the point in clipped coordinates
     */
    this.unapplyProjection = function (pt) {
      var w;
      if (this._projection === 'perspective') {
        w = pt[3] || 1;
        pt[0] = w * pt[0];
        pt[1] = w * pt[1];
        pt[2] = w * pt[2];
        pt[3] = w;
      } else {
        pt[3] = 1;
      }
      return pt;
    };

    /**
     * Project a vec4 from world space into viewport space.
     * @param {vec4} point The point in world coordinates (mutated)
     * @returns {vec4} The point in display coordinates
     *
     * @note For the moment, this computation assumes the following:
     *   * point[3] > 0
     *   * depth range [0, 1]
     *
     * The clip space z and w coordinates are returned with the window
     * x/y coordinates.
     */
    this.worldToDisplay4 = function (point) {
      // This is because z = 0 is the far plane exposed to the user, but
      // internally the far plane is at -2.
      point[2] -= 2;

      // convert to clip space
      this._worldToClip4(point);

      // apply projection specific transformation
      point = this.applyProjection(point);

      // convert to display space
      point[0] = this._viewport.width * (1 + point[0]) / 2.0;
      point[1] = this._viewport.height * (1 - point[1]) / 2.0;
      point[2] = (1 + point[2]) / 2.0;
      return point;
    };

    /**
     * Project a vec4 from display space into world space in place.
     * @param {vec4} point The point in display coordinates (mutated)
     * @returns {vec4} The point in world space coordinates
     *
     * @note For the moment, this computation assumes the following:
     *   * point[3] > 0
     *   * depth range [0, 1]
     */
    this.displayToWorld4 = function (point) {
      // convert to clip space
      point[0] = 2 * point[0] / this._viewport.width - 1;
      point[1] = -2 * point[1] / this._viewport.height + 1;
      point[2] = 2 * point[2] - 1;

      // invert projection transform
      point = this.unapplyProjection(point);

      // convert to world coordinates
      this._clipToWorld4(point);

      // move far surface to z = 0
      point[2] += 2;
      return point;
    };

    /**
     * Project a point object from world space into viewport space.
     * @param {object} point The point in world coordinates
     * @param {number} point.x
     * @param {number} point.y
     * @returns {object} The point in display coordinates
     */
    this.worldToDisplay = function (point) {
      // define some magic numbers:
      var z = 0, // z coordinate of the surface in world coordinates
          w = 1; // enables perspective divide (i.e. for point conversion)
      point = this.worldToDisplay4(
        [point.x, point.y, z, w]
      );
      return {x: point[0], y: point[1], z: point[2]};
    };

    /**
     * Project a point object from viewport space into world space.
     * @param {object} point The point in display coordinates
     * @param {number} point.x
     * @param {number} point.y
     * @returns {object} The point in world coordinates
     */
    this.displayToWorld = function (point) {
      // define some magic numbers:
      var z = 1, // the z coordinate of the surface
          w = 2; // perspective divide at z = 1
      point = this.displayToWorld4(
        [point.x, point.y, z, w]
      );
      return {x: point[0], y: point[1]};
    };

    /**
     * Calculate the current bounds in world coordinates from the
     * current view matrix.  This computes a matrix vector multiplication
     * so the result is cached for public facing methods.
     *
     * @protected
     * @returns {object} bounds object
     */
    this._getBounds = function () {
      var ul, ur, ll, lr, bds = {};

      // get corners
      ul = this.displayToWorld({x: 0, y: 0});
      ur = this.displayToWorld({x: this._viewport.width, y: 0});
      ll = this.displayToWorld({x: 0, y: this._viewport.height});
      lr = this.displayToWorld({
        x: this._viewport.width,
        y: this._viewport.height
      });

      bds.left = Math.min(ul.x, ur.x, ll.x, lr.x);
      bds.bottom = Math.min(ul.y, ur.y, ll.y, lr.y);
      bds.right = Math.max(ul.x, ur.x, ll.x, lr.x);
      bds.top = Math.max(ul.y, ur.y, ll.y, lr.y);

      return bds;
    };

    /**
     * Sets the view matrix so that the given world bounds
     * are in view.  To account for the viewport aspect ratio,
     * the resulting bounds may be larger in width or height than
     * the requested bound, but should be centered in the frame.
     *
     * @protected
     * @param {object} bounds
     * @param {number} bounds.left
     * @param {number} bounds.right
     * @param {number} bounds.bottom
     * @param {number} bounds.top
     * @param {number?} bounds.near Currently ignored
     * @param {number?} bounds.far Currently ignored
     * @return {this} Chainable
     */
    this._setBounds = function (bounds) {
      var size = {
        width: bounds.right - bounds.left,
        height: bounds.top - bounds.bottom
      };
      var center = {
        x: (bounds.left + bounds.right) / 2,
        y: (bounds.bottom + bounds.top) / 2
      };

      this._viewFromCenterSizeRotation(center, size, 0);
      return this;
    };

    /**
     * Sets the view matrix so that the given world center is centered, at
     * least a certain width and height are visible, and a rotation is applied.
     * The resulting bounds may be larger in width or height than the values if
     * the viewport is a different aspect ratio.
     *
     * @protected
     * @param {object} center
     * @param {number} center.x
     * @param {number} center.y
     * @param {object} size
     * @param {number} size.width
     * @param {number} size.height
     * @param {number} rotation in clockwise radians.  Optional
     * @return {this} Chainable
     */
    this._viewFromCenterSizeRotation = function (center, size, rotation) {
      var translate = util.vec3AsArray(),
          scale = util.vec3AsArray(),
          c_ar, v_ar, w, h;

      // reset view to the identity
      this._resetView();

      w = Math.abs(size.width);
      h = Math.abs(size.height);
      c_ar = w / h;
      v_ar = this._viewport.width / this._viewport.height;

      if (c_ar >= v_ar) {
        // grow camera bounds vertically
        h = w / v_ar;
        scale[0] = 2 / w;
        scale[1] = 2 / h;
      } else {
        // grow bounds horizontally
        w = h * v_ar;
        scale[0] = 2 / w;
        scale[1] = 2 / h;
      }

      scale[2] = 1;
      this._scale(scale);

      if (rotation) {
        this._rotate(rotation);
      }

      // translate to the new center.
      translate[0] = -center.x;
      translate[1] = -center.y;
      translate[2] = 0;

      this._translate(translate);

      return this;
    };

    /**
     * Public exposure of the viewFromCenterSizeRotation function.
     */
    this.viewFromCenterSizeRotation = function (center, size, rotation) {
      this._viewFromCenterSizeRotation(center, size, rotation);
      this._update();
      return this;
    };

    /**
     * Pans the view matrix by the given amount.
     *
     * @param {object} offset The delta in world space coordinates.
     * @param {number} offset.x
     * @param {number} offset.y
     * @param {number} [offset.z=0]
     */
    this.pan = function (offset) {
      if (!offset.x &amp;&amp; !offset.y &amp;&amp; !offset.z) {
        return;
      }
      this._translate([
        offset.x,
        offset.y,
        offset.z || 0
      ]);
      this._update();
    };

    /**
     * Zooms the view matrix by the given amount.
     *
     * @param {number} zoom The zoom scale to apply
     */
    this.zoom = function (zoom) {
      if (zoom === 1) {
        return;
      }
      mat4.scale(this._view, this._view, [
        zoom,
        zoom,
        zoom
      ]);
      this._update();
    };

    /**
     * Rotate the view matrix by the given amount.
     *
     * @param {number} rotation Counter-clockwise rotation angle in radians.
     * @param {object} center Center of rotation in world space coordinates.
     * @param {vec3} axis acis of rotation.  Defaults to [0, 0, -1]
     */
    this._rotate = function (rotation, center, axis) {
      if (!rotation) {
        return;
      }
      axis = axis || [0, 0, -1];
      if (!center) {
        center = [0, 0, 0];
      } else if (center.x !== undefined) {
        center = [center.x || 0, center.y || 0, center.z || 0];
      }
      var invcenter = [-center[0], -center[1], -center[2]];
      mat4.translate(this._view, this._view, center);
      mat4.rotate(this._view, this._view, rotation, axis);
      mat4.translate(this._view, this._view, invcenter);
    };

    /**
     * Returns a CSS transform that converts (by default) from world coordinates
     * into display coordinates.  This allows users of this module to
     * position elements using world coordinates directly inside DOM
     * elements.
     *
     * @note This transform will not take into account projection specific
     * transforms.  For perspective projections, one can use the properties
     * `perspective` and `perspective-origin` to apply the projection
     * in css directly.
     *
     * @param {string} transform The transform to return
     *   * display
     *   * world
     * @returns {string} The css transform string
     */
    this.css = function (transform) {
      var m;
      switch ((transform || '').toLowerCase()) {
        case 'display':
        case '':
          m = this.display;
          break;
        case 'world':
          m = this.world;
          break;
        default:
          throw new Error('Unknown transform ' + transform);
      }
      return camera.css(m);
    };

    /**
     * Represent a glmatrix as a pretty-printed string.
     * @param {mat4} mat A 4 x 4 matrix
     * @param {number} prec The number of decimal places
     * @returns {string}
     */
    this.ppMatrix = function (mat, prec) {
      var t = mat;
      prec = prec || 2;
      function f(i) {
        var d = t[i], s = d.toExponential(prec);
        if (d >= 0) {
          s = ' ' + s;
        }
        return s;
      }
      return [
        [f(0), f(4), f(8), f(12)].join(' '),
        [f(1), f(5), f(9), f(13)].join(' '),
        [f(2), f(6), f(10), f(14)].join(' '),
        [f(3), f(7), f(11), f(15)].join(' ')
      ].join('\n');
    };

    /**
     * Pretty print the transform matrix.
     */
    this.toString = function () {
      return this.ppMatrix(this._transform);
    };

    /**
     * Return a debugging string of the current camera state.
     */
    this.debug = function () {
      return [
        'bounds',
        JSON.stringify(this.bounds),
        'view:',
        this.ppMatrix(this._view),
        'projection:',
        this.ppMatrix(this._proj),
        'transform:',
        this.ppMatrix(this._transform)
      ].join('\n');
    };

    /**
     * Represent the value of the camera as its transform matrix.
     */
    this.valueOf = function () {
      return this._transform;
    };

    // initialize the view matrix
    this._resetView();

    // set up the projection matrix
    this.projection = spec.projection || 'parallel';

    // initialize the viewport
    if (spec.viewport) {
      this.viewport = spec.viewport;
    }

    // trigger an initial update to set up the camera state
    this._update();

    return this;
  };

  /**
   * Supported projection types.
   */
  camera.projection = {
    perspective: true,
    parallel: true
  };

  /**
   * Camera clipping bounds, probably shouldn't be modified.
   */
  camera.bounds = {
    left: -1,
    right: 1,
    top: 1,
    bottom: -1,
    far: -2,
    near: -1
  };

  /**
   * Output a mat4 as a css transform.
   * @param {mat4} t A matrix transform
   * @returns {string} A css transform string
   */
  camera.css = function (t) {
    return (
      'matrix3d(' +
        [
          t[0].toFixed(20),
          t[1].toFixed(20),
          t[2].toFixed(20),
          t[3].toFixed(20),
          t[4].toFixed(20),
          t[5].toFixed(20),
          t[6].toFixed(20),
          t[7].toFixed(20),
          t[8].toFixed(20),
          t[9].toFixed(20),
          t[10].toFixed(20),
          t[11].toFixed(20),
          t[12].toFixed(20),
          t[13].toFixed(20),
          t[14].toFixed(20),
          t[15].toFixed(20)
        ].join(',') +
      ')'
    );
  };

  /**
   * Generate a mat4 representing an affine coordinate transformation.
   *
   * For the following affine transform:
   *
   *    x |-> m * (x + a) + b
   *
   * applies the css transform:
   *
   *    translate(b) scale(m) translate(a)
   *
   * @param {object?} pre Coordinate offset **before** scaling
   * @param {object?} scale Coordinate scaling
   * @param {object?} post Coordinate offset **after** scaling
   * @returns {mat4} The new transform matrix
   */
  camera.affine = function (pre, scale, post) {
    var mat = util.mat4AsArray();

    // Note: mat4 operations are applied to the right side of the current
    // transform, so the first applied here is the last applied to the
    // coordinate.
    if (post) {
      mat4.translate(mat, mat, [post.x || 0, post.y || 0, post.z || 0]);
    }
    if (scale) {
      mat4.scale(mat, mat, [scale.x || 1, scale.y || 1, scale.z || 1]);
    }
    if (pre) {
      mat4.translate(mat, mat, [pre.x || 0, pre.y || 0, pre.z || 0]);
    }
    return mat;
  };

  /**
   * Apply the given transform matrix to a point in place.
   * @param {mat4} t
   * @param {vec4} pt
   * @returns {vec4}
   */
  camera.applyTransform = function (t, pt) {
    return vec4.transformMat4(pt, pt, t);
  };

  /**
   * Combine two transforms by multiplying their matrix representations.
   * @note The second transform provided will be the first applied in the
   * coordinate transform.
   * @param {mat4} A
   * @param {mat4} B
   * @returns {mat4} A * B
   */
  camera.combine = function (A, B) {
    return mat4.multiply(util.mat4AsArray(), A, B);
  };

  inherit(camera, object);
  module.exports = camera;
})();
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="geo.module_util.html">geo.util</a></li></ul><h3>Classes</h3><ul><li><a href="geo.annotation.html">geo.annotation</a></li><li><a href="geo.annotationLayer.html">geo.annotationLayer</a></li><li><a href="geo.camera.html">geo.camera</a></li><li><a href="geo.canvas.heatmapFeature.html">geo.canvas.heatmapFeature</a></li><li><a href="geo.canvas.object.html">geo.canvas.object</a></li><li><a href="geo.canvas.quadFeature.html">geo.canvas.quadFeature</a></li><li><a href="geo.canvas.renderer.html">geo.canvas.renderer</a></li><li><a href="geo.choroplethFeature.html">geo.choroplethFeature</a></li><li><a href="geo.clock.html">geo.clock</a></li><li><a href="geo.contourFeature.html">geo.contourFeature</a></li><li><a href="geo.d3.graphFeature.html">geo.d3.graphFeature</a></li><li><a href="geo.d3.lineFeature.html">geo.d3.lineFeature</a></li><li><a href="geo.d3.object.html">geo.d3.object</a></li><li><a href="geo.d3.pathFeature.html">geo.d3.pathFeature</a></li><li><a href="geo.d3.pointFeature.html">geo.d3.pointFeature</a></li><li><a href="geo.d3.quadFeature.html">geo.d3.quadFeature</a></li><li><a href="geo.d3.renderer.html">geo.d3.renderer</a></li><li><a href="geo.d3.vectorFeature.html">geo.d3.vectorFeature</a></li><li><a href="geo.domRenderer.html">geo.domRenderer</a></li><li><a href="geo.feature.html">geo.feature</a></li><li><a href="geo.featureLayer.html">geo.featureLayer</a></li><li><a href="geo.fetchQueue.html">geo.fetchQueue</a></li><li><a href="geo.fileReader.html">geo.fileReader</a></li><li><a href="geo.geomFeature.html">geo.geomFeature</a></li><li><a href="geo.gl.choroplethFeature.html">geo.gl.choroplethFeature</a></li><li><a href="geo.gl.contourFeature.html">geo.gl.contourFeature</a></li><li><a href="geo.gl.ellipsoid.html">geo.gl.ellipsoid</a></li><li><a href="geo.gl.geomFeature.html">geo.gl.geomFeature</a></li><li><a href="geo.gl.lineFeature.html">geo.gl.lineFeature</a></li><li><a href="geo.gl.object.html">geo.gl.object</a></li><li><a href="geo.gl.pointFeature.html">geo.gl.pointFeature</a></li><li><a href="geo.gl.polygonFeature.html">geo.gl.polygonFeature</a></li><li><a href="geo.gl.quadFeature.html">geo.gl.quadFeature</a></li><li><a href="geo.gl.vglRenderer.html">geo.gl.vglRenderer</a></li><li><a href="geo.greaphFeature.html">geo.greaphFeature</a></li><li><a href="geo.gui.legendWidget.html">geo.gui.legendWidget</a></li><li><a href="geo.gui.sliderWidget.html">geo.gui.sliderWidget</a></li><li><a href="geo.gui.svgWidget.html">geo.gui.svgWidget</a></li><li><a href="geo.gui.uiLayer.html">geo.gui.uiLayer</a></li><li><a href="geo.gui.widget.html">geo.gui.widget</a></li><li><a href="geo.heatmapFeature.html">geo.heatmapFeature</a></li><li><a href="geo.imageTile.html">geo.imageTile</a></li><li><a href="geo.jsonReader.html">geo.jsonReader</a></li><li><a href="geo.layer.html">geo.layer</a></li><li><a href="geo.lineFeature.html">geo.lineFeature</a></li><li><a href="geo.map.html">geo.map</a></li><li><a href="geo.mapInteractor.html">geo.mapInteractor</a></li><li><a href="geo.object.html">geo.object</a></li><li><a href="geo.osmLayer.html">geo.osmLayer</a></li><li><a href="geo.pathFeature.html">geo.pathFeature</a></li><li><a href="geo.pointFeature.html">geo.pointFeature</a></li><li><a href="geo.polygonFeature.html">geo.polygonFeature</a></li><li><a href="geo.quadFeature.html">geo.quadFeature</a></li><li><a href="geo.renderer.html">geo.renderer</a></li><li><a href="geo.sceneObject.html">geo.sceneObject</a></li><li><a href="geo.tile.html">geo.tile</a></li><li><a href="geo.tileCache.html">geo.tileCache</a></li><li><a href="geo.tileLayer.html">geo.tileLayer</a></li><li><a href="geo.timestamp.html">geo.timestamp</a></li><li><a href="geo.transform.html">geo.transform</a></li><li><a href="geo.util.ClusterGroup.html">geo.util.ClusterGroup</a></li><li><a href="geo.vectorFeature.html">geo.vectorFeature</a></li></ul><h3>Namespaces</h3><ul><li><a href="-_anonymous_-geo.util.html"><anonymous>~geo.util</a></li><li><a href="geo.canvas.html">geo.canvas</a></li><li><a href="geo.d3.html">geo.d3</a></li><li><a href="geo.event.html">geo.event</a></li><li><a href="geo.event.annotation.html">geo.event.annotation</a></li><li><a href="geo.event.camera.html">geo.event.camera</a></li><li><a href="geo.event.feature.html">geo.event.feature</a></li><li><a href="geo.gl.html">geo.gl</a></li><li><a href="geo.gui.html">geo.gui</a></li><li><a href="geo_event.clock.html">geo_event.clock</a></li></ul><h3>Global</h3><ul><li><a href="global.html#$">$</a></li><li><a href="global.html#__render">__render</a></li><li><a href="global.html#_addPolygonFeature">_addPolygonFeature</a></li><li><a href="global.html#_animatePan">_animatePan</a></li><li><a href="global.html#_appendChild">_appendChild</a></li><li><a href="global.html#_bindMouseHandlers">_bindMouseHandlers</a></li><li><a href="global.html#_boundingBox">_boundingBox</a></li><li><a href="global.html#_build">_build</a></li><li><a href="global.html#_checkForStroke">_checkForStroke</a></li><li><a href="global.html#_clusterData">_clusterData</a></li><li><a href="global.html#_colorize">_colorize</a></li><li><a href="global.html#_computeGradient">_computeGradient</a></li><li><a href="global.html#_connectEvents">_connectEvents</a></li><li><a href="global.html#_coordinates">_coordinates</a></li><li><a href="global.html#_createCanvas">_createCanvas</a></li><li><a href="global.html#_createCircle">_createCircle</a></li><li><a href="global.html#_createFeature">_createFeature</a></li><li><a href="global.html#_definitions">_definitions</a></li><li><a href="global.html#_deleteFeature">_deleteFeature</a></li><li><a href="global.html#_disconnectEvents">_disconnectEvents</a></li><li><a href="global.html#_drawFeatures">_drawFeatures</a></li><li><a href="global.html#_exit">_exit</a></li><li><a href="global.html#_feature">_feature</a></li><li><a href="global.html#_featureArray">_featureArray</a></li><li><a href="global.html#_featureToPolygons">_featureToPolygons</a></li><li><a href="global.html#_forward">_forward</a></li><li><a href="global.html#_generateQuads">_generateQuads</a></li><li><a href="global.html#_generateScale">_generateScale</a></li><li><a href="global.html#_geojsonCoordinates">_geojsonCoordinates</a></li><li><a href="global.html#_geojsonFeatureToAnnotation">_geojsonFeatureToAnnotation</a></li><li><a href="global.html#_geojsonGeometryType">_geojsonGeometryType</a></li><li><a href="global.html#_geojsonStyles">_geojsonStyles</a></li><li><a href="global.html#_getArrayBuffer">_getArrayBuffer</a></li><li><a href="global.html#_getLoopData">_getLoopData</a></li><li><a href="global.html#_getMouseButton">_getMouseButton</a></li><li><a href="global.html#_getMouseModifiers">_getMouseModifiers</a></li><li><a href="global.html#_getMousePosition">_getMousePosition</a></li><li><a href="global.html#_getString">_getString</a></li><li><a href="global.html#_handleBrush">_handleBrush</a></li><li><a href="global.html#_handleBrushend">_handleBrushend</a></li><li><a href="global.html#_handleDoubleClick">_handleDoubleClick</a></li><li><a href="global.html#_handleMouseClick">_handleMouseClick</a></li><li><a href="global.html#_handleMouseclick">_handleMouseclick</a></li><li><a href="global.html#_handleMouseDown">_handleMouseDown</a></li><li><a href="global.html#_handleMouseMove">_handleMouseMove</a></li><li><a href="global.html#_handleMousemove">_handleMousemove</a></li><li><a href="global.html#_handleMouseMoveDocument">_handleMouseMoveDocument</a></li><li><a href="global.html#_handleMouseUp">_handleMouseUp</a></li><li><a href="global.html#_handleMouseUpDocument">_handleMouseUpDocument</a></li><li><a href="global.html#_handleMouseWheel">_handleMouseWheel</a></li><li><a href="global.html#_handleZoom">_handleZoom</a></li><li><a href="global.html#_init">_init</a></li><li><a href="global.html#_inverse">_inverse</a></li><li><a href="global.html#_objectListAdd">_objectListAdd</a></li><li><a href="global.html#_objectListEnd">_objectListEnd</a></li><li><a href="global.html#_objectListGet">_objectListGet</a></li><li><a href="global.html#_objectListStart">_objectListStart</a></li><li><a href="global.html#_position">_position</a></li><li><a href="global.html#_positionToQuad">_positionToQuad</a></li><li><a href="global.html#_processSelection">_processSelection</a></li><li><a href="global.html#_removeFeature">_removeFeature</a></li><li><a href="global.html#_render">_render</a></li><li><a href="global.html#_renderBinnedData">_renderBinnedData</a></li><li><a href="global.html#_renderColorQuads">_renderColorQuads</a></li><li><a href="global.html#_renderFrame">_renderFrame</a></li><li><a href="global.html#_renderImageQuads">_renderImageQuads</a></li><li><a href="global.html#_renderOnCanvas">_renderOnCanvas</a></li><li><a href="global.html#_renderPoints">_renderPoints</a></li><li><a href="global.html#_resize">_resize</a></li><li><a href="global.html#_setClickMaybe">_setClickMaybe</a></li><li><a href="global.html#_style">_style</a></li><li><a href="global.html#_unbindMouseHandlers">_unbindMouseHandlers</a></li><li><a href="global.html#_update">_update</a></li><li><a href="global.html#_updateRangeTree">_updateRangeTree</a></li><li><a href="global.html#_updateTextures">_updateTextures</a></li><li><a href="global.html#_wipePolygons">_wipePolygons</a></li><li><a href="global.html#active">active</a></li><li><a href="global.html#actors">actors</a></li><li><a href="global.html#addAction">addAction</a></li><li><a href="global.html#addAnnotation">addAnnotation</a></li><li><a href="global.html#addChild">addChild</a></li><li><a href="global.html#addPromise">addPromise</a></li><li><a href="global.html#allowRotation">allowRotation</a></li><li><a href="global.html#annotationById">annotationById</a></li><li><a href="global.html#annotations">annotations</a></li><li><a href="global.html#api">api</a></li><li><a href="global.html#attribution">attribution</a></li><li><a href="global.html#bin">bin</a></li><li><a href="global.html#binned">binned</a></li><li><a href="global.html#bounds">bounds</a></li><li><a href="global.html#boundsFromZoomAndCenter">boundsFromZoomAndCenter</a></li><li><a href="global.html#boxSearch">boxSearch</a></li><li><a href="global.html#buildTime">buildTime</a></li><li><a href="global.html#camera">camera</a></li><li><a href="global.html#cancel">cancel</a></li><li><a href="global.html#canRead">canRead</a></li><li><a href="global.html#canvas">canvas</a></li><li><a href="global.html#categories">categories</a></li><li><a href="global.html#center">center</a></li><li><a href="global.html#children">children</a></li><li><a href="global.html#choropleth">choropleth</a></li><li><a href="global.html#clampBoundsX">clampBoundsX</a></li><li><a href="global.html#clampBoundsY">clampBoundsY</a></li><li><a href="global.html#clampZoom">clampZoom</a></li><li><a href="global.html#clear">clear</a></li><li><a href="global.html#clock">clock</a></li><li><a href="global.html#clustering">clustering</a></li><li><a href="global.html#computeGeodeticSurfaceNormal">computeGeodeticSurfaceNormal</a></li><li><a href="global.html#contextRenderer">contextRenderer</a></li><li><a href="global.html#contour">contour</a></li><li><a href="global.html#coordinates">coordinates</a></li><li><a href="global.html#createChoropleth">createChoropleth</a></li><li><a href="global.html#createContours">createContours</a></li><li><a href="global.html#createFeature">createFeature</a></li><li><a href="global.html#createLayer">createLayer</a></li><li><a href="global.html#createWidget">createWidget</a></li><li><a href="global.html#data">data</a></li><li><a href="global.html#dataTime">dataTime</a></li><li><a href="global.html#deleteFeature">deleteFeature</a></li><li><a href="global.html#deleteLayer">deleteLayer</a></li><li><a href="global.html#deleteWidget">deleteWidget</a></li><li><a href="global.html#delta">delta</a></li><li><a href="global.html#destroy">destroy</a></li><li><a href="global.html#discreteZoom">discreteZoom</a></li><li><a href="global.html#displayDistance">displayDistance</a></li><li><a href="global.html#displayToGcs">displayToGcs</a></li><li><a href="global.html#displayToWorld">displayToWorld</a></li><li><a href="global.html#draw">draw</a></li><li><a href="global.html#end">end</a></li><li><a href="global.html#exit">exit</a></li><li><a href="global.html#featureGcsToDisplay">featureGcsToDisplay</a></li><li><a href="global.html#features">features</a></li><li><a href="global.html#featureVertices">featureVertices</a></li><li><a href="global.html#fileReader">fileReader</a></li><li><a href="global.html#forward">forward</a></li><li><a href="global.html#framerate">framerate</a></li><li><a href="global.html#fromLocal">fromLocal</a></li><li><a href="global.html#gcs">gcs</a></li><li><a href="global.html#gcsPosition">gcsPosition</a></li><li><a href="global.html#gcsToDisplay">gcsToDisplay</a></li><li><a href="global.html#gcsToWorld">gcsToWorld</a></li><li><a href="global.html#geo_action">geo_action</a></li><li><a href="global.html#geojson">geojson</a></li><li><a href="global.html#geometry">geometry</a></li><li><a href="global.html#geoOff">geoOff</a></li><li><a href="global.html#geoOn">geoOn</a></li><li><a href="global.html#geoTrigger">geoTrigger</a></li><li><a href="global.html#globals">globals</a></li><li><a href="global.html#hasAction">hasAction</a></li><li><a href="global.html#height">height</a></li><li><a href="global.html#id">id</a></li><li><a href="global.html#ingcs">ingcs</a></li><li><a href="global.html#initialized">initialized</a></li><li><a href="global.html#intensity">intensity</a></li><li><a href="global.html#interactor">interactor</a></li><li><a href="global.html#inverse">inverse</a></li><li><a href="global.html#isInViewport">isInViewport</a></li><li><a href="global.html#keyboard">keyboard</a></li><li><a href="global.html#layer">layer</a></li><li><a href="global.html#layers">layers</a></li><li><a href="global.html#line">line</a></li><li><a href="global.html#linkFeatures">linkFeatures</a></li><li><a href="global.html#links">links</a></li><li><a href="global.html#loop">loop</a></li><li><a href="global.html#map">map</a></li><li><a href="global.html#maximumRadius">maximumRadius</a></li><li><a href="global.html#maxIntensity">maxIntensity</a></li><li><a href="global.html#minimumRadius">minimumRadius</a></li><li><a href="global.html#minIntensity">minIntensity</a></li><li><a href="global.html#mode">mode</a></li><li><a href="global.html#modified">modified</a></li><li><a href="global.html#mouse">mouse</a></li><li><a href="global.html#mouseClick">mouseClick</a></li><li><a href="global.html#mouseMove">mouseMove</a></li><li><a href="global.html#moveDown">moveDown</a></li><li><a href="global.html#moveToBottom">moveToBottom</a></li><li><a href="global.html#moveToTop">moveToTop</a></li><li><a href="global.html#moveUp">moveUp</a></li><li><a href="global.html#name">name</a></li><li><a href="global.html#node">node</a></li><li><a href="global.html#nodeFeature">nodeFeature</a></li><li><a href="global.html#nodes">nodes</a></li><li><a href="global.html#now">now</a></li><li><a href="global.html#object">object</a></li><li><a href="global.html#onIdle">onIdle</a></li><li><a href="global.html#opacity">opacity</a></li><li><a href="global.html#options">options</a></li><li><a href="global.html#origin">origin</a></li><li><a href="global.html#pan">pan</a></li><li><a href="global.html#parent">parent</a></li><li><a href="global.html#parentCanvas">parentCanvas</a></li><li><a href="global.html#pause">pause</a></li><li><a href="global.html#pointAnnotation">pointAnnotation</a></li><li><a href="global.html#pointSearch">pointSearch</a></li><li><a href="global.html#polygonAnnotation">polygonAnnotation</a></li><li><a href="global.html#position">position</a></li><li><a href="global.html#radii">radii</a></li><li><a href="global.html#radiiSquared">radiiSquared</a></li><li><a href="global.html#read">read</a></li><li><a href="global.html#rectangleAnnotation">rectangleAnnotation</a></li><li><a href="global.html#removeAction">removeAction</a></li><li><a href="global.html#removeAllAnnotations">removeAllAnnotations</a></li><li><a href="global.html#removeAnnotation">removeAnnotation</a></li><li><a href="global.html#removeChild">removeChild</a></li><li><a href="global.html#renderer">renderer</a></li><li><a href="global.html#rendererName">rendererName</a></li><li><a href="global.html#reposition">reposition</a></li><li><a href="global.html#reset">reset</a></li><li><a href="global.html#resize">resize</a></li><li><a href="global.html#rotatedSize">rotatedSize</a></li><li><a href="global.html#rotation">rotation</a></li><li><a href="global.html#scalar">scalar</a></li><li><a href="global.html#scale">scale</a></li><li><a href="global.html#scaleFactor">scaleFactor</a></li><li><a href="global.html#select">select</a></li><li><a href="global.html#selectionAPI">selectionAPI</a></li><li><a href="global.html#simulateEvent">simulateEvent</a></li><li><a href="global.html#size">size</a></li><li><a href="global.html#source">source</a></li><li><a href="global.html#springBack">springBack</a></li><li><a href="global.html#start">start</a></li><li><a href="global.html#state">state</a></li><li><a href="global.html#step">step</a></li><li><a href="global.html#stepBackward">stepBackward</a></li><li><a href="global.html#stepForward">stepForward</a></li><li><a href="global.html#sticky">sticky</a></li><li><a href="global.html#style">style</a></li><li><a href="global.html#target">target</a></li><li><a href="global.html#toLocal">toLocal</a></li><li><a href="global.html#transformGeometry">transformGeometry</a></li><li><a href="global.html#transformPoint">transformPoint</a></li><li><a href="global.html#transition">transition</a></li><li><a href="global.html#transitionCancel">transitionCancel</a></li><li><a href="global.html#type">type</a></li><li><a href="global.html#unitsPerPixel">unitsPerPixel</a></li><li><a href="global.html#updateAttribution">updateAttribution</a></li><li><a href="global.html#updateDelay">updateDelay</a></li><li><a href="global.html#updateTime">updateTime</a></li><li><a href="global.html#validateAttribute">validateAttribute</a></li><li><a href="global.html#verticesPerFeature">verticesPerFeature</a></li><li><a href="global.html#visible">visible</a></li><li><a href="global.html#width">width</a></li><li><a href="global.html#worldToDisplay">worldToDisplay</a></li><li><a href="global.html#worldToGcs">worldToGcs</a></li><li><a href="global.html#zIndex">zIndex</a></li><li><a href="global.html#zoom">zoom</a></li><li><a href="global.html#zoomAndCenterFromBounds">zoomAndCenterFromBounds</a></li><li><a href="global.html#zoomRange">zoomRange</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.1</a> on Fri Oct 14 2016 13:39:42 GMT-0400 (EDT)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
