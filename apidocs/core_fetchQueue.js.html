<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: core/fetchQueue.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: core/fetchQueue.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>(function () {
  'use strict';

  //////////////////////////////////////////////////////////////////////////////
  /**
   * This class implements a queue for Deferred objects.  Whenever one of the
   * objects in the queue completes (resolved or rejected), another item in the
   * queue is processed.  The number of concurrently processing items can be
   * adjusted.  At this time (2015-12-29) most major browsers support 6
   * concurrent requests from any given server, so, when using the queue for
   * tile images, thie number of concurrent requests should be 6 * (number of
   * subdomains serving tiles).
   *
   * @class
   *
   * @param {Object?} [options] A configuration object for the queue
   * @param {Number} [options.size=6] The maximum number of concurrent deferred
   *    objects.
   * @param {Number} [options.track=600] The number of objects that are tracked
   *    that trigger checking if any of them have been abandoned.  The fetch
   *    queue can grow to the greater of this size and the number of items that
   *    are still needed.  Setting this to a low number will increase
   *    processing time, to a high number can increase memory.  Ideally, it
   *    should reflect the number of items that are kept in memory elsewhere.
   *    If needed is null, this is ignored.
   * @param {function} [options.needed=null] If set, this function is passed a
   *    Deferred object and must return a truthy value if the object is still
   *    needed.
   */
  //////////////////////////////////////////////////////////////////////////////
  geo.fetchQueue = function (options) {
    if (!(this instanceof geo.fetchQueue)) {
      return new geo.fetchQueue(options);
    }
    options = options || {};
    this._size = options.size || 6;
    this._track = options.track || 600;
    this._needed = options.needed || null;
    this._batch = false;

    var m_this = this,
        m_next_batch = 1;

    /**
     * Get/set the maximum concurrent deferred object size.
     */
    Object.defineProperty(this, 'size', {
      get: function () { return this._size; },
      set: function (n) {
        this._size = n;
        this.next_item();
      }
    });

    /**
     * Get the current queue size.
     */
    Object.defineProperty(this, 'length', {
      get: function () { return this._queue.length; }
    });

    /**
     * Get the current number of processing items.
     */
    Object.defineProperty(this, 'processing', {
      get: function () { return this._processing; }
    });

    /**
     * Remove all items from the queue.
     */
    this.clear = function () {
      this._queue = [];
      this._processing = 0;
      return this;
    };

    /**
     * Add a Deferred object to the queue.
     * @param {Deferred} defer Deferred object to add to the queue.
     * @param {function} callback a function to call when the item's turn is
     *  granted.
     * @param {boolean} atEnd if false, add the item to the front of the queue
     *  if batching is turned off or at the end of the current batch if it is
     *  turned on.  If true, always add the item to the end of the queue.
     */
    this.add = function (defer, callback, atEnd) {
      if (defer.__fetchQueue) {
        var pos = $.inArray(defer, this._queue);
        if (pos >= 0) {
          this._queue.splice(pos, 1);
          this._addToQueue(defer, atEnd);
          return defer;
        }
      }
      var wait = new $.Deferred();
      var process = new $.Deferred();
      wait.then(function () {
        $.when(callback.call(defer)).always(process.resolve);
      }, process.resolve);
      defer.__fetchQueue = wait;
      this._addToQueue(defer, atEnd);
      $.when(wait, process).always(function () {
        if (m_this._processing > 0) {
          m_this._processing -= 1;
        }
        m_this.next_item();
      }).promise(defer);
      m_this.next_item();
      return defer;
    };

    /**
     * Add an item to the queue.  If batches are being used, add it at after
     * other items in the same batch.
     * @param {Deferred} defer Deferred object to add to the queue.
     * @param {boolean} atEnd if false, add the item to the front of the queue
     *  if batching is turned off or at the end of the current batch if it is
     *  turned on.  If true, always add the item to the end of the queue.
     */
    this._addToQueue = function (defer, atEnd) {
      defer.__fetchQueue._batch = this._batch;
      if (atEnd) {
        this._queue.push(defer);
      } else if (!this._batch) {
        this._queue.unshift(defer);
      } else {
        for (var i = 0; i &lt; this._queue.length; i += 1) {
          if (this._queue[i].__fetchQueue._batch !== this._batch) {
            break;
          }
        }
        this._queue.splice(i, 0, defer);
      }
    };

    /**
     * Get the position of a deferred object in the queue.
     * @param {Deferred} defer Deferred object to get the position of.
     * @returns {number} -1 if not in the queue, or the position in the queue.
     */
    this.get = function (defer) {
      return $.inArray(defer, this._queue);
    };

    /**
     * Remove a Deferred object from the queue.
     * @param {Deferred} defer Deferred object to add to the queue.
     * @returns {bool} true if the object was removed
     */
    this.remove = function (defer) {
      var pos = $.inArray(defer, this._queue);
      if (pos >= 0) {
        this._queue.splice(pos, 1);
        return true;
      }
      return false;
    };

    /**
     * Start a new batch or clear using batches.
     * @param {boolean} start true to start a new batch, false to turn off
     *                        using batches.  Undefined to return the current
     *                        state of batches.
     * @return {Number|boolean|Object} the current batch state or this object.
     */
    this.batch = function (start) {
      if (start === undefined) {
        return this._batch;
      }
      if (!start) {
        this._batch = false;
      } else {
        this._batch = m_next_batch;
        m_next_batch += 1;
      }
      return this;
    };

    /**
     * Check if any items are queued and if there if there are not too many
     * deferred objects being processed.  If so, process more items.
     */
    this.next_item = function () {
      if (m_this._innextitem) {
        return;
      }
      m_this._innextitem = true;
      /* if the queue is greater than the track size, check each item to see
       * if it is still needed. */
      if (m_this._queue.length > m_this._track &amp;&amp; this._needed) {
        for (var i = m_this._queue.length - 1; i >= 0; i -= 1) {
          if (!m_this._needed(m_this._queue[i])) {
            var discard = m_this._queue.splice(i, 1)[0];
            m_this._processing += 1;
            discard.__fetchQueue.reject();
            delete discard.__fetchQueue;
          }
        }
      }
      while (m_this._processing &lt; m_this._size &amp;&amp; m_this._queue.length) {
        var defer = m_this._queue.shift();
        if (defer.__fetchQueue) {
          m_this._processing += 1;
          var needed = m_this._needed ? m_this._needed(defer) : true;
          if (needed) {
            defer.__fetchQueue.resolve();
          } else {
            defer.__fetchQueue.reject();
          }
          delete defer.__fetchQueue;
        }
      }
      m_this._innextitem = false;
    };

    this.clear();
    return this;
  };
})();
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="geo.camera.html">camera</a></li><li><a href="geo.choroplethFeature.html">choroplethFeature</a></li><li><a href="geo.clock.html">clock</a></li><li><a href="geo.contourFeature.html">contourFeature</a></li><li><a href="geo.d3.d3Renderer.html">d3Renderer</a></li><li><a href="geo.d3.graphFeature.html">graphFeature</a></li><li><a href="geo.d3.lineFeature.html">lineFeature</a></li><li><a href="geo.d3.object.html">object</a></li><li><a href="geo.d3.pathFeature.html">pathFeature</a></li><li><a href="geo.d3.planeFeature.html">planeFeature</a></li><li><a href="geo.d3.pointFeature.html">pointFeature</a></li><li><a href="geo.d3.vectorFeature.html">vectorFeature</a></li><li><a href="geo.ellipsoid.html">ellipsoid</a></li><li><a href="geo.feature.html">feature</a></li><li><a href="geo.featureLayer.html">featureLayer</a></li><li><a href="geo.fetchQueue.html">fetchQueue</a></li><li><a href="geo.fileReader.html">fileReader</a></li><li><a href="geo.geomFeature.html">geomFeature</a></li><li><a href="geo.gl.choroplethFeature.html">choroplethFeature</a></li><li><a href="geo.gl.contourFeature.html">contourFeature</a></li><li><a href="geo.gl.geomFeature.html">geomFeature</a></li><li><a href="geo.gl.lineFeature.html">lineFeature</a></li><li><a href="geo.gl.planeFeature.html">planeFeature</a></li><li><a href="geo.gl.pointFeature.html">pointFeature</a></li><li><a href="geo.gl.polygonFeature.html">polygonFeature</a></li><li><a href="geo.gl.quadFeature.html">quadFeature</a></li><li><a href="geo.gl.vglRenderer.html">vglRenderer</a></li><li><a href="geo.graphFeature.html">graphFeature</a></li><li><a href="geo.gui.legendWidget.html">legendWidget</a></li><li><a href="geo.gui.sliderWidget.html">sliderWidget</a></li><li><a href="geo.gui.svgWidget.html">svgWidget</a></li><li><a href="geo.gui.uiLayer.html">uiLayer</a></li><li><a href="geo.gui.widget.html">widget</a></li><li><a href="geo.imageTile.html">imageTile</a></li><li><a href="geo.jsonReader.html">jsonReader</a></li><li><a href="geo.layer.html">layer</a></li><li><a href="geo.lineFeature.html">lineFeature</a></li><li><a href="geo.map.html">map</a></li><li><a href="geo.mapInteractor.html">mapInteractor</a></li><li><a href="geo.object.html">object</a></li><li><a href="geo.osmLayer.html">osmLayer</a></li><li><a href="geo.pathFeature.html">pathFeature</a></li><li><a href="geo.planeFeature.html">planeFeature</a></li><li><a href="geo.pointFeature.html">pointFeature</a></li><li><a href="geo.pointSpritesGeomFeature.html">pointSpritesGeomFeature</a></li><li><a href="geo.polygonFeature.html">polygonFeature</a></li><li><a href="geo.quadFeature.html">quadFeature</a></li><li><a href="geo.renderer.html">renderer</a></li><li><a href="geo.sceneObject.html">sceneObject</a></li><li><a href="geo.tile.html">tile</a></li><li><a href="geo.tileCache.html">tileCache</a></li><li><a href="geo.tileLayer.html">tileLayer</a></li><li><a href="geo.timestamp.html">timestamp</a></li><li><a href="geo.transform.html">transform</a></li><li><a href="geo.util.ClusterGroup.html">ClusterGroup</a></li><li><a href="geo.vectorFeature.html">vectorFeature</a></li><li><a href="jQuery.fn.geojsMap.html">geojsMap</a></li></ul><h3>Namespaces</h3><ul><li><a href="geo.html">geo</a></li><li><a href="geo.d3.html">d3</a></li><li><a href="geo.event.html">event</a></li><li><a href="geo.event.camera.html">camera</a></li><li><a href="geo.event.clock.html">clock</a></li><li><a href="geo.event.feature.html">feature</a></li><li><a href="geo.gl.html">gl</a></li><li><a href="geo.gui.html">gui</a></li><li><a href="geo.util.html">util</a></li></ul><h3><a href="global.html">Global</a></h3>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.0</a> on Thu Feb 18 2016 10:07:42 GMT-0500 (EST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
